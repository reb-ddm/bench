/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef __mode_t mode_t;
typedef unsigned long size_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
typedef int wchar_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
struct allocator {
   void *(*allocate)(size_t  ) ;
   void *(*reallocate)(void * , size_t  ) ;
   void (*free)(void * ) ;
   void (*die)(size_t  ) ;
};
typedef long __off64_t;
typedef long __ssize_t;
typedef __ssize_t ssize_t;
typedef long ptrdiff_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
struct obstack;
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
struct argv_iterator;
enum argv_iter_err {
    AI_ERR_OK = 1,
    AI_ERR_EOF = 2,
    AI_ERR_MEM = 3,
    AI_ERR_READ = 4
} ;
struct argv_iterator {
   FILE *fp ;
   size_t item_idx ;
   char *tok ;
   size_t buf_len ;
   char **arg_list ;
   char **p ;
};
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
struct __locale_data;
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef unsigned int __socklen_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct sockaddr_at;
struct sockaddr_ax25;
struct sockaddr_dl;
struct sockaddr_eon;
struct sockaddr_in;
struct sockaddr_in6;
struct sockaddr_inarp;
struct sockaddr_ipx;
struct sockaddr_iso;
struct sockaddr_ns;
struct sockaddr_un;
struct sockaddr_x25;
union __anonunion___SOCKADDR_ARG_18 {
   struct sockaddr * __restrict  __sockaddr__ ;
   struct sockaddr_at * __restrict  __sockaddr_at__ ;
   struct sockaddr_ax25 * __restrict  __sockaddr_ax25__ ;
   struct sockaddr_dl * __restrict  __sockaddr_dl__ ;
   struct sockaddr_eon * __restrict  __sockaddr_eon__ ;
   struct sockaddr_in * __restrict  __sockaddr_in__ ;
   struct sockaddr_in6 * __restrict  __sockaddr_in6__ ;
   struct sockaddr_inarp * __restrict  __sockaddr_inarp__ ;
   struct sockaddr_ipx * __restrict  __sockaddr_ipx__ ;
   struct sockaddr_iso * __restrict  __sockaddr_iso__ ;
   struct sockaddr_ns * __restrict  __sockaddr_ns__ ;
   struct sockaddr_un * __restrict  __sockaddr_un__ ;
   struct sockaddr_x25 * __restrict  __sockaddr_x25__ ;
};
typedef union __anonunion___SOCKADDR_ARG_18  __attribute__((__transparent_union__)) __SOCKADDR_ARG;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
union __anonunion___in6_u_22 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_22 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
enum canonicalize_mode_t {
    CAN_EXISTING = 0,
    CAN_ALL_BUT_LAST = 1,
    CAN_MISSING = 2
} ;
typedef enum canonicalize_mode_t canonicalize_mode_t;
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
typedef struct hash_tuning Hash_tuning;
struct hash_table;
typedef struct hash_table Hash_table;
typedef __off_t off_t;
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
struct sha1_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t E ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
struct sha256_ctx {
   uint32_t state[8] ;
   uint32_t total[2] ;
   size_t buflen ;
   uint32_t buffer[32] ;
};
typedef unsigned long uint64_t;
typedef uint64_t u64;
struct sha512_ctx {
   u64 state[8] ;
   u64 total[2] ;
   size_t buflen ;
   u64 buffer[32] ;
};
typedef __ino_t ino_t;
typedef __dev_t dev_t;
typedef unsigned long uintmax_t;
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
struct di_set;
struct ino_map;
typedef size_t hashint;
struct di_ent {
   dev_t dev ;
   struct hash_table *ino_set ;
};
struct di_set {
   struct hash_table *dev_map ;
   struct ino_map *ino_map ;
   struct di_ent *probe ;
};
typedef __time_t time_t;
typedef int __int32_t;
typedef struct _IO_FILE __FILE;
union __anonunion___value_4 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_3 {
   int __count ;
   union __anonunion___value_4 __value ;
};
typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
struct exclude;
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
typedef struct mbchar mbchar_t;
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
typedef struct mbuiter_multi mbui_iterator_t;
struct patopts {
   char const   *pattern ;
   int options ;
};
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
union __anonunion_v_31 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_31 v ;
};
struct exclude {
   struct exclude_segment *head ;
   struct exclude_segment *tail ;
};
enum __anonenum_fadvice_t_20 {
    FADVISE_NORMAL = 0,
    FADVISE_SEQUENTIAL = 2,
    FADVISE_NOREUSE = 5,
    FADVISE_DONTNEED = 4,
    FADVISE_WILLNEED = 3,
    FADVISE_RANDOM = 1
} ;
typedef enum __anonenum_fadvice_t_20 fadvice_t;
typedef __gnuc_va_list va_list;
struct F_triple {
   char *name ;
   ino_t st_ino ;
   dev_t st_dev ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
typedef long __suseconds_t;
typedef int __clockid_t;
typedef __clockid_t clockid_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
typedef __gid_t gid_t;
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
struct heap;
struct heap {
   void **array ;
   size_t capacity ;
   size_t count ;
   int (*compare)(void const   * , void const   * ) ;
};
typedef long intmax_t;
typedef int __gwchar_t;
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
typedef enum strtol_error strtol_error;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
typedef struct I_ring I_ring;
typedef __uid_t uid_t;
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
union __anonunion_id_24 {
   uid_t u ;
   gid_t g ;
};
struct userid {
   union __anonunion_id_24 id ;
   struct userid *next ;
   char name[] ;
};
struct ino_map_ent {
   ino_t ino ;
   size_t mapped_ino ;
};
struct ino_map {
   struct hash_table *map ;
   size_t next_mapped_ino ;
   struct ino_map_ent *probe ;
};
struct linebuffer {
   size_t size ;
   size_t length ;
   char *buffer ;
};
typedef int nl_item;
typedef unsigned long pthread_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
union __anonunion_pthread_mutexattr_t_12 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_12 pthread_mutexattr_t;
typedef int pthread_once_t;
typedef pthread_mutex_t gl_recursive_lock_t;
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
enum __anonenum_mbs_align_t_1 {
    MBS_ALIGN_LEFT = 0,
    MBS_ALIGN_RIGHT = 1,
    MBS_ALIGN_CENTER = 2
} ;
typedef enum __anonenum_mbs_align_t_1 mbs_align_t;
typedef unsigned long longword;
struct savewd;
typedef int __pid_t;
typedef __pid_t pid_t;
enum __anonenum_state_18 {
    INITIAL_STATE = 0,
    FD_STATE = 1,
    FD_POST_CHDIR_STATE = 2,
    FORKING_STATE = 3,
    ERROR_STATE = 4,
    FINAL_STATE = 5
} ;
union __anonunion_val_19 {
   int fd ;
   int errnum ;
   pid_t child ;
};
struct savewd {
   enum __anonenum_state_18 state ;
   union __anonunion_val_19 val ;
};
struct mode_change;
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
enum nproc_query {
    NPROC_ALL = 0,
    NPROC_CURRENT = 1,
    NPROC_CURRENT_OVERRIDABLE = 2
} ;
typedef unsigned long __cpu_mask;
struct __anonstruct_cpu_set_t_24 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
typedef struct __anonstruct_cpu_set_t_24 cpu_set_t;
typedef long long_time_t;
struct __anonstruct_textint_29 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
typedef struct __anonstruct_textint_29 textint;
struct __anonstruct_table_30 {
   char const   *name ;
   int type ;
   int value ;
};
typedef struct __anonstruct_table_30 table;
struct __anonstruct_relative_time_33 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
typedef struct __anonstruct_relative_time_33 relative_time;
struct __anonstruct_parser_control_34 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
typedef struct __anonstruct_parser_control_34 parser_control;
union YYSTYPE;
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
typedef union YYSTYPE YYSTYPE;
typedef unsigned char yytype_uint8;
typedef signed char yytype_int8;
typedef short yytype_int16;
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
typedef unsigned short fpucw_t;
struct quoting_options;
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
struct slotvec {
   size_t size ;
   char *val ;
};
struct randread_source;
typedef uintmax_t randint;
struct randint_source;
struct randint_source {
   struct randread_source *source ;
   randint randnum ;
   randint randmax ;
};
struct sparse_ent_ {
   size_t index ;
   size_t val ;
};
typedef Hash_table sparse_map;
typedef unsigned long uint_least64_t;
typedef uint_least64_t isaac_word;
struct isaac_state {
   isaac_word m[1 << 8] ;
   isaac_word a ;
   isaac_word b ;
   isaac_word c ;
};
union __anonunion_data_32 {
   isaac_word w[1 << 8] ;
   unsigned char b[(unsigned long )(1 << 8) * sizeof(isaac_word )] ;
};
struct isaac {
   size_t buffered ;
   struct isaac_state state ;
   union __anonunion_data_32 data ;
};
union __anonunion_buf_31 {
   char c[2UL * ((unsigned long )(1 << 8) * sizeof(isaac_word ))] ;
   struct isaac isaac ;
};
struct randread_source {
   FILE *source ;
   void (*handler)(void const   * ) ;
   void const   *handler_arg ;
   union __anonunion_buf_31 buf ;
};
struct tokenbuffer {
   size_t size ;
   char *buffer ;
};
typedef struct tokenbuffer token_buffer;
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
union __anonunion_temp_26 {
   long tempint ;
   void *tempptr ;
};
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_26 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
struct saved_cwd {
   int desc ;
   char *name ;
};
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_2 __sigset_t;
union __anonunion_50 {
   int __in ;
   int __i ;
};
union __anonunion_51 {
   int __in ;
   int __i ;
};
union __anonunion_52 {
   int __in ;
   int __i ;
};
typedef void *iconv_t;
union __anonunion_tmp_21 {
   unsigned int align ;
   char buf[4096] ;
};
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
typedef struct mbiter_multi mbi_iterator_t;
typedef uint32_t ucs4_t;
struct fs_res {
   dev_t dev ;
   int resolution ;
   _Bool exact ;
};
struct cd_buf {
   int fd ;
};
struct fs_usage {
   uintmax_t fsu_blocksize ;
   uintmax_t fsu_blocks ;
   uintmax_t fsu_bfree ;
   uintmax_t fsu_bavail ;
   _Bool fsu_bavail_top_bit_set ;
   uintmax_t fsu_files ;
   uintmax_t fsu_ffree ;
};
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
typedef struct __anonstruct___fsid_t_1 __fsid_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsfilcnt_t;
struct statfs {
   long f_type ;
   long f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   long f_namelen ;
   long f_frsize ;
   long f_flags ;
   long f_spare[4] ;
};
typedef __nlink_t nlink_t;
struct _ftsent;
union __anonunion_fts_cycle_20 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
struct __anonstruct_FTS_19 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_20 fts_cycle ;
   I_ring fts_fd_ring ;
};
typedef struct __anonstruct_FTS_19 FTS;
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   DIR *fts_dirp ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
typedef struct _ftsent FTSENT;
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
typedef long long xtime_t;
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
struct option_list {
   struct rpl_option  const  *p ;
   struct option_list *next ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
union __anonunion_memory_double_2 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
typedef union __anonunion_memory_double_2 memory_double;
struct mount_entry {
   char *me_devname ;
   char *me_mountdir ;
   char *me_type ;
   dev_t me_dev ;
   unsigned int me_dummy : 1 ;
   unsigned int me_remote : 1 ;
   unsigned int me_type_malloced : 1 ;
   struct mount_entry *me_next ;
};
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
enum __anonenum_arg_type_3 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
typedef enum __anonenum_arg_type_3 arg_type;
union __anonunion_a_5 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
struct __anonstruct_argument_4 {
   arg_type type ;
   union __anonunion_a_5 a ;
};
typedef struct __anonstruct_argument_4 argument;
struct __anonstruct_arguments_6 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
typedef struct __anonstruct_arguments_6 arguments;
struct __anonstruct_char_directive_7 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
typedef struct __anonstruct_char_directive_7 char_directive;
struct __anonstruct_char_directives_8 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
typedef struct __anonstruct_char_directives_8 char_directives;
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
struct __anonstruct_ut_tv_16 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_16 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
typedef struct utmpx STRUCT_UTMP;
struct numname {
   int num ;
   char const   name[8] ;
};
union __anonunion___u_36 {
   long double __l ;
   int __i[3] ;
};
struct fs_type_list {
   char *fs_name ;
   struct fs_type_list *fs_next ;
};
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 

  {
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 

  {
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 

  {
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(2,4))) ;
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(3,5))) ;
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                            int __flag ) 
{ int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int stat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int lstat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern int fstatat64(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                              int __flag ) 
{ int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
int set_acl(char const   *name , int desc , mode_t mode ) ;
int qset_acl(char const   *name , int desc , mode_t mode ) ;
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                   char ** __restrict  __endptr )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                       char ** __restrict  __endptr ,
                                                       int __base )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern double atof(char const   *__nptr ) 
{ double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern int atoi(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern long atol(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__warn_unused_result__,
__pure__, __nonnull__(1))) ;
__inline extern long long atoll(char const   *__nptr ) 
{ long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                     char const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                                                     wchar_t const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ptsname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   * __restrict  __name ,
                                                          char * __restrict  __resolved ,
                                                          size_t __resolvedlen )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   * __restrict  __name ,
                                                            char * __restrict  __resolved )  __asm__("realpath") __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                  char * __restrict  __resolved )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                  char * __restrict  __resolved )  __attribute__((__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                                                                              char * __restrict  __resolved ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__resolved, 1);
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
  }
  tmp___2 = __realpath_alias(__name, __resolved);
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen )  __asm__("ptsname_r") __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"),
__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ptsname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__nonnull__(2))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ptsname_r)(int __fd ,
                                                                                                     char *__buf ,
                                                                                                     size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
    return ((int __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar )  __asm__("wctomb") __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wctomb)(char *__s , wchar_t __wchar )  __attribute__((__warn_unused_result__)) ;
__inline extern int __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) wctomb)(char *__s ,
                                                                                                                          wchar_t __wchar ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___2) {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
      return ((int __attribute__((__artificial__))  )tmp___0);
    }
  }
  tmp___3 = __wctomb_alias(__s, __wchar);
  return ((int __attribute__((__artificial__))  )tmp___3);
}
}
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t * __restrict  __dst ,
                                                           char const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t * __restrict  __dst ,
                                                             char const   * __restrict  __src ,
                                                             size_t __len )  __asm__("mbstowcs")  ;
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                char const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                     char const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                       char const   * __restrict  __src ,
                                                                                                       size_t __len ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char * __restrict  __dst ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char * __restrict  __dst ,
                                                             wchar_t const   * __restrict  __src ,
                                                             size_t __len )  __asm__("wcstombs")  ;
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char * __restrict  __dst ,
                                                                wchar_t const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                                                     wchar_t const   * __restrict  __src ,
                                                                                                                                     size_t __len ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                       wchar_t const   * __restrict  __src ,
                                                                                                       size_t __len ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
char const   *quote(char const   *name ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category )  __attribute__((__format_arg__(2))) ;
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                                                                                  void const   * __restrict  __src ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memmove)(void *__dest ,
                                                                                                                                   void const   *__src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memset)(void *__dest ,
                                                                                                                                  int __ch ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcat)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncat)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                                                   void const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bcopy)(void const   *__src ,
                                                                                                                                void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bzero)(void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while ((int const   )*(__s + __result) == (int const   )__accept) {
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
        break;
      }
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
          break;
        }
      }
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*__s != 0) {
      if ((int const   )*__s != (int const   )__accept1) {
        if (! ((int const   )*__s != (int const   )__accept2)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )*__s == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((size_t )__s);
  }
  return (tmp);
}
}
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*__s != 0) {
      if ((int const   )*__s != (int const   )__accept1) {
        if ((int const   )*__s != (int const   )__accept2) {
          if (! ((int const   )*__s != (int const   )__accept3)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )*__s == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((size_t )__s);
  }
  return (tmp);
}
}
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
    __s = *__nextp;
  }
  while ((int )*__s == (int )__sep) {
    __s ++;
  }
  __result = (char *)((void *)0);
  if ((int )*__s != 0) {
    tmp = __s;
    __s ++;
    __result = tmp;
    while ((int )*__s != 0) {
      tmp___0 = __s;
      __s ++;
      if ((int )*tmp___0 == (int )__sep) {
        *(__s + -1) = (char )'\000';
        break;
      }
    }
  }
  *__nextp = __s;
  return (__result);
}
}
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
  __retval = *__s;
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
    tmp___0 = tmp___2;
    *__s = tmp___0;
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      tmp = *__s;
      (*__s) ++;
      *tmp = (char )'\000';
    }
  }
  return (__retval);
}
}
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
  __retval = *__s;
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    __cp = __retval;
    while (1) {
      if ((int )*__cp == 0) {
        __cp = (char *)((void *)0);
        break;
      }
      if ((int )*__cp == (int )__reject1) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else
      if ((int )*__cp == (int )__reject2) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      }
      __cp ++;
    }
    *__s = __cp;
  }
  return (__retval);
}
}
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
  __retval = *__s;
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    __cp = __retval;
    while (1) {
      if ((int )*__cp == 0) {
        __cp = (char *)((void *)0);
        break;
      }
      if ((int )*__cp == (int )__reject1) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else
      if ((int )*__cp == (int )__reject2) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else
      if ((int )*__cp == (int )__reject3) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      }
      __cp ++;
    }
    *__s = __cp;
  }
  return (__retval);
}
}
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                                                                                  void const   * __restrict  __src ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memcpy)(void * __restrict  __dest ,
                                                                                                    void const   * __restrict  __src ,
                                                                                                    size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 0);
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memmove)(void *__dest ,
                                                                                                                                   void const   *__src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memmove)(void *__dest ,
                                                                                                     void const   *__src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                                                   void const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) mempcpy)(void * __restrict  __dest ,
                                                                                                     void const   * __restrict  __src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 0);
  tmp___0 = __builtin___mempcpy_chk((void *)__dest, (void const   *)__src, __len,
                                    tmp);
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memset)(void *__dest ,
                                                                                                                                  int __ch ,
                                                                                                                                  size_t __len )  __attribute__((__nonnull__(1))) ;
__inline extern void __attribute__((__artificial__))  *( __attribute__((__always_inline__)) memset)(void *__dest ,
                                                                                                    int __ch ,
                                                                                                    size_t __len ) 
{ unsigned long tmp ;
  void *tmp___0 ;

  {
  tmp = __builtin_object_size(__dest, 0);
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
  return ((void __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bcopy)(void const   *__src ,
                                                                                                                                void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bcopy)(void const   *__src ,
                                                                                                  void *__dest ,
                                                                                                  size_t __len ) 
{ unsigned long tmp ;

  {
  tmp = __builtin_object_size(__dest, 0);
  __builtin___memmove_chk(__dest, __src, __len, tmp);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bzero)(void *__dest ,
                                                                                                                                size_t __len )  __attribute__((__nonnull__(1))) ;
__inline extern void __attribute__((__artificial__))  ( __attribute__((__always_inline__)) bzero)(void *__dest ,
                                                                                                  size_t __len ) 
{ unsigned long tmp ;

  {
  tmp = __builtin_object_size(__dest, 0);
  __builtin___memset_chk(__dest, '\000', __len, tmp);
  return;
}
}
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcpy)(char * __restrict  __dest ,
                                                                                                    char const   * __restrict  __src ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpcpy)(char * __restrict  __dest ,
                                                                                                    char const   * __restrict  __src ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___stpcpy_chk((char *)__dest, (char const   *)__src, tmp);
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncpy)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n )  __asm__("stpncpy")  ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src ,
                                                                                                     size_t __n ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
    return ((char __attribute__((__artificial__))  *)tmp___0);
  }
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
  return ((char __attribute__((__artificial__))  *)tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcat)(char * __restrict  __dest ,
                                                                                                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strcat)(char * __restrict  __dest ,
                                                                                                    char const   * __restrict  __src ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncat)(char * __restrict  __dest ,
                                                                                                                                   char const   * __restrict  __src ,
                                                                                                                                   size_t __len )  __attribute__((__nonnull__(1,2))) ;
__inline extern char __attribute__((__artificial__))  *( __attribute__((__always_inline__)) strncat)(char * __restrict  __dest ,
                                                                                                     char const   * __restrict  __src ,
                                                                                                     size_t __len ) 
{ unsigned long tmp ;
  char *tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__dest, 1);
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
  return ((char __attribute__((__artificial__))  *)tmp___0);
}
}
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (desc != -1) {
    tmp = fchmod(desc, mode);
    return (tmp);
  } else {
    tmp___0 = chmod(name, mode);
    return (tmp___0);
  }
}
}
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ int tmp ;

  {
  tmp = chmod_or_fchmod(name, desc, mode);
  return (tmp);
}
}
int set_acl(char const   *name , int desc , mode_t mode ) 
{ int r ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  tmp = qset_acl(name, desc, mode);
  r = tmp;
  if (r != 0) {
    tmp___0 = quote(name);
    tmp___1 = dcgettext((char const   *)((void *)0), "setting permissions for %s",
                        5);
    tmp___2 = __errno_location();
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
  }
  return (r);
}
}
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
static int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
                     int dest_desc , mode_t mode ) 
{ int tmp ;

  {
  tmp = qset_acl(dst_name, dest_desc, mode);
  return (tmp);
}
}
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
  ret = tmp;
  switch (ret) {
  case -2: 
  tmp___0 = quote(src_name);
  tmp___1 = __errno_location();
  error(0, *tmp___1, "%s", tmp___0);
  return (-1);
  case -1: 
  tmp___2 = quote(dst_name);
  tmp___3 = dcgettext((char const   *)((void *)0), "preserving permissions for %s",
                      5);
  tmp___4 = __errno_location();
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
  return (-1);
  default: 
  return (0);
  }
}
}
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 

  {
  return (0);
}
}
struct allocator  const  stdlib_allocator ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
struct allocator  const  stdlib_allocator  =    {& malloc, & realloc, & free, (void (*)(size_t  ))((void *)0)};
char *areadlink(char const   *filename ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open)(char const   *__path ,
                                                                                                int __oflag 
                                                                                                , ...)  __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open64)(char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat)(int __fd ,
                                                                                                  char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(2))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat64)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    int __oflag 
                                                                                                    , ...)  __attribute__((__nonnull__(2))) ;
extern int __open_2(char const   *__path , int __oflag )  __attribute__((__nonnull__(1))) ;
extern int __open_alias(char const   *__path , int __oflag  , ...)  __asm__("open") __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open)(char const   *__path ,
                                                                                                int __oflag 
                                                                                                , ...)  __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open)(char const   *__path ,
                                                                                                int __oflag 
                                                                                                , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp = __builtin_va_arg_pack_len();
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __open_2(__path, __oflag);
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern int __open64_2(char const   *__path , int __oflag )  __attribute__((__nonnull__(1))) ;
extern int __open64_alias(char const   *__path , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
extern void __open64_too_many_args(void)  __attribute__((__error__("open64 can be called either with 2 or 3 arguments, not more"))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open64)(char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) open64)(char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp = __builtin_va_arg_pack_len();
  if (tmp > 1) {
    __open64_too_many_args();
  }
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __open64_2(__path, __oflag);
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
  tmp___5 = __open64_alias(__path, __oflag, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern int __openat_2(int __fd , char const   *__path , int __oflag )  __attribute__((__nonnull__(2))) ;
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...)  __asm__("openat") __attribute__((__nonnull__(2))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat)(int __fd ,
                                                                                                  char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...)  __attribute__((__nonnull__(2))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat)(int __fd ,
                                                                                                  char const   *__path ,
                                                                                                  int __oflag 
                                                                                                  , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp = __builtin_va_arg_pack_len();
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __openat_2(__fd, __path, __oflag);
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern int __openat64_2(int __fd , char const   *__path , int __oflag )  __attribute__((__nonnull__(2))) ;
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...)  __asm__("openat64") __attribute__((__nonnull__(2))) ;
extern void __openat64_too_many_args(void)  __attribute__((__error__("openat64 can be called either with 3 or 4 arguments, not more"))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat64)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    int __oflag 
                                                                                                    , ...)  __attribute__((__nonnull__(2))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) openat64)(int __fd ,
                                                                                                    char const   *__path ,
                                                                                                    int __oflag 
                                                                                                    , ...) 
{ int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp = __builtin_va_arg_pack_len();
  if (tmp > 1) {
    __openat64_too_many_args();
  }
  tmp___4 = __builtin_va_arg_pack_len();
  if (tmp___4 < 1) {
    tmp___3 = __openat64_2(__fd, __path, __oflag);
    return ((int __attribute__((__artificial__))  )tmp___3);
  }
  tmp___5 = __openat64_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) read)(int __fd ,
                                                                                                                            void *__buf ,
                                                                                                                            size_t __nbytes )  __attribute__((__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread)(int __fd ,
                                                                                                                             void *__buf ,
                                                                                                                             size_t __nbytes ,
                                                                                                                             __off_t __offset )  __attribute__((__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread64)(int __fd ,
                                                                                                                               void *__buf ,
                                                                                                                               size_t __nbytes ,
                                                                                                                               __off64_t __offset )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__, __artificial__))  *( __attribute__((__always_inline__)) getwd)(char *__buf )  __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__)) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) confstr)(int __name ,
                                                                                                                                    char *__buf ,
                                                                                                                                    size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getgroups)(int __size ,
                                                                                                                                   __gid_t *__list )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ttyname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__))  ( __attribute__((__always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                   char * __restrict  __buf ,
                                                                                   size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__))  ( __attribute__((__always_inline__)) readlinkat)(int __fd ,
                                                                                     char const   * __restrict  __path ,
                                                                                     char * __restrict  __buf ,
                                                                                     size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getlogin_r)(char *__buf ,
                                                                                                      size_t __buflen )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) gethostname)(char *__buf ,
                                                                                                                                     size_t __buflen )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getdomainname)(char *__buf ,
                                                                                                                                       size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen )  __attribute__((__warn_unused_result__)) ;
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes )  __asm__("read") __attribute__((__warn_unused_result__)) ;
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"),
__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) read)(int __fd ,
                                                                                                                            void *__buf ,
                                                                                                                            size_t __nbytes )  __attribute__((__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) read)(int __fd ,
                                                                                                                            void *__buf ,
                                                                                                                            size_t __nbytes ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize )  __attribute__((__warn_unused_result__)) ;
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize )  __attribute__((__warn_unused_result__)) ;
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __asm__("pread") __attribute__((__warn_unused_result__)) ;
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64") __attribute__((__warn_unused_result__)) ;
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize )  __asm__("__pread_chk") __attribute__((__warning__("pread called with bigger length than size of the destination buffer"),
__warn_unused_result__)) ;
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize )  __asm__("__pread64_chk") __attribute__((__warning__("pread64 called with bigger length than size of the destination buffer"),
__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread)(int __fd ,
                                                                                                                             void *__buf ,
                                                                                                                             size_t __nbytes ,
                                                                                                                             __off_t __offset )  __attribute__((__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread)(int __fd ,
                                                                                                                             void *__buf ,
                                                                                                                             size_t __nbytes ,
                                                                                                                             __off_t __offset ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread64)(int __fd ,
                                                                                                                               void *__buf ,
                                                                                                                               size_t __nbytes ,
                                                                                                                               __off64_t __offset )  __attribute__((__warn_unused_result__)) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) pread64)(int __fd ,
                                                                                                                               void *__buf ,
                                                                                                                               size_t __nbytes ,
                                                                                                                               __off64_t __offset ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   * __restrict  __path ,
                                                            char * __restrict  __buf ,
                                                            size_t __len , size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   * __restrict  __path ,
                                                              char * __restrict  __buf ,
                                                              size_t __len )  __asm__("readlink") __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   * __restrict  __path ,
                                                                 char * __restrict  __buf ,
                                                                 size_t __len , size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"),
__warn_unused_result__, __nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(1,2), __artificial__))  ( __attribute__((__always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                   char * __restrict  __buf ,
                                                                                   size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(1,2))) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __nonnull__(1,2), __artificial__))  ( __attribute__((__always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                                                                                                  char * __restrict  __buf ,
                                                                                                                                                  size_t __len ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
    return ((ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
      return ((ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )tmp___2);
    }
  }
  tmp___5 = __readlink_alias(__path, __buf, __len);
  return ((ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   * __restrict  __path ,
                                                              char * __restrict  __buf ,
                                                              size_t __len , size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len )  __asm__("readlinkat") __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   * __restrict  __path ,
                                                                   char * __restrict  __buf ,
                                                                   size_t __len ,
                                                                   size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"),
__warn_unused_result__, __nonnull__(2,3))) ;
__inline extern  __attribute__((__nothrow__)) ssize_t __attribute__((__warn_unused_result__,
__nonnull__(2,3), __artificial__))  ( __attribute__((__always_inline__)) readlinkat)(int __fd ,
                                                                                     char const   * __restrict  __path ,
                                                                                     char * __restrict  __buf ,
                                                                                     size_t __len )  __attribute__((__warn_unused_result__,
__nonnull__(2,3))) ;
__inline extern ssize_t __attribute__((__warn_unused_result__, __nonnull__(2,3), __artificial__))  ( __attribute__((__always_inline__)) readlinkat)(int __fd ,
                                                                                                                                                    char const   * __restrict  __path ,
                                                                                                                                                    char * __restrict  __buf ,
                                                                                                                                                    size_t __len ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
    return ((ssize_t __attribute__((__nonnull__(2,3), __artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
      return ((ssize_t __attribute__((__nonnull__(2,3), __artificial__))  )tmp___2);
    }
  }
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
  return ((ssize_t __attribute__((__nonnull__(2,3), __artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size )  __asm__("getcwd") __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"),
__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__artificial__))  *( __attribute__((__always_inline__)) getcwd)(char *__buf , size_t __size )  __attribute__((__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) getcwd)(char *__buf ,
                                                                                                                            size_t __size ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__size > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
      return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __getcwd_alias(__buf, __size);
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"),
__warn_unused_result__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__, __artificial__))  *( __attribute__((__always_inline__)) getwd)(char *__buf )  __attribute__((__warn_unused_result__,
__nonnull__(1), __deprecated__)) ;
__inline extern char __attribute__((__warn_unused_result__, __nonnull__(1), __deprecated__,
__artificial__))  *( __attribute__((__always_inline__)) getwd)(char *__buf ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getwd_chk(__buf, tmp);
    return ((char __attribute__((__warn_unused_result__, __nonnull__(1), __deprecated__,
    __artificial__))  *)tmp___0);
  }
  tmp___2 = __getwd_warn(__buf);
  return ((char __attribute__((__warn_unused_result__, __nonnull__(1), __deprecated__,
  __artificial__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len )  __asm__("confstr")  ;
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) confstr)(int __name ,
                                                                                                                                    char *__buf ,
                                                                                                                                    size_t __len ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) confstr)(int __name ,
                                                                                                      char *__buf ,
                                                                                                      size_t __len ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (tmp___3 < __len) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __confstr_alias(__name, __buf, __len);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t *__list ,
                                                         size_t __listlen )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t *__list )  __asm__("getgroups") __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t *__list ,
                                                              size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"),
__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getgroups)(int __size ,
                                                                                                                                   __gid_t *__list )  __attribute__((__warn_unused_result__)) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getgroups)(int __size ,
                                                                                                     __gid_t *__list ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__list, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__list, 1);
    tmp___0 = __getgroups_chk(__size, __list, tmp);
    return ((int __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__list, 1);
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__list, 1);
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __getgroups_alias(__size, __list);
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen )  __asm__("ttyname_r") __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"),
__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ttyname_r)(int __fd ,
                                                                                                                                   char *__buf ,
                                                                                                                                   size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(2))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) ttyname_r)(int __fd ,
                                                                                                     char *__buf ,
                                                                                                     size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
    return ((int __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal )  __attribute__((__nonnull__(1))) ;
extern int __getlogin_r_alias(char *__buf , size_t __buflen )  __asm__("getlogin_r") __attribute__((__nonnull__(1))) ;
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"),
__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getlogin_r)(char *__buf ,
                                                                                                      size_t __buflen )  __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getlogin_r)(char *__buf ,
                                                                                                      size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
    return ((int __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen )  __asm__("gethostname") __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"),
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) gethostname)(char *__buf ,
                                                                                                                                     size_t __buflen )  __attribute__((__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) gethostname)(char *__buf ,
                                                                                                       size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
    return ((int __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __gethostname_alias(__buf, __buflen);
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen )  __asm__("getdomainname") __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"),
__warn_unused_result__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getdomainname)(char *__buf ,
                                                                                                                                       size_t __buflen )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) getdomainname)(char *__buf ,
                                                                                                         size_t __buflen ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
    return ((int __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
      return ((int __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __getdomainname_alias(__buf, __buflen);
  return ((int __attribute__((__artificial__))  )tmp___5);
}
}
char *careadlinkat(int fd , char const   *filename , char *buffer , size_t buffer_size ,
                   struct allocator  const  *alloc , ssize_t (*preadlinkat)(int  ,
                                                                            char const   * ,
                                                                            char * ,
                                                                            size_t  ) ) ;
ssize_t careadlinkatcwd(int fd , char const   *filename , char *buffer , size_t buffer_size ) ;
char *areadlink(char const   *filename ) 
{ char *tmp ;

  {
  tmp = careadlinkat(-100, filename, (char *)((void *)0), (size_t )0, (struct allocator  const  *)((void *)0),
                     & careadlinkatcwd);
  return (tmp);
}
}
char *areadlink_with_size(char const   *file , size_t size ) ;
char *areadlink_with_size(char const   *file , size_t size ) 
{ size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer ;
  void *tmp___1 ;
  ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp___7 ;

  {
  symlink_max = (size_t )1024;
  INITIAL_LIMIT_BOUND = (size_t )8192;
  if (symlink_max < INITIAL_LIMIT_BOUND) {
    tmp = symlink_max + 1UL;
  } else {
    tmp = INITIAL_LIMIT_BOUND;
  }
  initial_limit = tmp;
  if (size < initial_limit) {
    tmp___0 = size + 1UL;
  } else {
    tmp___0 = initial_limit;
  }
  buf_size = tmp___0;
  while (1) {
    tmp___1 = malloc(buf_size);
    buffer = (char *)tmp___1;
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
    tmp___7 = (ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )readlink((char const   * __restrict  )file,
                                                                                    (char * __restrict  )buffer,
                                                                                    buf_size);
    tmp___2 = tmp___7;
    r = (ssize_t )tmp___2;
    link_length = (size_t )r;
    if (r < 0L) {
      tmp___5 = __errno_location();
      if (*tmp___5 != 34) {
        tmp___3 = __errno_location();
        saved_errno = *tmp___3;
        free((void *)buffer);
        tmp___4 = __errno_location();
        *tmp___4 = saved_errno;
        return ((char *)((void *)0));
      }
    }
    if (link_length < buf_size) {
      *(buffer + link_length) = (char)0;
      return (buffer);
    }
    free((void *)buffer);
    if (buf_size <= 4611686018427387903UL) {
      buf_size *= 2UL;
    } else
    if (buf_size < 9223372036854775807UL) {
      buf_size = 9223372036854775807UL;
    } else {
      tmp___6 = __errno_location();
      *tmp___6 = 12;
      return ((char *)((void *)0));
    }
  }
}
}
char *areadlinkat(int fd , char const   *filename ) ;
char *areadlinkat(int fd , char const   *filename ) 
{ char *tmp ;

  {
  tmp = careadlinkat(fd, filename, (char *)((void *)0), (size_t )0, (struct allocator  const  *)((void *)0),
                     (ssize_t (*)(int  , char const   * , char * , size_t  ))(& readlinkat));
  return (tmp);
}
}
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
void (*argmatch_die)(void) ;
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
extern int __uflow(_IO_FILE * ) ;
extern int __overflow(_IO_FILE * , int  ) ;
extern int _IO_getc(_IO_FILE *__fp ) ;
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                  , ...) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                                                 char const   * __restrict  __fmt 
                                                                                                                                 , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                                   __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                                                  char const   * __restrict  __fmt ,
                                                                                                                                  __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) snprintf)(char * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vasprintf)(char ** __restrict  __ptr ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) asprintf)(char ** __restrict  __ptr ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...)  __attribute__((__warn_unused_result__)) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vdprintf)(int __fd ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) dprintf)(int __fd ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) ;
__inline extern int getchar(void) ;
extern int getc_unlocked(FILE *__fp ) ;
__inline extern int getchar_unlocked(void) ;
__inline extern int fgetc_unlocked(FILE *__fp ) ;
__inline extern int putchar(int __c ) ;
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putchar_unlocked(int __c ) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                                           int __n ,
                                                                                                                           FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                                    int __n ,
                                                                                                                                    FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                                            size_t __size ,
                                                                                                                            size_t __n ,
                                                                                                                            FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                                     size_t __size ,
                                                                                                                                     size_t __n ,
                                                                                                                                     FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                                                                        char const   * __restrict  __fmt 
                                                                                                                                        , ...) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                                                         char const   * __restrict  __fmt ,
                                                                                                                                         __gnuc_va_list __ap ) ;
__inline extern int getchar(void) 
{ int tmp ;

  {
  tmp = _IO_getc(stdin);
  return (tmp);
}
}
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int getchar_unlocked(void) 
{ int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int putchar(int __c ) 
{ int tmp ;

  {
  tmp = _IO_putc(__c, stdout);
  return (tmp);
}
}
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int putchar_unlocked(int __c ) 
{ int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) 
{ __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
__inline extern int feof_unlocked(FILE *__stream ) 
{ 

  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 

  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                                                 char const   * __restrict  __fmt 
                                                                                                                                 , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                                                  char const   * __restrict  __fmt ,
                                                                                                                                  __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) snprintf)(char * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) snprintf)(char * __restrict  __s ,
                                                                                                    size_t __n ,
                                                                                                    char const   * __restrict  __fmt 
                                                                                                    , ...) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                     size_t __n ,
                                                                                                     char const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
  return ((int __attribute__((__artificial__))  )tmp___0);
}
}
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) 
{ int tmp ;

  {
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                                  , ...) 
{ int tmp ;

  {
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                                   __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
extern  __attribute__((__nothrow__)) int __asprintf_chk(char ** __restrict  __ptr ,
                                                        int __flag , char const   * __restrict  __fmt 
                                                        , ...)  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char ** __restrict  __ptr ,
                                                         int __flag , char const   * __restrict  __fmt ,
                                                         __gnuc_va_list __arg )  __attribute__((__warn_unused_result__)) ;
extern int __dprintf_chk(int __fd , int __flag , char const   * __restrict  __fmt 
                         , ...) ;
extern int __vdprintf_chk(int __fd , int __flag , char const   * __restrict  __fmt ,
                          __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack * __restrict  __obstack ,
                                                              int __flag , char const   * __restrict  __format 
                                                              , ...) ;
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack * __restrict  __obstack ,
                                                               int __flag , char const   * __restrict  __format ,
                                                               __gnuc_va_list __args ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) asprintf)(char ** __restrict  __ptr ,
                                                                                                                                  char const   * __restrict  __fmt 
                                                                                                                                  , ...)  __attribute__((__warn_unused_result__)) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) asprintf)(char ** __restrict  __ptr ,
                                                                                                    char const   * __restrict  __fmt 
                                                                                                    , ...) 
{ int tmp ;

  {
  tmp = __asprintf_chk(__ptr, 1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) dprintf)(int __fd ,
                                                                                                   char const   * __restrict  __fmt 
                                                                                                   , ...) 
{ int tmp ;

  {
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                                                                        char const   * __restrict  __fmt 
                                                                                                                                        , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                                          char const   * __restrict  __fmt 
                                                                                                          , ...) 
{ int tmp ;

  {
  tmp = __obstack_printf_chk(__obstack, 1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vasprintf)(char ** __restrict  __ptr ,
                                                                                                                                   char const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap )  __attribute__((__warn_unused_result__)) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vasprintf)(char ** __restrict  __ptr ,
                                                                                                     char const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vdprintf)(int __fd ,
                                                                                                    char const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                                                         char const   * __restrict  __fmt ,
                                                                                                                                         __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                           char const   * __restrict  __fmt ,
                                                                                                           __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
extern char *__fgets_chk(char * __restrict  __s , size_t __size , int __n , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern char *__fgets_alias(char * __restrict  __s , int __n , FILE * __restrict  __stream )  __asm__("fgets") __attribute__((__warn_unused_result__)) ;
extern char *__fgets_chk_warn(char * __restrict  __s , size_t __size , int __n , FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                                           int __n ,
                                                                                                                           FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                                           int __n ,
                                                                                                                           FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
      return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __fgets_alias(__s, __n, __stream);
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
extern size_t __fread_chk(void * __restrict  __ptr , size_t __ptrlen , size_t __size ,
                          size_t __n , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern size_t __fread_alias(void * __restrict  __ptr , size_t __size , size_t __n ,
                            FILE * __restrict  __stream )  __asm__("fread") __attribute__((__warn_unused_result__)) ;
extern size_t __fread_chk_warn(void * __restrict  __ptr , size_t __ptrlen , size_t __size ,
                               size_t __n , FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"),
__warn_unused_result__)) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                                            size_t __size ,
                                                                                                                            size_t __n ,
                                                                                                                            FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                                            size_t __size ,
                                                                                                                            size_t __n ,
                                                                                                                            FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__ptr, 0);
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern char *__fgets_unlocked_chk(char * __restrict  __s , size_t __size , int __n ,
                                  FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern char *__fgets_unlocked_alias(char * __restrict  __s , int __n , FILE * __restrict  __stream )  __asm__("fgets_unlocked") __attribute__((__warn_unused_result__)) ;
extern char *__fgets_unlocked_chk_warn(char * __restrict  __s , size_t __size , int __n ,
                                       FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk") __attribute__((__warning__("fgets_unlocked called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                                    int __n ,
                                                                                                                                    FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern char __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                                    int __n ,
                                                                                                                                    FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_unlocked_chk(__s, tmp, __n, __stream);
    return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_unlocked_chk_warn(__s, tmp___1, __n, __stream);
      return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __fgets_unlocked_alias(__s, __n, __stream);
  return ((char __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
extern size_t __fread_unlocked_chk(void * __restrict  __ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern size_t __fread_unlocked_alias(void * __restrict  __ptr , size_t __size , size_t __n ,
                                     FILE * __restrict  __stream )  __asm__("fread_unlocked") __attribute__((__warn_unused_result__)) ;
extern size_t __fread_unlocked_chk_warn(void * __restrict  __ptr , size_t __ptrlen ,
                                        size_t __size , size_t __n , FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"),
__warn_unused_result__)) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                                     size_t __size ,
                                                                                                                                     size_t __n ,
                                                                                                                                     FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                                     size_t __size ,
                                                                                                                                     size_t __n ,
                                                                                                                                     FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__ptr, 0);
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  return ((size_t __attribute__((__artificial__))  )tmp___11);
}
}
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
char const   *quote_n(int n , char const   *name ) ;
 __attribute__((__noreturn__)) void usage(int status ) ;
static void __argmatch_die(void) 
{ 

  {
  usage(1);
  return;
}
}
void (*argmatch_die)(void)  =    & __argmatch_die;
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  matchind = (ptrdiff_t )-1;
  ambiguous = (_Bool)0;
  arglen = strlen(arg);
  i = (size_t )0;
  while (*(arglist + i)) {
    if (0) {
      if (0) {
        __s1_len = __builtin_strlen((char const   *)*(arglist + i));
        __s2_len = __builtin_strlen(arg);
        if (! ((size_t )((void const   *)(*(arglist + i) + 1)) - (size_t )((void const   *)*(arglist + i)) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)(arg + 1)) - (size_t )((void const   *)arg) == 1UL)) {
            tmp___9 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___9 = 1;
          } else {
            tmp___9 = 0;
          }
        } else {
          tmp___9 = 0;
        }
        if (tmp___9) {
          tmp___4 = __builtin_strcmp((char const   *)*(arglist + i), arg);
          tmp___8 = tmp___4;
        } else {
          tmp___7 = __builtin_strcmp((char const   *)*(arglist + i), arg);
          tmp___8 = tmp___7;
        }
      } else {
        tmp___7 = __builtin_strcmp((char const   *)*(arglist + i), arg);
        tmp___8 = tmp___7;
      }
      tmp___11 = tmp___8;
    } else {
      tmp___10 = strncmp((char const   *)*(arglist + i), arg, arglen);
      tmp___11 = tmp___10;
    }
    if (! tmp___11) {
      tmp___0 = strlen((char const   *)*(arglist + i));
      if (tmp___0 == arglen) {
        return ((ptrdiff_t )i);
      } else
      if (matchind == -1L) {
        matchind = (ptrdiff_t )i;
      } else
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
        ambiguous = (_Bool)1;
      } else {
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        if (tmp) {
          ambiguous = (_Bool)1;
        }
      }
    }
    i ++;
  }
  if (ambiguous) {
    return ((ptrdiff_t )-2);
  } else {
    return (matchind);
  }
}
}
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
  if (problem == -1L) {
    tmp = dcgettext((char const   *)((void *)0), "invalid argument %s for %s", 5);
    tmp___1 = tmp;
  } else {
    tmp___0 = dcgettext((char const   *)((void *)0), "ambiguous argument %s for %s",
                        5);
    tmp___1 = tmp___0;
  }
  format = (char const   *)tmp___1;
  tmp___2 = quote_n(1, context);
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
  error(0, 0, format, tmp___3, tmp___2);
  return;
}
}
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;

  {
  last_val = (char const   *)((void *)0);
  tmp = dcgettext((char const   *)((void *)0), "Valid arguments are:", 5);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp);
  i = (size_t )0;
  while (*(arglist + i)) {
    if (i == 0UL) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n  - `%s\'",
              *(arglist + i));
      last_val = vallist + valsize * i;
    } else {
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      if (tmp___0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n  - `%s\'",
                *(arglist + i));
        last_val = vallist + valsize * i;
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )", `%s\'",
                *(arglist + i));
      }
    }
    i ++;
  }
  fputc_unlocked('\n', stderr);
  return;
}
}
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  tmp = argmatch(arg, arglist, vallist, valsize);
  res = tmp;
  if (res >= 0L) {
    return (res);
  }
  argmatch_invalid(context, arg, res);
  argmatch_valid(arglist, vallist, valsize);
  (*exit_fn)();
  return ((ptrdiff_t )-1);
}
}
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ size_t i ;
  int tmp ;

  {
  i = (size_t )0;
  while (*(arglist + i)) {
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
    if (! tmp) {
      return ((char const   *)*(arglist + i));
    }
    i ++;
  }
  return ((char const   *)((void *)0));
}
}
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
struct argv_iterator *argv_iter_init_argv(char **argv )  __attribute__((__nonnull__(1))) ;
struct argv_iterator *argv_iter_init_stream(FILE *fp )  __attribute__((__nonnull__(1))) ;
char *argv_iter(struct argv_iterator *ai , enum argv_iter_err *err )  __attribute__((__nonnull__(1,2))) ;
size_t argv_iter_n_args(struct argv_iterator  const  *ai )  __attribute__((__nonnull__(1))) ;
void argv_iter_free(struct argv_iterator *ai )  __attribute__((__nonnull__(1))) ;
struct argv_iterator *argv_iter_init_argv(char **argv )  __attribute__((__nonnull__(1))) ;
struct argv_iterator *argv_iter_init_argv(char **argv ) 
{ struct argv_iterator *ai ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*ai));
  ai = (struct argv_iterator *)tmp;
  if (! ai) {
    return ((struct argv_iterator *)((void *)0));
  }
  ai->fp = (FILE *)((void *)0);
  ai->arg_list = argv;
  ai->p = argv;
  return (ai);
}
}
struct argv_iterator *argv_iter_init_stream(FILE *fp )  __attribute__((__nonnull__(1))) ;
struct argv_iterator *argv_iter_init_stream(FILE *fp ) 
{ struct argv_iterator *ai ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*ai));
  ai = (struct argv_iterator *)tmp;
  if (! ai) {
    return ((struct argv_iterator *)((void *)0));
  }
  ai->fp = fp;
  ai->tok = (char *)((void *)0);
  ai->buf_len = (size_t )0;
  ai->item_idx = (size_t )0;
  ai->arg_list = (char **)((void *)0);
  return (ai);
}
}
char *argv_iter(struct argv_iterator *ai , enum argv_iter_err *err )  __attribute__((__nonnull__(1,2))) ;
char *argv_iter(struct argv_iterator *ai , enum argv_iter_err *err ) 
{ ssize_t len ;
  __ssize_t tmp ;
  int tmp___1 ;
  char **tmp___2 ;

  {
  if (ai->fp) {
    tmp = getdelim((char ** __restrict  )(& ai->tok), (size_t * __restrict  )(& ai->buf_len),
                   '\000', (FILE * __restrict  )ai->fp);
    len = tmp;
    if (len < 0L) {
      tmp___1 = feof(ai->fp);
      if (tmp___1) {
        *err = (enum argv_iter_err )2;
      } else {
        *err = (enum argv_iter_err )4;
      }
      return ((char *)((void *)0));
    }
    *err = (enum argv_iter_err )1;
    (ai->item_idx) ++;
    return (ai->tok);
  } else
  if ((unsigned long )*(ai->p) == (unsigned long )((void *)0)) {
    *err = (enum argv_iter_err )2;
    return ((char *)((void *)0));
  } else {
    *err = (enum argv_iter_err )1;
    tmp___2 = ai->p;
    (ai->p) ++;
    return (*tmp___2);
  }
}
}
size_t argv_iter_n_args(struct argv_iterator  const  *ai )  __attribute__((__nonnull__(1))) ;
size_t argv_iter_n_args(struct argv_iterator  const  *ai ) 
{ size_t tmp ;

  {
  if (ai->fp) {
    tmp = (size_t )ai->item_idx;
  } else {
    tmp = (size_t )((size_t const   )(ai->p - ai->arg_list));
  }
  return (tmp);
}
}
void argv_iter_free(struct argv_iterator *ai )  __attribute__((__nonnull__(1))) ;
void argv_iter_free(struct argv_iterator *ai ) 
{ 

  {
  if (ai->fp) {
    free((void *)ai->tok);
  }
  free((void *)ai);
  return;
}
}
char const   *simple_backup_suffix ;
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) ;
enum backup_type get_version(char const   *context , char const   *version ) ;
enum backup_type xget_version(char const   *context , char const   *version ) ;
size_t base_len(char const   *name ) ;
char *last_component(char const   *name ) ;
 __attribute__((__noreturn__)) void xalloc_die(void) ;
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ int tmp ;
  void *tmp___0 ;

  {
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    tmp = -1;
  } else {
    tmp = -2;
  }
  if ((size_t )tmp / s < n) {
    xalloc_die();
  }
  tmp___0 = xrealloc(p, n * s);
  return (tmp___0);
}
}
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name )  __attribute__((__nonnull__(1))) ;
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
DIR *opendir_safer(char const   *name ) ;
char const   *simple_backup_suffix  =    "~";
static void check_extension(char *file , size_t filelen , char e ) 
{ char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;

  {
  tmp = last_component((char const   *)file);
  base = tmp;
  tmp___0 = base_len((char const   *)base);
  baselen = tmp___0;
  baselen_max = (size_t )255;
  if (14UL < baselen) {
    memcpy((void * __restrict  )(tmp___1), (void const   * __restrict  )base, sizeof("."));
    strcpy((char * __restrict  )base, (char const   * __restrict  )".");
    tmp___2 = __errno_location();
    *tmp___2 = 0;
    name_max = pathconf((char const   *)file, 3);
    if (0L <= name_max) {
      goto _L;
    } else {
      tmp___3 = __errno_location();
      if (*tmp___3 == 0) {
        _L: 
        baselen_max = (size_t )name_max;
        size = (long )baselen_max;
        if (name_max != size) {
          baselen_max = (size_t )-1;
        }
      }
    }
    memcpy((void * __restrict  )base, (void const   * __restrict  )(tmp___1), sizeof("."));
  }
  if (baselen_max < baselen) {
    baselen = (size_t )((file + filelen) - base);
    if (baselen_max <= baselen) {
      baselen = baselen_max - 1UL;
    }
    *(base + baselen) = e;
    *(base + (baselen + 1UL)) = (char )'\000';
  }
  return;
}
}
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___1 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  result = (enum numbered_backup_result )2;
  buf___1 = *buffer;
  versionlenmax = (size_t )1;
  tmp = last_component((char const   *)buf___1);
  base = tmp;
  base_offset = (size_t )(base - buf___1);
  tmp___0 = base_len((char const   *)base);
  baselen = tmp___0;
  memcpy((void * __restrict  )(tmp___1), (void const   * __restrict  )base, sizeof("."));
  strcpy((char * __restrict  )base, (char const   * __restrict  )".");
  dirp = opendir_safer((char const   *)buf___1);
  memcpy((void * __restrict  )base, (void const   * __restrict  )(tmp___1), sizeof("."));
  strcpy((char * __restrict  )(base + baselen), (char const   * __restrict  )".~1~");
  if (! dirp) {
    return (result);
  }
  while (1) {
    dp = readdir(dirp);
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
      break;
    }
    if (! (dp->d_ino != 0UL)) {
      continue;
    } else {
      tmp___2 = strlen((char const   *)(dp->d_name));
      if (tmp___2 < baselen + 4UL) {
        continue;
      }
    }
    tmp___3 = memcmp((void const   *)(buf___1 + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
    if (tmp___3 != 0) {
      continue;
    }
    p = (char const   *)((dp->d_name + baselen) + 2);
    if (49 <= (int )*p) {
      if (! ((int const   )*p <= 57)) {
        continue;
      }
    } else {
      continue;
    }
    all_9s = (_Bool )((int const   )*p == 57);
    versionlen = (size_t )1;
    while ((unsigned int )*(p + versionlen) - 48U <= 9U) {
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
      versionlen ++;
    }
    if ((int const   )*(p + versionlen) == 126) {
      if (! *(p + (versionlen + 1UL))) {
        if (! (versionlenmax < versionlen)) {
          if (versionlenmax == versionlen) {
            tmp___4 = memcmp((void const   *)((buf___1 + filelen) + 2), (void const   *)p,
                             versionlen);
            if (! (tmp___4 <= 0)) {
              continue;
            }
          } else {
            continue;
          }
        }
      } else {
        continue;
      }
    } else {
      continue;
    }
    versionlenmax = (size_t )all_9s + versionlen;
    if (all_9s) {
      result = (enum numbered_backup_result )1;
    } else {
      result = (enum numbered_backup_result )0;
    }
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
    if (buffer_size <= new_buflen) {
      tmp___5 = xnrealloc((void *)buf___1, (size_t )2, new_buflen);
      buf___1 = (char *)tmp___5;
      buffer_size = new_buflen * 2UL;
    }
    q = buf___1 + filelen;
    tmp___6 = q;
    q ++;
    *tmp___6 = (char )'.';
    tmp___7 = q;
    q ++;
    *tmp___7 = (char )'~';
    *q = (char )'0';
    q += (int )all_9s;
    memcpy((void * __restrict  )q, (void const   * __restrict  )p, versionlen + 2UL);
    q += versionlen;
    while (1) {
      q --;
      if (! ((int )*q == 57)) {
        break;
      }
      *q = (char )'0';
    }
    *q = (char )((int )*q + 1);
  }
  closedir(dirp);
  *buffer = buf___1;
  return (result);
}
}
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;

  {
  tmp = strlen(file);
  filelen = tmp;
  simple = (_Bool)1;
  tmp___0 = strlen(simple_backup_suffix);
  simple_backup_suffix_size = tmp___0 + 1UL;
  backup_suffix_size_guess = simple_backup_suffix_size;
  if (backup_suffix_size_guess < 9UL) {
    backup_suffix_size_guess = (size_t )9;
  }
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
  tmp___1 = xmalloc(ssize);
  s = (char *)tmp___1;
  memcpy((void * __restrict  )s, (void const   * __restrict  )file, filelen + 1UL);
  if ((unsigned int )backup_type != 1U) {
    tmp___2 = numbered_backup(& s, ssize, filelen);
    switch ((int )tmp___2) {
    case 0: 
    return (s);
    case 1: 
    simple = (_Bool)0;
    break;
    case 2: 
    simple = (_Bool )((unsigned int )backup_type == 2U);
    break;
    }
  }
  if (simple) {
    memcpy((void * __restrict  )(s + filelen), (void const   * __restrict  )simple_backup_suffix,
           simple_backup_suffix_size);
  }
  check_extension(s, filelen, (char )'~');
  return (s);
}
}
static char const   * const  backup_args[9]  = 
  {      (char const   * const  )"none",      (char const   * const  )"off",      (char const   * const  )"simple",      (char const   * const  )"never", 
        (char const   * const  )"existing",      (char const   * const  )"nil",      (char const   * const  )"numbered",      (char const   * const  )"t", 
        (char const   * const  )((void *)0)};
static enum backup_type  const  backup_types[8]  = 
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
enum backup_type get_version(char const   *context , char const   *version ) 
{ ptrdiff_t tmp ;

  {
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
    return ((enum backup_type )2);
  } else
  if ((int const   )*version == 0) {
    return ((enum backup_type )2);
  } else {
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               sizeof(backup_types[0]), argmatch_die);
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
enum backup_type xget_version(char const   *context , char const   *version ) 
{ enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;

  {
  if (version) {
    if (*version) {
      tmp = get_version(context, version);
      return (tmp);
    } else {
      tmp___0 = getenv("VERSION_CONTROL");
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
      return (tmp___1);
    }
  } else {
    tmp___0 = getenv("VERSION_CONTROL");
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
    return (tmp___1);
  }
}
}
_Bool isbase64(char ch ) ;
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) ;
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) ;
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) ;
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline static unsigned char to_uchar(char ch ) 
{ 

  {
  return ((unsigned char )ch);
}
}
static char const   b64str[64]  = 
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) 
{ char * __restrict  tmp ;
  unsigned char tmp___0 ;
  char * __restrict  tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  char * __restrict  tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  char * __restrict  tmp___9 ;
  unsigned char tmp___10 ;

  {
  while (1) {
    if (inlen) {
      if (! outlen) {
        break;
      }
    } else {
      break;
    }
    tmp = out;
    out ++;
    tmp___0 = to_uchar((char )*(in + 0));
    *tmp = (char )b64str[((int )tmp___0 >> 2) & 63];
    outlen --;
    if (! outlen) {
      break;
    }
    tmp___1 = out;
    out ++;
    tmp___2 = to_uchar((char )*(in + 0));
    inlen --;
    if (inlen) {
      tmp___3 = to_uchar((char )*(in + 1));
      tmp___4 = (int )tmp___3 >> 4;
    } else {
      tmp___4 = 0;
    }
    *tmp___1 = (char )b64str[(((int )tmp___2 << 4) + tmp___4) & 63];
    outlen --;
    if (! outlen) {
      break;
    }
    tmp___5 = out;
    out ++;
    if (inlen) {
      tmp___6 = to_uchar((char )*(in + 1));
      inlen --;
      if (inlen) {
        tmp___7 = to_uchar((char )*(in + 2));
        tmp___8 = (int )tmp___7 >> 6;
      } else {
        tmp___8 = 0;
      }
      *tmp___5 = (char )b64str[(((int )tmp___6 << 2) + tmp___8) & 63];
    } else {
      *tmp___5 = (char )'=';
    }
    outlen --;
    if (! outlen) {
      break;
    }
    tmp___9 = out;
    out ++;
    if (inlen) {
      tmp___10 = to_uchar((char )*(in + 2));
      *tmp___9 = (char )b64str[(int )tmp___10 & 63];
    } else {
      *tmp___9 = (char )'=';
    }
    outlen --;
    if (! outlen) {
      break;
    }
    if (inlen) {
      inlen --;
    }
    if (inlen) {
      in += 3;
    }
  }
  if (outlen) {
    *out = (char )'\000';
  }
  return;
}
}
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) 
{ size_t outlen ;
  void *tmp ;

  {
  outlen = 1UL + ((inlen + 2UL) / 3UL) * 4UL;
  if (inlen > outlen) {
    *out = (char *)((void *)0);
    return ((size_t )0);
  }
  tmp = malloc(outlen);
  *out = (char *)tmp;
  if (! *out) {
    return (outlen);
  }
  base64_encode((char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                outlen);
  return (outlen - 1UL);
}
}
static signed char const   b64[256]  = 
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
_Bool isbase64(char ch ) 
{ unsigned char tmp ;

  {
  tmp = to_uchar(ch);
  return ((_Bool )(0 <= (int )b64[tmp]));
}
}
void base64_decode_ctx_init(struct base64_decode_context *ctx ) 
{ 

  {
  ctx->i = 0U;
  return;
}
}
__inline static char *get_4(struct base64_decode_context *ctx , char const   * __restrict  *in ,
                            char const   * __restrict  in_end , size_t *n_non_newline ) 
{ char const   *t ;
  void *tmp ;
  char const   *p ;
  char c ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
  if (ctx->i == 4U) {
    ctx->i = 0U;
  }
  if (ctx->i == 0U) {
    t = (char const   *)*in;
    if (4 <= in_end - *in) {
      tmp = memchr((void const   *)t, '\n', (size_t )4);
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        *in += 4;
        *n_non_newline = (size_t )4;
        return ((char *)t);
      }
    }
  }
  p = (char const   *)*in;
  while ((unsigned long )p < (unsigned long )in_end) {
    tmp___0 = p;
    p ++;
    c = (char )*tmp___0;
    if ((int )c != 10) {
      tmp___1 = ctx->i;
      (ctx->i) ++;
      ctx->buf[tmp___1] = c;
      if (ctx->i == 4U) {
        break;
      }
    }
  }
  *in = (char const   * __restrict  )p;
  *n_non_newline = (size_t )ctx->i;
  return (ctx->buf);
}
}
__inline static _Bool decode_4(char const   * __restrict  in , size_t inlen , char * __restrict  *outp ,
                               size_t *outleft ) 
{ char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
  out = (char *)*outp;
  if (inlen < 2UL) {
    return ((_Bool)0);
  }
  tmp = isbase64((char )*(in + 0));
  if (tmp) {
    tmp___0 = isbase64((char )*(in + 1));
    if (! tmp___0) {
      return ((_Bool)0);
    }
  } else {
    return ((_Bool)0);
  }
  if (*outleft) {
    tmp___1 = out;
    out ++;
    tmp___2 = to_uchar((char )*(in + 0));
    tmp___3 = to_uchar((char )*(in + 1));
    *tmp___1 = (char )(((int const   )b64[tmp___2] << 2) | ((int const   )b64[tmp___3] >> 4));
    (*outleft) --;
  }
  if (inlen == 2UL) {
    while (1) {
      *outp = (char * __restrict  )out;
      return ((_Bool)0);
      break;
    }
  }
  if ((int const   )*(in + 2) == 61) {
    if (inlen != 4UL) {
      while (1) {
        *outp = (char * __restrict  )out;
        return ((_Bool)0);
        break;
      }
    }
    if ((int const   )*(in + 3) != 61) {
      while (1) {
        *outp = (char * __restrict  )out;
        return ((_Bool)0);
        break;
      }
    }
  } else {
    tmp___4 = isbase64((char )*(in + 2));
    if (! tmp___4) {
      while (1) {
        *outp = (char * __restrict  )out;
        return ((_Bool)0);
        break;
      }
    }
    if (*outleft) {
      tmp___5 = out;
      out ++;
      tmp___6 = to_uchar((char )*(in + 1));
      tmp___7 = to_uchar((char )*(in + 2));
      *tmp___5 = (char )((((int const   )b64[tmp___6] << 4) & 240) | ((int const   )b64[tmp___7] >> 2));
      (*outleft) --;
    }
    if (inlen == 3UL) {
      while (1) {
        *outp = (char * __restrict  )out;
        return ((_Bool)0);
        break;
      }
    }
    if ((int const   )*(in + 3) == 61) {
      if (inlen != 4UL) {
        while (1) {
          *outp = (char * __restrict  )out;
          return ((_Bool)0);
          break;
        }
      }
    } else {
      tmp___8 = isbase64((char )*(in + 3));
      if (! tmp___8) {
        while (1) {
          *outp = (char * __restrict  )out;
          return ((_Bool)0);
          break;
        }
      }
      if (*outleft) {
        tmp___9 = out;
        out ++;
        tmp___10 = to_uchar((char )*(in + 2));
        tmp___11 = to_uchar((char )*(in + 3));
        *tmp___9 = (char )((((int const   )b64[tmp___10] << 6) & 192) | (int const   )b64[tmp___11]);
        (*outleft) --;
      }
    }
  }
  *outp = (char * __restrict  )out;
  return ((_Bool)1);
}
}
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) 
{ size_t outleft ;
  _Bool ignore_newlines ;
  _Bool flush_ctx ;
  unsigned int ctx_i ;
  size_t outleft_save ;
  _Bool tmp ;
  char const   *in_end ;
  char const   *non_nl ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  outleft = *outlen;
  ignore_newlines = (_Bool )((unsigned long )ctx != (unsigned long )((void *)0));
  flush_ctx = (_Bool)0;
  ctx_i = 0U;
  if (ignore_newlines) {
    ctx_i = ctx->i;
    flush_ctx = (_Bool )(inlen == 0UL);
  }
  while (1) {
    outleft_save = outleft;
    if (ctx_i == 0U) {
      if (! flush_ctx) {
        while (1) {
          outleft_save = outleft;
          tmp = decode_4(in, inlen, & out, & outleft);
          if (! tmp) {
            break;
          }
          in += 4;
          inlen -= 4UL;
        }
      }
    }
    if (inlen == 0UL) {
      if (! flush_ctx) {
        break;
      }
    }
    if (inlen) {
      if ((int const   )*in == 10) {
        if (ignore_newlines) {
          in ++;
          inlen --;
          continue;
        }
      }
    }
    out -= outleft_save - outleft;
    outleft = outleft_save;
    in_end = (char const   *)(in + inlen);
    if (ignore_newlines) {
      tmp___0 = get_4(ctx, & in, (char const   * __restrict  )in_end, & inlen);
      non_nl = (char const   *)tmp___0;
    } else {
      non_nl = (char const   *)in;
    }
    if (inlen == 0UL) {
      inlen = (size_t )0;
      break;
    } else
    if (inlen < 4UL) {
      if (! flush_ctx) {
        if (ignore_newlines) {
          inlen = (size_t )0;
          break;
        }
      }
    }
    tmp___1 = decode_4((char const   * __restrict  )non_nl, inlen, & out, & outleft);
    if (! tmp___1) {
      break;
    }
    inlen = (size_t )(in_end - (char const   *)in);
  }
  *outlen -= outleft;
  return ((_Bool )(inlen == 0UL));
}
}
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) 
{ size_t needlen ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  needlen = 3UL * (inlen / 4UL) + 3UL;
  tmp = malloc(needlen);
  *out = (char *)tmp;
  if (! *out) {
    return ((_Bool)1);
  }
  tmp___0 = base64_decode_ctx(ctx, (char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                              & needlen);
  if (! tmp___0) {
    free((void *)*out);
    *out = (char *)((void *)0);
    return ((_Bool)0);
  }
  if (outlen) {
    *outlen = needlen;
  }
  return ((_Bool)1);
}
}
_Bool c_isascii(int c ) ;
_Bool c_isalnum(int c ) ;
_Bool c_isalpha(int c ) ;
_Bool c_isblank(int c ) ;
_Bool c_iscntrl(int c ) ;
_Bool c_isdigit(int c ) ;
_Bool c_islower(int c ) ;
_Bool c_isgraph(int c ) ;
_Bool c_isprint(int c ) ;
_Bool c_ispunct(int c ) ;
_Bool c_isspace(int c ) ;
_Bool c_isupper(int c ) ;
_Bool c_isxdigit(int c ) ;
int c_tolower(int c ) ;
int c_toupper(int c ) ;
_Bool c_isascii(int c ) 
{ int tmp ;

  {
  if (c >= 0) {
    if (c <= 127) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isalnum(int c ) 
{ int tmp ;

  {
  if (c >= 48) {
    if (c <= 57) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: 
  if ((c & -33) >= 65) {
    if ((c & -33) <= 90) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isalpha(int c ) 
{ int tmp ;

  {
  if ((c & -33) >= 65) {
    if ((c & -33) <= 90) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isblank(int c ) 
{ int tmp ;

  {
  if (c == 32) {
    tmp = 1;
  } else
  if (c == 9) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_iscntrl(int c ) 
{ int tmp ;

  {
  if ((c & -32) == 0) {
    tmp = 1;
  } else
  if (c == 127) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isdigit(int c ) 
{ int tmp ;

  {
  if (c >= 48) {
    if (c <= 57) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_islower(int c ) 
{ int tmp ;

  {
  if (c >= 97) {
    if (c <= 122) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isgraph(int c ) 
{ int tmp ;

  {
  if (c >= 33) {
    if (c <= 126) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isprint(int c ) 
{ int tmp ;

  {
  if (c >= 32) {
    if (c <= 126) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_ispunct(int c ) 
{ int tmp ;

  {
  if (c >= 33) {
    if (c <= 126) {
      if (c >= 48) {
        if (c <= 57) {
          tmp = 0;
        } else {
          goto _L;
        }
      } else
      _L: 
      if ((c & -33) >= 65) {
        if ((c & -33) <= 90) {
          tmp = 0;
        } else {
          tmp = 1;
        }
      } else {
        tmp = 1;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isspace(int c ) 
{ int tmp ;

  {
  if (c == 32) {
    tmp = 1;
  } else
  if (c == 9) {
    tmp = 1;
  } else
  if (c == 10) {
    tmp = 1;
  } else
  if (c == 11) {
    tmp = 1;
  } else
  if (c == 12) {
    tmp = 1;
  } else
  if (c == 13) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isupper(int c ) 
{ int tmp ;

  {
  if (c >= 65) {
    if (c <= 90) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
_Bool c_isxdigit(int c ) 
{ int tmp ;

  {
  if (c >= 48) {
    if (c <= 57) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: 
  if ((c & -33) >= 65) {
    if ((c & -33) <= 70) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
int c_tolower(int c ) 
{ int tmp ;

  {
  if (c >= 65) {
    if (c <= 90) {
      tmp = (c - 65) + 97;
    } else {
      tmp = c;
    }
  } else {
    tmp = c;
  }
  return (tmp);
}
}
int c_toupper(int c ) 
{ int tmp ;

  {
  if (c >= 97) {
    if (c <= 122) {
      tmp = (c - 97) + 65;
    } else {
      tmp = c;
    }
  } else {
    tmp = c;
  }
  return (tmp);
}
}
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
  p1 = (unsigned char const   *)s1;
  p2 = (unsigned char const   *)s2;
  if ((unsigned long )p1 == (unsigned long )p2) {
    return (0);
  }
  while (1) {
    __c = (int )*p1;
    if (__c >= 65) {
      if (__c <= 90) {
        tmp = (__c - 65) + 97;
      } else {
        tmp = __c;
      }
    } else {
      tmp = __c;
    }
    c1 = (unsigned char )tmp;
    __c___0 = (int )*p2;
    if (__c___0 >= 65) {
      if (__c___0 <= 90) {
        tmp___0 = (__c___0 - 65) + 97;
      } else {
        tmp___0 = __c___0;
      }
    } else {
      tmp___0 = __c___0;
    }
    c2 = (unsigned char )tmp___0;
    if ((int )c1 == 0) {
      break;
    }
    p1 ++;
    p2 ++;
    if (! ((int )c1 == (int )c2)) {
      break;
    }
  }
  return ((int )c1 - (int )c2);
}
}
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
  p1 = (unsigned char const   *)s1;
  p2 = (unsigned char const   *)s2;
  if ((unsigned long )p1 == (unsigned long )p2) {
    return (0);
  } else
  if (n == 0UL) {
    return (0);
  }
  while (1) {
    __c = (int )*p1;
    if (__c >= 65) {
      if (__c <= 90) {
        tmp = (__c - 65) + 97;
      } else {
        tmp = __c;
      }
    } else {
      tmp = __c;
    }
    c1 = (unsigned char )tmp;
    __c___0 = (int )*p2;
    if (__c___0 >= 65) {
      if (__c___0 <= 90) {
        tmp___0 = (__c___0 - 65) + 97;
      } else {
        tmp___0 = __c___0;
      }
    } else {
      tmp___0 = __c___0;
    }
    c2 = (unsigned char )tmp___0;
    n --;
    if (n == 0UL) {
      break;
    } else
    if ((int )c1 == 0) {
      break;
    }
    p1 ++;
    p2 ++;
    if (! ((int )c1 == (int )c2)) {
      break;
    }
  }
  return ((int )c1 - (int )c2);
}
}
double c_strtod(char const   *nptr , char **endptr ) ;
extern  __attribute__((__nothrow__)) __locale_t newlocale(int __category_mask , char const   *__locale ,
                                                          __locale_t __base ) ;
extern  __attribute__((__nothrow__)) double strtod_l(char const   * __restrict  __nptr ,
                                                     char ** __restrict  __endptr ,
                                                     __locale_t __loc )  __attribute__((__warn_unused_result__,
__nonnull__(1,3))) ;
static locale_t volatile   c_locale_cache  ;
__inline static locale_t c_locale(void) 
{ __locale_t tmp ;

  {
  if (! c_locale_cache) {
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
    c_locale_cache = (locale_t volatile   )tmp;
  }
  return ((locale_t )c_locale_cache);
}
}
double c_strtod(char const   *nptr , char **endptr ) 
{ double r ;
  locale_t locale ;
  locale_t tmp ;

  {
  tmp = c_locale();
  locale = tmp;
  if (! locale) {
    if (endptr) {
      *endptr = (char *)nptr;
    }
    return ((double )0);
  }
  r = strtod_l((char const   * __restrict  )nptr, (char ** __restrict  )endptr, locale);
  return (r);
}
}
long double c_strtold(char const   *nptr , char **endptr ) ;
extern  __attribute__((__nothrow__)) long double strtold_l(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr ,
                                                           __locale_t __loc )  __attribute__((__warn_unused_result__,
__nonnull__(1,3))) ;
static locale_t volatile   c_locale_cache___0  ;
__inline static locale_t c_locale___0(void) 
{ __locale_t tmp ;

  {
  if (! c_locale_cache___0) {
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
    c_locale_cache___0 = (locale_t volatile   )tmp;
  }
  return ((locale_t )c_locale_cache___0);
}
}
long double c_strtold(char const   *nptr , char **endptr ) 
{ long double r ;
  locale_t locale ;
  locale_t tmp ;

  {
  tmp = c_locale___0();
  locale = tmp;
  if (! locale) {
    if (endptr) {
      *endptr = (char *)nptr;
    }
    return ((long double )0);
  }
  r = strtold_l((char const   * __restrict  )nptr, (char ** __restrict  )endptr, locale);
  return (r);
}
}
char *canon_host(char const   *host ) ;
char *canon_host_r(char const   *host , int *cherror ) ;
char const   *ch_strerror(void) ;
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 

  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recv)(int __fd ,
                                                                                                    void *__buf ,
                                                                                                    size_t __n ,
                                                                                                    int __flags ) ;
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recvfrom)(int __fd ,
                                                                                                        void * __restrict  __buf ,
                                                                                                        size_t __n ,
                                                                                                        int __flags ,
                                                                                                        struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                                        socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recv)(int __fd ,
                                                                                                    void *__buf ,
                                                                                                    size_t __n ,
                                                                                                    int __flags ) 
{ unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
__inline extern ssize_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) recvfrom)(int __fd ,
                                                                                                        void * __restrict  __buf ,
                                                                                                        size_t __n ,
                                                                                                        int __flags ,
                                                                                                        struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                                        socklen_t * __restrict  __addr_len ) 
{ __SOCKADDR_ARG __addr ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  __addr.__sockaddr__ = __cil_tmp14;
  tmp___4 = __builtin_object_size((void *)__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 0);
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr.__sockaddr__,
                             __addr_len);
    return ((ssize_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 0);
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr.__sockaddr__,
                                    __addr_len);
      return ((ssize_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr.__sockaddr__, __addr_len);
  return ((ssize_t __attribute__((__artificial__))  )tmp___5);
}
}
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
static int last_cherror  ;
char *canon_host(char const   *host ) 
{ char *tmp ;

  {
  tmp = canon_host_r(host, & last_cherror);
  return (tmp);
}
}
static struct addrinfo hints  ;
char *canon_host_r(char const   *host , int *cherror ) 
{ char *retval ;
  struct addrinfo *res ;
  int status ;
  char const   *tmp___11 ;
  char *tmp___12 ;

  {
  retval = (char *)((void *)0);
  res = (struct addrinfo *)((void *)0);
  hints.ai_flags = 2;
  status = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )((void *)0),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& res));
  if (! status) {
    if (res->ai_canonname) {
      tmp___11 = (char const   *)res->ai_canonname;
    } else {
      tmp___11 = host;
    }
    tmp___12 = __strdup(tmp___11);
    retval = tmp___12;
    if (! retval) {
      if (cherror) {
        *cherror = -10;
      }
    }
    freeaddrinfo(res);
  } else
  if (cherror) {
    *cherror = status;
  }
  return (retval);
}
}
char const   *ch_strerror(void) 
{ char const   *tmp ;

  {
  tmp = gai_strerror(last_cherror);
  return (tmp);
}
}
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) ;
extern void *__rawmemchr(void const   *__s , int __c ) ;
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) )  __attribute__((__warn_unused_result__)) ;
void hash_free(Hash_table *table___1 ) ;
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats )  __attribute__((__nonnull__(2,3))) ;
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) ;
size_t triple_hash(void const   *x , size_t table_size ) ;
_Bool triple_compare_ino_str(void const   *x , void const   *y ) ;
void triple_free(void *x ) ;
char *xgetcwd(void) ;
static _Bool seen_triple(Hash_table **ht___0 , char const   *filename , struct stat  const  *st ) 
{ size_t initial_capacity ;
  _Bool tmp ;

  {
  if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
    initial_capacity = (size_t )7;
    *ht___0 = hash_initialize(initial_capacity, (Hash_tuning const   *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
    if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
      xalloc_die();
    }
  }
  tmp = seen_file((Hash_table const   *)*ht___0, filename, st);
  if (tmp) {
    return ((_Bool)1);
  }
  record_file(*ht___0, filename, st);
  return ((_Bool)0);
}
}
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) 
{ char *rname ;
  char *dest ;
  char *extra_buf ;
  char const   *start ;
  char const   *end ;
  char const   *rname_limit ;
  size_t extra_len ;
  Hash_table *ht___0 ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *p ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct stat st ;
  char *tmp___6 ;
  ptrdiff_t dest_offset ;
  size_t new_size ;
  void *tmp___7 ;
  void __attribute__((__artificial__))  *tmp___8 ;
  int *tmp___9 ;
  unsigned long tmp___19 ;
  int tmp___20 ;
  char *buf___1 ;
  size_t n ;
  size_t len ;
  _Bool tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void __attribute__((__artificial__))  *tmp___26 ;
  void *tmp___28 ;
  int *tmp___29 ;

  {
  extra_buf = (char *)((void *)0);
  extra_len = (size_t )0;
  ht___0 = (Hash_table *)((void *)0);
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((char *)((void *)0));
  }
  if ((int const   )*(name + 0) == 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 2;
    return ((char *)((void *)0));
  }
  if ((int const   )*(name + 0) != 47) {
    rname = xgetcwd();
    if (! rname) {
      return ((char *)((void *)0));
    }
    tmp___1 = __rawmemchr((void const   *)rname, '\000');
    dest = (char *)tmp___1;
    if (dest - rname < 4096) {
      tmp___3 = xrealloc((void *)rname, (size_t )4096);
      p = (char *)tmp___3;
      dest = p + (dest - rname);
      rname = p;
      rname_limit = (char const   *)(rname + 4096);
    } else {
      rname_limit = (char const   *)dest;
    }
  } else {
    tmp___4 = xmalloc((size_t )4096);
    rname = (char *)tmp___4;
    rname_limit = (char const   *)(rname + 4096);
    *(rname + 0) = (char )'/';
    dest = rname + 1;
  }
  start = name;
  while (*start) {
    while ((int const   )*start == 47) {
      start ++;
    }
    end = start;
    while (1) {
      if (*end) {
        if (! ((int const   )*end != 47)) {
          break;
        }
      } else {
        break;
      }
      end ++;
    }
    if (end - start == 0) {
      break;
    } else
    if (end - start == 1) {
      if (! ((int const   )*(start + 0) == 46)) {
        goto _L___1;
      }
    } else
    _L___1: 
    if (end - start == 2) {
      if ((int const   )*(start + 0) == 46) {
        if ((int const   )*(start + 1) == 46) {
          if ((unsigned long )dest > (unsigned long )(rname + 1)) {
            while (1) {
              dest --;
              if (! ((int )*(dest + -1) != 47)) {
                break;
              }
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((int )*(dest + -1) != 47) {
        tmp___6 = dest;
        dest ++;
        *tmp___6 = (char )'/';
      }
      if ((unsigned long )(dest + (end - start)) >= (unsigned long )rname_limit) {
        dest_offset = (ptrdiff_t )(dest - rname);
        new_size = (size_t )(rname_limit - (char const   *)rname);
        if ((end - start) + 1 > 4096) {
          new_size += (size_t )((end - start) + 1);
        } else {
          new_size += 4096UL;
        }
        tmp___7 = xrealloc((void *)rname, new_size);
        rname = (char *)tmp___7;
        rname_limit = (char const   *)(rname + new_size);
        dest = rname + dest_offset;
      }
      tmp___8 = memcpy((void * __restrict  )dest, (void const   * __restrict  )start,
                       (size_t )(end - start));
      dest = (char *)tmp___8;
      dest += end - start;
      *dest = (char )'\000';
      tmp___20 = lstat((char const   * __restrict  )rname, (struct stat * __restrict  )(& st));
      if (tmp___20 != 0) {
        tmp___9 = __errno_location();
        saved_errno = *tmp___9;
        if ((unsigned int )can_mode == 0U) {
          goto error;
        }
        if ((unsigned int )can_mode == 1U) {
          tmp___19 = __builtin_strspn(end, "/");
          if (*(end + tmp___19)) {
            goto error;
          } else
          if (saved_errno != 2) {
            goto error;
          }
          goto __Cont;
        }
        st.st_mode = (__mode_t )0;
      }
      if ((st.st_mode & 61440U) == 40960U) {
        tmp___21 = seen_triple(& ht___0, name, (struct stat  const  *)(& st));
        if (tmp___21) {
          if ((unsigned int )can_mode == 2U) {
            goto __Cont;
          }
          saved_errno = 40;
          goto error;
        }
        buf___1 = areadlink_with_size((char const   *)rname, (size_t )st.st_size);
        if (! buf___1) {
          if ((unsigned int )can_mode == 2U) {
            tmp___22 = __errno_location();
            if (*tmp___22 != 12) {
              goto __Cont;
            }
          }
          tmp___23 = __errno_location();
          saved_errno = *tmp___23;
          goto error;
        }
        n = strlen((char const   *)buf___1);
        len = strlen(end);
        if (! extra_len) {
          if ((n + len) + 1UL > 4096UL) {
            extra_len = (n + len) + 1UL;
          } else {
            extra_len = (size_t )4096;
          }
          tmp___24 = xmalloc(extra_len);
          extra_buf = (char *)tmp___24;
        } else
        if ((n + len) + 1UL > extra_len) {
          extra_len = (n + len) + 1UL;
          tmp___25 = xrealloc((void *)extra_buf, extra_len);
          extra_buf = (char *)tmp___25;
        }
        memmove((void *)(extra_buf + n), (void const   *)end, len + 1UL);
        tmp___26 = memcpy((void * __restrict  )extra_buf, (void const   * __restrict  )buf___1,
                          n);
        end = (char const   *)tmp___26;
        name = end;
        if ((int )*(buf___1 + 0) == 47) {
          dest = rname + 1;
        } else
        if ((unsigned long )dest > (unsigned long )(rname + 1)) {
          while (1) {
            dest --;
            if (! ((int )*(dest + -1) != 47)) {
              break;
            }
          }
        }
        free((void *)buf___1);
      } else
      if (! ((st.st_mode & 61440U) == 16384U)) {
        if (*end) {
          if ((unsigned int )can_mode != 2U) {
            saved_errno = 20;
            goto error;
          }
        }
      }
    }
    __Cont: 
    start = end;
  }
  if ((unsigned long )dest > (unsigned long )(rname + 1)) {
    if ((int )*(dest + -1) == 47) {
      dest --;
    }
  }
  *dest = (char )'\000';
  if ((unsigned long )rname_limit != (unsigned long )(dest + 1)) {
    tmp___28 = xrealloc((void *)rname, (size_t )((dest - rname) + 1));
    rname = (char *)tmp___28;
  }
  free((void *)extra_buf);
  if (ht___0) {
    hash_free(ht___0);
  }
  return (rname);
  error: 
  free((void *)extra_buf);
  free((void *)rname);
  if (ht___0) {
    hash_free(ht___0);
  }
  tmp___29 = __errno_location();
  *tmp___29 = saved_errno;
  return ((char *)((void *)0));
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
ssize_t careadlinkatcwd(int fd , char const   *filename , char *buffer , size_t buffer_size ) 
{ ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp ;
  ssize_t __attribute__((__nonnull__(1,2), __artificial__))  tmp___0 ;

  {
  if (fd != -100) {
    abort();
  }
  tmp___0 = (ssize_t __attribute__((__nonnull__(1,2), __artificial__))  )readlink((char const   * __restrict  )filename,
                                                                                  (char * __restrict  )buffer,
                                                                                  buffer_size);
  tmp = tmp___0;
  return ((ssize_t )tmp);
}
}
char *careadlinkat(int fd , char const   *filename , char *buffer , size_t buffer_size ,
                   struct allocator  const  *alloc , ssize_t (*preadlinkat)(int  ,
                                                                            char const   * ,
                                                                            char * ,
                                                                            size_t  ) ) 
{ char *buf___1 ;
  size_t buf_size ;
  size_t buf_size_max ;
  char stack_buf[1024] ;
  ssize_t link_length ;
  ssize_t tmp ;
  size_t link_size ;
  int readlinkat_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char *b ;
  void *tmp___3 ;
  char *b___0 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;

  {
  buf_size_max = 0x8000000000000000UL;
  if (! alloc) {
    alloc = & stdlib_allocator;
  }
  if (! buffer_size) {
    buffer = stack_buf;
    buffer_size = sizeof(stack_buf);
  }
  buf___1 = buffer;
  buf_size = buffer_size;
  while (1) {
    tmp = (*preadlinkat)(fd, filename, buf___1, buf_size);
    link_length = tmp;
    if (link_length < 0L) {
      tmp___0 = __errno_location();
      readlinkat_errno = *tmp___0;
      if (readlinkat_errno != 34) {
        if ((unsigned long )buf___1 != (unsigned long )buffer) {
          (*(alloc->free))((void *)buf___1);
          tmp___1 = __errno_location();
          *tmp___1 = readlinkat_errno;
        }
        return ((char *)((void *)0));
      }
    }
    link_size = (size_t )link_length;
    if (link_size < buf_size) {
      tmp___2 = link_size;
      link_size ++;
      *(buf___1 + tmp___2) = (char )'\000';
      if ((unsigned long )buf___1 == (unsigned long )(stack_buf)) {
        tmp___3 = (*(alloc->allocate))(link_size);
        b = (char *)tmp___3;
        buf_size = link_size;
        if (! b) {
          break;
        }
        memcpy((void * __restrict  )b, (void const   * __restrict  )buf___1, link_size);
        buf___1 = b;
      } else
      if (link_size < buf_size) {
        if ((unsigned long )buf___1 != (unsigned long )buffer) {
          if (alloc->reallocate) {
            tmp___4 = (*(alloc->reallocate))((void *)buf___1, link_size);
            b___0 = (char *)tmp___4;
            if (b___0) {
              buf___1 = b___0;
            }
          }
        }
      }
      return (buf___1);
    }
    if ((unsigned long )buf___1 != (unsigned long )buffer) {
      (*(alloc->free))((void *)buf___1);
    }
    if (buf_size <= buf_size_max / 2UL) {
      buf_size *= 2UL;
    } else
    if (buf_size < buf_size_max) {
      buf_size = buf_size_max;
    } else
    if (buf_size_max < 0xffffffffffffffffUL) {
      tmp___5 = __errno_location();
      *tmp___5 = 36;
      return ((char *)((void *)0));
    } else {
      break;
    }
    tmp___6 = (*(alloc->allocate))(buf_size);
    buf___1 = (char *)tmp___6;
    if (! buf___1) {
      break;
    }
  }
  if (alloc->die) {
    (*(alloc->die))(buf_size);
  }
  tmp___7 = __errno_location();
  *tmp___7 = 12;
  return ((char *)((void *)0));
}
}
int set_cloexec_flag(int desc , _Bool value ) ;
int dup_cloexec(int fd ) ;
int rpl_fcntl(int fd , int action  , ...) ;
int set_cloexec_flag(int desc , _Bool value ) 
{ int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = rpl_fcntl(desc, 1, 0);
  flags = tmp;
  if (0 <= flags) {
    if (value) {
      tmp___0 = flags | 1;
    } else {
      tmp___0 = flags & -2;
    }
    newflags = tmp___0;
    if (flags == newflags) {
      return (0);
    } else {
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      if (tmp___1 != -1) {
        return (0);
      }
    }
  }
  return (-1);
}
}
int dup_cloexec(int fd ) 
{ int tmp ;

  {
  tmp = rpl_fcntl(fd, 1030, 0);
  return (tmp);
}
}
int rpl_fclose(FILE *fp )  __attribute__((__nonnull__(1))) ;
int close_stream(FILE *stream ) ;
extern  __attribute__((__nothrow__)) size_t __fpending(FILE *__fp ) ;
int close_stream(FILE *stream ) 
{ _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  tmp = __fpending(stream);
  some_pending = (_Bool )(tmp != 0UL);
  tmp___0 = ferror_unlocked(stream);
  prev_fail = (_Bool )(tmp___0 != 0);
  tmp___1 = rpl_fclose(stream);
  fclose_fail = (_Bool )(tmp___1 != 0);
  if (prev_fail) {
    goto _L___0;
  } else
  if (fclose_fail) {
    if (some_pending) {
      goto _L___0;
    } else {
      tmp___3 = __errno_location();
      if (*tmp___3 != 9) {
        _L___0: 
        if (! fclose_fail) {
          tmp___2 = __errno_location();
          *tmp___2 = 0;
        }
        return (-1);
      }
    }
  }
  return (0);
}
}
void close_stdin_set_file_name(char const   *file ) ;
void close_stdin(void) ;
int rpl_fflush(FILE *stream ) ;
int rpl_fseeko(FILE *fp , off_t offset , int whence )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
void close_stdout(void) ;
int volatile   exit_failure ;
size_t freadahead(FILE *fp ) ;
char *quotearg_colon(char const   *arg ) ;
static char const   *file_name  ;
void close_stdin_set_file_name(char const   *file ) 
{ 

  {
  file_name = file;
  return;
}
}
void close_stdin(void) 
{ _Bool fail ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *close_error ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  fail = (_Bool)0;
  tmp___1 = freadahead(stdin);
  if (tmp___1 > 0UL) {
    tmp = rpl_fseeko(stdin, (off_t )0, 1);
    if (tmp == 0) {
      tmp___0 = rpl_fflush(stdin);
      if (tmp___0 != 0) {
        fail = (_Bool)1;
      }
    }
  }
  tmp___2 = close_stream(stdin);
  if (tmp___2 != 0) {
    fail = (_Bool)1;
  }
  if (fail) {
    tmp___3 = dcgettext((char const   *)((void *)0), "error closing file", 5);
    close_error = (char const   *)tmp___3;
    if (file_name) {
      tmp___4 = quotearg_colon(file_name);
      tmp___5 = __errno_location();
      error(0, *tmp___5, "%s: %s", tmp___4, close_error);
    } else {
      tmp___6 = __errno_location();
      error(0, *tmp___6, "%s", close_error);
    }
  }
  close_stdout();
  if (fail) {
    _exit((int )exit_failure);
  }
  return;
}
}
void close_stdout_set_file_name(char const   *file ) ;
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
static char const   *file_name___0  ;
void close_stdout_set_file_name(char const   *file ) 
{ 

  {
  file_name___0 = file;
  return;
}
}
static _Bool ignore_EPIPE  ;
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 

  {
  ignore_EPIPE = ignore;
  return;
}
}
void close_stdout(void) 
{ char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  tmp___3 = close_stream(stdout);
  if (tmp___3 != 0) {
    if (ignore_EPIPE) {
      tmp___4 = __errno_location();
      if (! (*tmp___4 == 32)) {
        goto _L;
      }
    } else {
      _L: 
      tmp = dcgettext((char const   *)((void *)0), "write error", 5);
      write_error = (char const   *)tmp;
      if (file_name___0) {
        tmp___0 = quotearg_colon(file_name___0);
        tmp___1 = __errno_location();
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
      } else {
        tmp___2 = __errno_location();
        error(0, *tmp___2, "%s", write_error);
      }
      _exit((int )exit_failure);
    }
  }
  tmp___5 = close_stream(stderr);
  if (tmp___5 != 0) {
    _exit((int )exit_failure);
  }
  return;
}
}
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len ,
                                               void *resblock ) ;
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
void md5_init_ctx(struct md5_ctx *ctx ) 
{ uint32_t tmp ;

  {
  ctx->A = (uint32_t )1732584193;
  ctx->B = 4023233417U;
  ctx->C = 2562383102U;
  ctx->D = (uint32_t )271733878;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (uint32_t )0;
  return;
}
}
__inline static void set_uint32(char *cp , uint32_t v ) 
{ 

  {
  memcpy((void * __restrict  )cp, (void const   * __restrict  )(& v), sizeof(v));
  return;
}
}
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ char *r ;

  {
  r = (char *)resbuf;
  set_uint32(r + 0UL, (uint32_t )ctx->A);
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
  return (resbuf);
}
}
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
  bytes = ctx->buflen;
  if (bytes < 56U) {
    tmp = 16;
  } else {
    tmp = 32;
  }
  size = (size_t )tmp;
  ctx->total[0] += bytes;
  if (ctx->total[0] < bytes) {
    (ctx->total[1]) ++;
  }
  ctx->buffer[size - 2UL] = ctx->total[0] << 3;
  ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf),
         (size - 2UL) * 4UL - (size_t )bytes);
  md5_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  return (tmp___0);
}
}
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
int md5_stream(FILE *stream , void *resblock ) 
{ struct md5_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  if (! buffer) {
    return (1);
  }
  md5_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
      tmp___0 = tmp___3;
      n = (size_t )tmp___0;
      sum += n;
      if (sum == 32768UL) {
        break;
      }
      if (n == 0UL) {
        tmp___1 = ferror_unlocked(stream);
        if (tmp___1) {
          free((void *)buffer);
          return (1);
        }
        goto process_partial_block;
      }
      tmp___2 = feof_unlocked(stream);
      if (tmp___2) {
        goto process_partial_block;
      }
    }
    md5_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: 
  if (sum > 0UL) {
    md5_process_bytes((void const   *)buffer, sum, & ctx);
  }
  md5_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  return (0);
}
}
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len ,
                                               void *resblock ) ;
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct md5_ctx ctx ;
  void *tmp ;

  {
  md5_init_ctx(& ctx);
  md5_process_bytes((void const   *)buffer, len, & ctx);
  tmp = md5_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
  if (ctx->buflen != 0U) {
    left_over = (size_t )ctx->buflen;
    if (128UL - left_over > len) {
      tmp = len;
    } else {
      tmp = 128UL - left_over;
    }
    add = tmp;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    if (ctx->buflen > 64U) {
      md5_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
      ctx->buflen &= 63U;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
    }
    buffer = (void const   *)((char const   *)buffer + add);
    len -= add;
  }
  if (len >= 64UL) {
    md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
    len &= 63UL;
  }
  if (len > 0UL) {
    left_over___0 = (size_t )ctx->buflen;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
    left_over___0 += len;
    if (left_over___0 >= 64UL) {
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
      left_over___0 -= 64UL;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
    ctx->buflen = (uint32_t )left_over___0;
  }
  return;
}
}
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;

  {
  words = (uint32_t const   *)buffer;
  nwords = len / sizeof(uint32_t );
  endp = words + nwords;
  A = ctx->A;
  B = ctx->B;
  C = ctx->C;
  D = ctx->D;
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
  if ((size_t )ctx->total[0] < len) {
    (ctx->total[1]) ++;
  }
  while ((unsigned long )words < (unsigned long )endp) {
    cwp = correct_words;
    A_save = A;
    B_save = B;
    C_save = C;
    D_save = D;
    while (1) {
      tmp = cwp;
      cwp ++;
      tmp___0 = (uint32_t )*words;
      *tmp = tmp___0;
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___1 = cwp;
      cwp ++;
      tmp___2 = (uint32_t )*words;
      *tmp___1 = tmp___2;
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___3 = cwp;
      cwp ++;
      tmp___4 = (uint32_t )*words;
      *tmp___3 = tmp___4;
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___5 = cwp;
      cwp ++;
      tmp___6 = (uint32_t )*words;
      *tmp___5 = tmp___6;
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      tmp___7 = cwp;
      cwp ++;
      tmp___8 = (uint32_t )*words;
      *tmp___7 = tmp___8;
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___9 = cwp;
      cwp ++;
      tmp___10 = (uint32_t )*words;
      *tmp___9 = tmp___10;
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___11 = cwp;
      cwp ++;
      tmp___12 = (uint32_t )*words;
      *tmp___11 = tmp___12;
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___13 = cwp;
      cwp ++;
      tmp___14 = (uint32_t )*words;
      *tmp___13 = tmp___14;
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      tmp___15 = cwp;
      cwp ++;
      tmp___16 = (uint32_t )*words;
      *tmp___15 = tmp___16;
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___17 = cwp;
      cwp ++;
      tmp___18 = (uint32_t )*words;
      *tmp___17 = tmp___18;
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___19 = cwp;
      cwp ++;
      tmp___20 = (uint32_t )*words;
      *tmp___19 = tmp___20;
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___21 = cwp;
      cwp ++;
      tmp___22 = (uint32_t )*words;
      *tmp___21 = tmp___22;
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      tmp___23 = cwp;
      cwp ++;
      tmp___24 = (uint32_t )*words;
      *tmp___23 = tmp___24;
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
      words ++;
      A = (A << 7) | (A >> 25);
      A += B;
      break;
    }
    while (1) {
      tmp___25 = cwp;
      cwp ++;
      tmp___26 = (uint32_t )*words;
      *tmp___25 = tmp___26;
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
      words ++;
      D = (D << 12) | (D >> 20);
      D += A;
      break;
    }
    while (1) {
      tmp___27 = cwp;
      cwp ++;
      tmp___28 = (uint32_t )*words;
      *tmp___27 = tmp___28;
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
      words ++;
      C = (C << 17) | (C >> 15);
      C += D;
      break;
    }
    while (1) {
      tmp___29 = cwp;
      cwp ++;
      tmp___30 = (uint32_t )*words;
      *tmp___29 = tmp___30;
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
      words ++;
      B = (B << 22) | (B >> 10);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
      A = (A << 5) | (A >> 27);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
      D = (D << 9) | (D >> 23);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
      C = (C << 14) | (C >> 18);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
      B = (B << 20) | (B >> 12);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
      A = (A << 4) | (A >> 28);
      A += B;
      break;
    }
    while (1) {
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
      D = (D << 11) | (D >> 21);
      D += A;
      break;
    }
    while (1) {
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
      C = (C << 16) | (C >> 16);
      C += D;
      break;
    }
    while (1) {
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
      B = (B << 23) | (B >> 9);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    while (1) {
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
      A = (A << 6) | (A >> 26);
      A += B;
      break;
    }
    while (1) {
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
      D = (D << 10) | (D >> 22);
      D += A;
      break;
    }
    while (1) {
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
      C = (C << 15) | (C >> 17);
      C += D;
      break;
    }
    while (1) {
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
      B = (B << 21) | (B >> 11);
      B += C;
      break;
    }
    A += A_save;
    B += B_save;
    C += C_save;
    D += D_save;
  }
  ctx->A = A;
  ctx->B = B;
  ctx->C = C;
  ctx->D = D;
  return;
}
}
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
int sha1_stream(FILE *stream , void *resblock ) ;
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) ;
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ uint32_t tmp ;

  {
  ctx->A = (uint32_t )1732584193;
  ctx->B = 4023233417U;
  ctx->C = 2562383102U;
  ctx->D = (uint32_t )271733878;
  ctx->E = 3285377520U;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (uint32_t )0;
  return;
}
}
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ char *r ;

  {
  r = (char *)resbuf;
  set_uint32(r + 0UL, (uint32_t )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24)));
  set_uint32(r + sizeof(ctx->B), (uint32_t )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24)));
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24)));
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24)));
  set_uint32(r + 4UL * sizeof(ctx->E), (uint32_t )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24)));
  return (resbuf);
}
}
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
  bytes = ctx->buflen;
  if (bytes < 56U) {
    tmp = 16;
  } else {
    tmp = 32;
  }
  size = (size_t )tmp;
  ctx->total[0] += bytes;
  if (ctx->total[0] < bytes) {
    (ctx->total[1]) ++;
  }
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___0),
         (size - 2UL) * 4UL - (size_t )bytes);
  sha1_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
  tmp___0 = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
  return (tmp___0);
}
}
int sha1_stream(FILE *stream , void *resblock ) 
{ struct sha1_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  if (! buffer) {
    return (1);
  }
  sha1_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
      tmp___0 = tmp___3;
      n = (size_t )tmp___0;
      sum += n;
      if (sum == 32768UL) {
        break;
      }
      if (n == 0UL) {
        tmp___1 = ferror_unlocked(stream);
        if (tmp___1) {
          free((void *)buffer);
          return (1);
        }
        goto process_partial_block;
      }
      tmp___2 = feof_unlocked(stream);
      if (tmp___2) {
        goto process_partial_block;
      }
    }
    sha1_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
  if (sum > 0UL) {
    sha1_process_bytes((void const   *)buffer, sum, & ctx);
  }
  sha1_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  return (0);
}
}
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha1_ctx ctx ;
  void *tmp ;

  {
  sha1_init_ctx(& ctx);
  sha1_process_bytes((void const   *)buffer, len, & ctx);
  tmp = sha1_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
  if (ctx->buflen != 0U) {
    left_over = (size_t )ctx->buflen;
    if (128UL - left_over > len) {
      tmp = len;
    } else {
      tmp = 128UL - left_over;
    }
    add = tmp;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
    if (ctx->buflen > 64U) {
      sha1_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
      ctx->buflen &= 63U;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
    }
    buffer = (void const   *)((char const   *)buffer + add);
    len -= add;
  }
  if (len >= 64UL) {
    sha1_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
    len &= 63UL;
  }
  if (len > 0UL) {
    left_over___0 = (size_t )ctx->buflen;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
    left_over___0 += len;
    if (left_over___0 >= 64UL) {
      sha1_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
      left_over___0 -= 64UL;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
    ctx->buflen = (uint32_t )left_over___0;
  }
  return;
}
}
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t tm ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
  words = (uint32_t const   *)buffer;
  nwords = len / sizeof(uint32_t );
  endp = words + nwords;
  a = ctx->A;
  b = ctx->B;
  c = ctx->C;
  d = ctx->D;
  e = ctx->E;
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
  if ((size_t )ctx->total[0] < len) {
    (ctx->total[1]) ++;
  }
  while ((unsigned long )words < (unsigned long )endp) {
    t = 0;
    while (t < 16) {
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
      words ++;
      t ++;
    }
    while (1) {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
      x[0] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
      x[1] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
      x[2] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
      x[3] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
      x[4] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
      x[5] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
      x[6] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
      x[7] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
      x[8] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
      x[9] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
      x[10] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
      c = (c << 30) | (c >> 2);
      break;
    }
    while (1) {
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
      x[11] = (tm << 1) | (tm >> 31);
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
      b = (b << 30) | (b >> 2);
      break;
    }
    while (1) {
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
      x[12] = (tm << 1) | (tm >> 31);
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
      a = (a << 30) | (a >> 2);
      break;
    }
    while (1) {
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
      x[13] = (tm << 1) | (tm >> 31);
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
      e = (e << 30) | (e >> 2);
      break;
    }
    while (1) {
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
      x[14] = (tm << 1) | (tm >> 31);
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
      d = (d << 30) | (d >> 2);
      break;
    }
    while (1) {
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
      x[15] = (tm << 1) | (tm >> 31);
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
      c = (c << 30) | (c >> 2);
      break;
    }
    tmp = ctx->A + a;
    ctx->A = tmp;
    a = tmp;
    tmp___0 = ctx->B + b;
    ctx->B = tmp___0;
    b = tmp___0;
    tmp___1 = ctx->C + c;
    ctx->C = tmp___1;
    c = tmp___1;
    tmp___2 = ctx->D + d;
    ctx->D = tmp___2;
    d = tmp___2;
    tmp___3 = ctx->E + e;
    ctx->E = tmp___3;
    e = tmp___3;
  }
  return;
}
}
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
int sha256_stream(FILE *stream , void *resblock ) ;
int sha224_stream(FILE *stream , void *resblock ) ;
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) ;
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) ;
static unsigned char const   fillbuf___1[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
void sha256_init_ctx(struct sha256_ctx *ctx ) 
{ uint32_t tmp ;

  {
  ctx->state[0] = (uint32_t )1779033703UL;
  ctx->state[1] = (uint32_t )3144134277UL;
  ctx->state[2] = (uint32_t )1013904242UL;
  ctx->state[3] = (uint32_t )2773480762UL;
  ctx->state[4] = (uint32_t )1359893119UL;
  ctx->state[5] = (uint32_t )2600822924UL;
  ctx->state[6] = (uint32_t )528734635UL;
  ctx->state[7] = (uint32_t )1541459225UL;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  return;
}
}
void sha224_init_ctx(struct sha256_ctx *ctx ) 
{ uint32_t tmp ;

  {
  ctx->state[0] = (uint32_t )3238371032UL;
  ctx->state[1] = (uint32_t )914150663UL;
  ctx->state[2] = (uint32_t )812702999UL;
  ctx->state[3] = (uint32_t )4144912697UL;
  ctx->state[4] = (uint32_t )4290775857UL;
  ctx->state[5] = (uint32_t )1750603025UL;
  ctx->state[6] = (uint32_t )1694076839UL;
  ctx->state[7] = (uint32_t )3204075428UL;
  tmp = (uint32_t )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  return;
}
}
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
  r = (char *)resbuf;
  i = 0;
  while (i < 8) {
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
    i ++;
  }
  return (resbuf);
}
}
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
  r = (char *)resbuf;
  i = 0;
  while (i < 7) {
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
    i ++;
  }
  return (resbuf);
}
}
static void sha256_conclude_ctx(struct sha256_ctx *ctx ) 
{ size_t bytes ;
  size_t size ;
  int tmp ;

  {
  bytes = ctx->buflen;
  if (bytes < 56UL) {
    tmp = 16;
  } else {
    tmp = 32;
  }
  size = (size_t )tmp;
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + bytes);
  if ((size_t )ctx->total[0] < bytes) {
    (ctx->total[1]) ++;
  }
  set_uint32((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24));
  set_uint32((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24));
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___1),
         (size - 2UL) * 4UL - bytes);
  sha256_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
  return;
}
}
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
  sha256_conclude_ctx(ctx);
  tmp = sha256_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
  return (tmp);
}
}
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
  sha256_conclude_ctx(ctx);
  tmp = sha224_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
  return (tmp);
}
}
int sha256_stream(FILE *stream , void *resblock ) 
{ struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  if (! buffer) {
    return (1);
  }
  sha256_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
      tmp___0 = tmp___3;
      n = (size_t )tmp___0;
      sum += n;
      if (sum == 32768UL) {
        break;
      }
      if (n == 0UL) {
        tmp___1 = ferror_unlocked(stream);
        if (tmp___1) {
          free((void *)buffer);
          return (1);
        }
        goto process_partial_block;
      }
      tmp___2 = feof_unlocked(stream);
      if (tmp___2) {
        goto process_partial_block;
      }
    }
    sha256_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
  if (sum > 0UL) {
    sha256_process_bytes((void const   *)buffer, sum, & ctx);
  }
  sha256_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  return (0);
}
}
int sha224_stream(FILE *stream , void *resblock ) 
{ struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  if (! buffer) {
    return (1);
  }
  sha224_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
      tmp___0 = tmp___3;
      n = (size_t )tmp___0;
      sum += n;
      if (sum == 32768UL) {
        break;
      }
      if (n == 0UL) {
        tmp___1 = ferror_unlocked(stream);
        if (tmp___1) {
          free((void *)buffer);
          return (1);
        }
        goto process_partial_block;
      }
      tmp___2 = feof_unlocked(stream);
      if (tmp___2) {
        goto process_partial_block;
      }
    }
    sha256_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
  if (sum > 0UL) {
    sha256_process_bytes((void const   *)buffer, sum, & ctx);
  }
  sha224_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  return (0);
}
}
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha256_ctx ctx ;
  void *tmp ;

  {
  sha256_init_ctx(& ctx);
  sha256_process_bytes((void const   *)buffer, len, & ctx);
  tmp = sha256_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha256_ctx ctx ;
  void *tmp ;

  {
  sha224_init_ctx(& ctx);
  sha256_process_bytes((void const   *)buffer, len, & ctx);
  tmp = sha224_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
  if (ctx->buflen != 0UL) {
    left_over = ctx->buflen;
    if (128UL - left_over > len) {
      tmp = len;
    } else {
      tmp = 128UL - left_over;
    }
    add = tmp;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
    ctx->buflen += add;
    if (ctx->buflen > 64UL) {
      sha256_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffffc0UL,
                           ctx);
      ctx->buflen &= 63UL;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             ctx->buflen);
    }
    buffer = (void const   *)((char const   *)buffer + add);
    len -= add;
  }
  if (len >= 64UL) {
    sha256_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
    len &= 63UL;
  }
  if (len > 0UL) {
    left_over___0 = ctx->buflen;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
    left_over___0 += len;
    if (left_over___0 >= 64UL) {
      sha256_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
      left_over___0 -= 64UL;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
    ctx->buflen = left_over___0;
  }
  return;
}
}
static uint32_t const   sha256_round_constants[64]  = 
  {      (uint32_t const   )1116352408UL,      (uint32_t const   )1899447441UL,      (uint32_t const   )3049323471UL,      (uint32_t const   )3921009573UL, 
        (uint32_t const   )961987163UL,      (uint32_t const   )1508970993UL,      (uint32_t const   )2453635748UL,      (uint32_t const   )2870763221UL, 
        (uint32_t const   )3624381080UL,      (uint32_t const   )310598401UL,      (uint32_t const   )607225278UL,      (uint32_t const   )1426881987UL, 
        (uint32_t const   )1925078388UL,      (uint32_t const   )2162078206UL,      (uint32_t const   )2614888103UL,      (uint32_t const   )3248222580UL, 
        (uint32_t const   )3835390401UL,      (uint32_t const   )4022224774UL,      (uint32_t const   )264347078UL,      (uint32_t const   )604807628UL, 
        (uint32_t const   )770255983UL,      (uint32_t const   )1249150122UL,      (uint32_t const   )1555081692UL,      (uint32_t const   )1996064986UL, 
        (uint32_t const   )2554220882UL,      (uint32_t const   )2821834349UL,      (uint32_t const   )2952996808UL,      (uint32_t const   )3210313671UL, 
        (uint32_t const   )3336571891UL,      (uint32_t const   )3584528711UL,      (uint32_t const   )113926993UL,      (uint32_t const   )338241895UL, 
        (uint32_t const   )666307205UL,      (uint32_t const   )773529912UL,      (uint32_t const   )1294757372UL,      (uint32_t const   )1396182291UL, 
        (uint32_t const   )1695183700UL,      (uint32_t const   )1986661051UL,      (uint32_t const   )2177026350UL,      (uint32_t const   )2456956037UL, 
        (uint32_t const   )2730485921UL,      (uint32_t const   )2820302411UL,      (uint32_t const   )3259730800UL,      (uint32_t const   )3345764771UL, 
        (uint32_t const   )3516065817UL,      (uint32_t const   )3600352804UL,      (uint32_t const   )4094571909UL,      (uint32_t const   )275423344UL, 
        (uint32_t const   )430227734UL,      (uint32_t const   )506948616UL,      (uint32_t const   )659060556UL,      (uint32_t const   )883997877UL, 
        (uint32_t const   )958139571UL,      (uint32_t const   )1322822218UL,      (uint32_t const   )1537002063UL,      (uint32_t const   )1747873779UL, 
        (uint32_t const   )1955562222UL,      (uint32_t const   )2024104815UL,      (uint32_t const   )2227730452UL,      (uint32_t const   )2361852424UL, 
        (uint32_t const   )2428436474UL,      (uint32_t const   )2756734187UL,      (uint32_t const   )3204031479UL,      (uint32_t const   )3329325298UL};
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t tm ;
  uint32_t t0 ;
  uint32_t t1 ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
  words = (uint32_t const   *)buffer;
  nwords = len / sizeof(uint32_t );
  endp = words + nwords;
  a = ctx->state[0];
  b = ctx->state[1];
  c = ctx->state[2];
  d = ctx->state[3];
  e = ctx->state[4];
  f = ctx->state[5];
  g = ctx->state[6];
  h = ctx->state[7];
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
  if ((size_t )ctx->total[0] < len) {
    (ctx->total[1]) ++;
  }
  while ((unsigned long )words < (unsigned long )endp) {
    t = 0;
    while (t < 16) {
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
      words ++;
      t ++;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[0]) + x[0];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[1]) + x[1];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[2]) + x[2];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[3]) + x[3];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[4]) + x[4];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[5]) + x[5];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[6]) + x[6];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[7]) + x[7];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[8]) + x[8];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[9]) + x[9];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[10]) + x[10];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[11]) + x[11];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[12]) + x[12];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[13]) + x[13];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[14]) + x[14];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[15]) + x[15];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
      x[0] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[16]) + x[0];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
      x[1] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[17]) + x[1];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
      x[2] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[18]) + x[2];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
      x[3] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[19]) + x[3];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
      x[4] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[20]) + x[4];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
      x[5] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[21]) + x[5];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
      x[6] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[22]) + x[6];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
      x[7] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[23]) + x[7];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
      x[8] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[24]) + x[8];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
      x[9] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[25]) + x[9];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
      x[10] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[26]) + x[10];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
      x[11] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[27]) + x[11];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
      x[12] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[28]) + x[12];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
      x[13] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[29]) + x[13];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
      x[14] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[30]) + x[14];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
      x[15] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[31]) + x[15];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
      x[0] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[32]) + x[0];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
      x[1] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[33]) + x[1];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
      x[2] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[34]) + x[2];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
      x[3] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[35]) + x[3];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
      x[4] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[36]) + x[4];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
      x[5] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[37]) + x[5];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
      x[6] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[38]) + x[6];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
      x[7] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[39]) + x[7];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
      x[8] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[40]) + x[8];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
      x[9] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[41]) + x[9];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
      x[10] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[42]) + x[10];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
      x[11] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[43]) + x[11];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
      x[12] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[44]) + x[12];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
      x[13] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[45]) + x[13];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
      x[14] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[46]) + x[14];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
      x[15] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[47]) + x[15];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
      x[0] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[48]) + x[0];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
      x[1] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[49]) + x[1];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
      x[2] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[50]) + x[2];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
      x[3] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[51]) + x[3];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
      x[4] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[52]) + x[4];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
      x[5] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[53]) + x[5];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
      x[6] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[54]) + x[6];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
      x[7] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[55]) + x[7];
      e += t1;
      a = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
      x[8] = tm;
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[56]) + x[8];
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
      x[9] = tm;
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[57]) + x[9];
      c += t1;
      g = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
      x[10] = tm;
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[58]) + x[10];
      b += t1;
      f = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
      x[11] = tm;
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[59]) + x[11];
      a += t1;
      e = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
      x[12] = tm;
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[60]) + x[12];
      h += t1;
      d = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
      x[13] = tm;
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[61]) + x[13];
      g += t1;
      c = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
      x[14] = tm;
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[62]) + x[14];
      f += t1;
      b = t0 + t1;
      break;
    }
    while (1) {
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
      x[15] = tm;
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[63]) + x[15];
      e += t1;
      a = t0 + t1;
      break;
    }
    tmp = ctx->state[0] + a;
    ctx->state[0] = tmp;
    a = tmp;
    tmp___0 = ctx->state[1] + b;
    ctx->state[1] = tmp___0;
    b = tmp___0;
    tmp___1 = ctx->state[2] + c;
    ctx->state[2] = tmp___1;
    c = tmp___1;
    tmp___2 = ctx->state[3] + d;
    ctx->state[3] = tmp___2;
    d = tmp___2;
    tmp___3 = ctx->state[4] + e;
    ctx->state[4] = tmp___3;
    e = tmp___3;
    tmp___4 = ctx->state[5] + f;
    ctx->state[5] = tmp___4;
    f = tmp___4;
    tmp___5 = ctx->state[6] + g;
    ctx->state[6] = tmp___5;
    g = tmp___5;
    tmp___6 = ctx->state[7] + h;
    ctx->state[7] = tmp___6;
    h = tmp___6;
  }
  return;
}
}
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
int sha512_stream(FILE *stream , void *resblock ) ;
int sha384_stream(FILE *stream , void *resblock ) ;
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) ;
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) ;
static unsigned char const   fillbuf___2[128]  = {      (unsigned char const   )128,      (unsigned char const   )0};
void sha512_init_ctx(struct sha512_ctx *ctx ) 
{ u64 tmp ;

  {
  ctx->state[0] = (1779033703UL << 32) + 4089235720UL;
  ctx->state[1] = (3144134277UL << 32) + 2227873595UL;
  ctx->state[2] = (1013904242UL << 32) + 4271175723UL;
  ctx->state[3] = (2773480762UL << 32) + 1595750129UL;
  ctx->state[4] = (1359893119UL << 32) + 2917565137UL;
  ctx->state[5] = (2600822924UL << 32) + 725511199UL;
  ctx->state[6] = (528734635UL << 32) + 4215389547UL;
  ctx->state[7] = (1541459225UL << 32) + 327033209UL;
  tmp = (u64 )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  return;
}
}
void sha384_init_ctx(struct sha512_ctx *ctx ) 
{ u64 tmp ;

  {
  ctx->state[0] = (3418070365UL << 32) + 3238371032UL;
  ctx->state[1] = (1654270250UL << 32) + 914150663UL;
  ctx->state[2] = (2438529370UL << 32) + 812702999UL;
  ctx->state[3] = (355462360UL << 32) + 4144912697UL;
  ctx->state[4] = (1731405415UL << 32) + 4290775857UL;
  ctx->state[5] = (2394180231UL << 32) + 1750603025UL;
  ctx->state[6] = (3675008525UL << 32) + 1694076839UL;
  ctx->state[7] = (1203062813UL << 32) + 3204075428UL;
  tmp = (u64 )0;
  ctx->total[1] = tmp;
  ctx->total[0] = tmp;
  ctx->buflen = (size_t )0;
  return;
}
}
__inline static void set_uint64(char *cp , u64 v ) 
{ 

  {
  memcpy((void * __restrict  )cp, (void const   * __restrict  )(& v), sizeof(v));
  return;
}
}
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
  r = (char *)resbuf;
  i = 0;
  while (i < 8) {
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
    i ++;
  }
  return (resbuf);
}
}
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ int i ;
  char *r ;

  {
  r = (char *)resbuf;
  i = 0;
  while (i < 6) {
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
    i ++;
  }
  return (resbuf);
}
}
static void sha512_conclude_ctx(struct sha512_ctx *ctx ) 
{ size_t bytes ;
  size_t size ;
  int tmp ;

  {
  bytes = ctx->buflen;
  if (bytes < 112UL) {
    tmp = 16;
  } else {
    tmp = 32;
  }
  size = (size_t )tmp;
  ctx->total[0] += bytes;
  if (ctx->total[0] < bytes) {
    (ctx->total[1]) ++;
  }
  set_uint64((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280UL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680UL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080UL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080UL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680UL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280UL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56))));
  set_uint64((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280UL) << 40)) | ((((ctx->total[0] << 3) & 16711680UL) << 24) | (((ctx->total[0] << 3) & 4278190080UL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080UL) | (((ctx->total[0] << 3) >> 24) & 16711680UL)) | ((((ctx->total[0] << 3) >> 40) & 65280UL) | ((ctx->total[0] << 3) >> 56))));
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___2),
         (size - 2UL) * 8UL - bytes);
  sha512_process_block((void const   *)(ctx->buffer), size * 8UL, ctx);
  return;
}
}
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
  sha512_conclude_ctx(ctx);
  tmp = sha512_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
  return (tmp);
}
}
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ void *tmp ;

  {
  sha512_conclude_ctx(ctx);
  tmp = sha384_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
  return (tmp);
}
}
int sha512_stream(FILE *stream , void *resblock ) 
{ struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  if (! buffer) {
    return (1);
  }
  sha512_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
      tmp___0 = tmp___3;
      n = (size_t )tmp___0;
      sum += n;
      if (sum == 32768UL) {
        break;
      }
      if (n == 0UL) {
        tmp___1 = ferror_unlocked(stream);
        if (tmp___1) {
          free((void *)buffer);
          return (1);
        }
        goto process_partial_block;
      }
      tmp___2 = feof_unlocked(stream);
      if (tmp___2) {
        goto process_partial_block;
      }
    }
    sha512_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
  if (sum > 0UL) {
    sha512_process_bytes((void const   *)buffer, sum, & ctx);
  }
  sha512_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  return (0);
}
}
int sha384_stream(FILE *stream , void *resblock ) 
{ struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;

  {
  tmp = malloc((size_t )32840);
  buffer = (char *)tmp;
  if (! buffer) {
    return (1);
  }
  sha384_init_ctx(& ctx);
  while (1) {
    sum = (size_t )0;
    while (1) {
      tmp___3 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )(buffer + sum),
                                                                         (size_t )1,
                                                                         32768UL - sum,
                                                                         (FILE * __restrict  )stream);
      tmp___0 = tmp___3;
      n = (size_t )tmp___0;
      sum += n;
      if (sum == 32768UL) {
        break;
      }
      if (n == 0UL) {
        tmp___1 = ferror_unlocked(stream);
        if (tmp___1) {
          free((void *)buffer);
          return (1);
        }
        goto process_partial_block;
      }
      tmp___2 = feof_unlocked(stream);
      if (tmp___2) {
        goto process_partial_block;
      }
    }
    sha512_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
  if (sum > 0UL) {
    sha512_process_bytes((void const   *)buffer, sum, & ctx);
  }
  sha384_finish_ctx(& ctx, resblock);
  free((void *)buffer);
  return (0);
}
}
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha512_ctx ctx ;
  void *tmp ;

  {
  sha512_init_ctx(& ctx);
  sha512_process_bytes((void const   *)buffer, len, & ctx);
  tmp = sha512_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha512_ctx ctx ;
  void *tmp ;

  {
  sha384_init_ctx(& ctx);
  sha512_process_bytes((void const   *)buffer, len, & ctx);
  tmp = sha384_finish_ctx(& ctx, resblock);
  return (tmp);
}
}
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  size_t tmp ;
  size_t left_over___0 ;

  {
  if (ctx->buflen != 0UL) {
    left_over = ctx->buflen;
    if (256UL - left_over > len) {
      tmp = len;
    } else {
      tmp = 256UL - left_over;
    }
    add = tmp;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
    ctx->buflen += add;
    if (ctx->buflen > 128UL) {
      sha512_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffff80UL,
                           ctx);
      ctx->buflen &= 127UL;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffff80UL)),
             ctx->buflen);
    }
    buffer = (void const   *)((char const   *)buffer + add);
    len -= add;
  }
  if (len >= 128UL) {
    sha512_process_block(buffer, len & 0xffffffffffffff80UL, ctx);
    buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffff80UL));
    len &= 127UL;
  }
  if (len > 0UL) {
    left_over___0 = ctx->buflen;
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
    left_over___0 += len;
    if (left_over___0 >= 128UL) {
      sha512_process_block((void const   *)(ctx->buffer), (size_t )128, ctx);
      left_over___0 -= 128UL;
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
    ctx->buflen = left_over___0;
  }
  return;
}
}
static u64 const   sha512_round_constants[80]  = 
  {      (u64 const   )((1116352408UL << 32) + 3609767458UL),      (u64 const   )((1899447441UL << 32) + 602891725UL),      (u64 const   )((3049323471UL << 32) + 3964484399UL),      (u64 const   )((3921009573UL << 32) + 2173295548UL), 
        (u64 const   )((961987163UL << 32) + 4081628472UL),      (u64 const   )((1508970993UL << 32) + 3053834265UL),      (u64 const   )((2453635748UL << 32) + 2937671579UL),      (u64 const   )((2870763221UL << 32) + 3664609560UL), 
        (u64 const   )((3624381080UL << 32) + 2734883394UL),      (u64 const   )((310598401UL << 32) + 1164996542UL),      (u64 const   )((607225278UL << 32) + 1323610764UL),      (u64 const   )((1426881987UL << 32) + 3590304994UL), 
        (u64 const   )((1925078388UL << 32) + 4068182383UL),      (u64 const   )((2162078206UL << 32) + 991336113UL),      (u64 const   )((2614888103UL << 32) + 633803317UL),      (u64 const   )((3248222580UL << 32) + 3479774868UL), 
        (u64 const   )((3835390401UL << 32) + 2666613458UL),      (u64 const   )((4022224774UL << 32) + 944711139UL),      (u64 const   )((264347078UL << 32) + 2341262773UL),      (u64 const   )((604807628UL << 32) + 2007800933UL), 
        (u64 const   )((770255983UL << 32) + 1495990901UL),      (u64 const   )((1249150122UL << 32) + 1856431235UL),      (u64 const   )((1555081692UL << 32) + 3175218132UL),      (u64 const   )((1996064986UL << 32) + 2198950837UL), 
        (u64 const   )((2554220882UL << 32) + 3999719339UL),      (u64 const   )((2821834349UL << 32) + 766784016UL),      (u64 const   )((2952996808UL << 32) + 2566594879UL),      (u64 const   )((3210313671UL << 32) + 3203337956UL), 
        (u64 const   )((3336571891UL << 32) + 1034457026UL),      (u64 const   )((3584528711UL << 32) + 2466948901UL),      (u64 const   )((113926993UL << 32) + 3758326383UL),      (u64 const   )((338241895UL << 32) + 168717936UL), 
        (u64 const   )((666307205UL << 32) + 1188179964UL),      (u64 const   )((773529912UL << 32) + 1546045734UL),      (u64 const   )((1294757372UL << 32) + 1522805485UL),      (u64 const   )((1396182291UL << 32) + 2643833823UL), 
        (u64 const   )((1695183700UL << 32) + 2343527390UL),      (u64 const   )((1986661051UL << 32) + 1014477480UL),      (u64 const   )((2177026350UL << 32) + 1206759142UL),      (u64 const   )((2456956037UL << 32) + 344077627UL), 
        (u64 const   )((2730485921UL << 32) + 1290863460UL),      (u64 const   )((2820302411UL << 32) + 3158454273UL),      (u64 const   )((3259730800UL << 32) + 3505952657UL),      (u64 const   )((3345764771UL << 32) + 106217008UL), 
        (u64 const   )((3516065817UL << 32) + 3606008344UL),      (u64 const   )((3600352804UL << 32) + 1432725776UL),      (u64 const   )((4094571909UL << 32) + 1467031594UL),      (u64 const   )((275423344UL << 32) + 851169720UL), 
        (u64 const   )((430227734UL << 32) + 3100823752UL),      (u64 const   )((506948616UL << 32) + 1363258195UL),      (u64 const   )((659060556UL << 32) + 3750685593UL),      (u64 const   )((883997877UL << 32) + 3785050280UL), 
        (u64 const   )((958139571UL << 32) + 3318307427UL),      (u64 const   )((1322822218UL << 32) + 3812723403UL),      (u64 const   )((1537002063UL << 32) + 2003034995UL),      (u64 const   )((1747873779UL << 32) + 3602036899UL), 
        (u64 const   )((1955562222UL << 32) + 1575990012UL),      (u64 const   )((2024104815UL << 32) + 1125592928UL),      (u64 const   )((2227730452UL << 32) + 2716904306UL),      (u64 const   )((2361852424UL << 32) + 442776044UL), 
        (u64 const   )((2428436474UL << 32) + 593698344UL),      (u64 const   )((2756734187UL << 32) + 3733110249UL),      (u64 const   )((3204031479UL << 32) + 2999351573UL),      (u64 const   )((3329325298UL << 32) + 3815920427UL), 
        (u64 const   )((3391569614UL << 32) + 3928383900UL),      (u64 const   )((3515267271UL << 32) + 566280711UL),      (u64 const   )((3940187606UL << 32) + 3454069534UL),      (u64 const   )((4118630271UL << 32) + 4000239992UL), 
        (u64 const   )((116418474UL << 32) + 1914138554UL),      (u64 const   )((174292421UL << 32) + 2731055270UL),      (u64 const   )((289380356UL << 32) + 3203993006UL),      (u64 const   )((460393269UL << 32) + 320620315UL), 
        (u64 const   )((685471733UL << 32) + 587496836UL),      (u64 const   )((852142971UL << 32) + 1086792851UL),      (u64 const   )((1017036298UL << 32) + 365543100UL),      (u64 const   )((1126000580UL << 32) + 2618297676UL), 
        (u64 const   )((1288033470UL << 32) + 3409855158UL),      (u64 const   )((1501505948UL << 32) + 4234509866UL),      (u64 const   )((1607167915UL << 32) + 987167468UL),      (u64 const   )((1816402316UL << 32) + 1246189591UL)};
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ u64 const   *words ;
  u64 const   *endp ;
  u64 x[16] ;
  u64 a ;
  u64 b ;
  u64 c ;
  u64 d ;
  u64 e ;
  u64 f ;
  u64 g ;
  u64 h ;
  int t ;
  u64 t0 ;
  u64 t1 ;
  u64 t0___0 ;
  u64 t1___0 ;
  u64 t0___1 ;
  u64 t1___1 ;
  u64 t0___2 ;
  u64 t1___2 ;
  u64 t0___3 ;
  u64 t1___3 ;
  u64 t0___4 ;
  u64 t1___4 ;
  u64 t0___5 ;
  u64 t1___5 ;
  u64 t0___6 ;
  u64 t1___6 ;
  u64 t0___7 ;
  u64 t1___7 ;
  u64 t0___8 ;
  u64 t1___8 ;
  u64 t0___9 ;
  u64 t1___9 ;
  u64 t0___10 ;
  u64 t1___10 ;
  u64 t0___11 ;
  u64 t1___11 ;
  u64 t0___12 ;
  u64 t1___12 ;
  u64 t0___13 ;
  u64 t1___13 ;
  u64 t0___14 ;
  u64 t1___14 ;
  u64 t0___15 ;
  u64 t1___15 ;
  u64 t0___16 ;
  u64 t1___16 ;
  u64 t0___17 ;
  u64 t1___17 ;
  u64 t0___18 ;
  u64 t1___18 ;
  u64 t0___19 ;
  u64 t1___19 ;
  u64 t0___20 ;
  u64 t1___20 ;
  u64 t0___21 ;
  u64 t1___21 ;
  u64 t0___22 ;
  u64 t1___22 ;
  u64 t0___23 ;
  u64 t1___23 ;
  u64 t0___24 ;
  u64 t1___24 ;
  u64 t0___25 ;
  u64 t1___25 ;
  u64 t0___26 ;
  u64 t1___26 ;
  u64 t0___27 ;
  u64 t1___27 ;
  u64 t0___28 ;
  u64 t1___28 ;
  u64 t0___29 ;
  u64 t1___29 ;
  u64 t0___30 ;
  u64 t1___30 ;
  u64 t0___31 ;
  u64 t1___31 ;
  u64 t0___32 ;
  u64 t1___32 ;
  u64 t0___33 ;
  u64 t1___33 ;
  u64 t0___34 ;
  u64 t1___34 ;
  u64 t0___35 ;
  u64 t1___35 ;
  u64 t0___36 ;
  u64 t1___36 ;
  u64 t0___37 ;
  u64 t1___37 ;
  u64 t0___38 ;
  u64 t1___38 ;
  u64 t0___39 ;
  u64 t1___39 ;
  u64 t0___40 ;
  u64 t1___40 ;
  u64 t0___41 ;
  u64 t1___41 ;
  u64 t0___42 ;
  u64 t1___42 ;
  u64 t0___43 ;
  u64 t1___43 ;
  u64 t0___44 ;
  u64 t1___44 ;
  u64 t0___45 ;
  u64 t1___45 ;
  u64 t0___46 ;
  u64 t1___46 ;
  u64 t0___47 ;
  u64 t1___47 ;
  u64 t0___48 ;
  u64 t1___48 ;
  u64 t0___49 ;
  u64 t1___49 ;
  u64 t0___50 ;
  u64 t1___50 ;
  u64 t0___51 ;
  u64 t1___51 ;
  u64 t0___52 ;
  u64 t1___52 ;
  u64 t0___53 ;
  u64 t1___53 ;
  u64 t0___54 ;
  u64 t1___54 ;
  u64 t0___55 ;
  u64 t1___55 ;
  u64 t0___56 ;
  u64 t1___56 ;
  u64 t0___57 ;
  u64 t1___57 ;
  u64 t0___58 ;
  u64 t1___58 ;
  u64 t0___59 ;
  u64 t1___59 ;
  u64 t0___60 ;
  u64 t1___60 ;
  u64 t0___61 ;
  u64 t1___61 ;
  u64 t0___62 ;
  u64 t1___62 ;
  u64 t0___63 ;
  u64 t1___63 ;
  u64 t0___64 ;
  u64 t1___64 ;
  u64 t0___65 ;
  u64 t1___65 ;
  u64 t0___66 ;
  u64 t1___66 ;
  u64 t0___67 ;
  u64 t1___67 ;
  u64 t0___68 ;
  u64 t1___68 ;
  u64 t0___69 ;
  u64 t1___69 ;
  u64 t0___70 ;
  u64 t1___70 ;
  u64 t0___71 ;
  u64 t1___71 ;
  u64 t0___72 ;
  u64 t1___72 ;
  u64 t0___73 ;
  u64 t1___73 ;
  u64 t0___74 ;
  u64 t1___74 ;
  u64 t0___75 ;
  u64 t1___75 ;
  u64 t0___76 ;
  u64 t1___76 ;
  u64 t0___77 ;
  u64 t1___77 ;
  u64 t0___78 ;
  u64 t1___78 ;
  u64 tmp ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  u64 tmp___4 ;
  u64 tmp___5 ;
  u64 tmp___6 ;

  {
  words = (u64 const   *)buffer;
  endp = words + len / sizeof(u64 );
  a = ctx->state[0];
  b = ctx->state[1];
  c = ctx->state[2];
  d = ctx->state[3];
  e = ctx->state[4];
  f = ctx->state[5];
  g = ctx->state[6];
  h = ctx->state[7];
  ctx->total[0] += len;
  if (ctx->total[0] < len) {
    (ctx->total[1]) ++;
  }
  while ((unsigned long )words < (unsigned long )endp) {
    t = 0;
    while (t < 16) {
      x[t] = (u64 )((((*words << 56) | ((*words & 65280UL) << 40)) | (((*words & 16711680UL) << 24) | ((*words & 4278190080UL) << 8))) | ((((*words >> 8) & 4278190080UL) | ((*words >> 24) & 16711680UL)) | (((*words >> 40) & 65280UL) | (*words >> 56))));
      words ++;
      t ++;
    }
    while (1) {
      t0 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      t1 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[0] + (u64 const   )x[0])));
      d += t1;
      h = t0 + t1;
      break;
    }
    while (1) {
      t0___0 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      t1___0 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[1] + (u64 const   )x[1])));
      c += t1___0;
      g = t0___0 + t1___0;
      break;
    }
    while (1) {
      t0___1 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      t1___1 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[2] + (u64 const   )x[2])));
      b += t1___1;
      f = t0___1 + t1___1;
      break;
    }
    while (1) {
      t0___2 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      t1___2 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[3] + (u64 const   )x[3])));
      a += t1___2;
      e = t0___2 + t1___2;
      break;
    }
    while (1) {
      t0___3 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      t1___3 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[4] + (u64 const   )x[4])));
      h += t1___3;
      d = t0___3 + t1___3;
      break;
    }
    while (1) {
      t0___4 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      t1___4 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[5] + (u64 const   )x[5])));
      g += t1___4;
      c = t0___4 + t1___4;
      break;
    }
    while (1) {
      t0___5 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      t1___5 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[6] + (u64 const   )x[6])));
      f += t1___5;
      b = t0___5 + t1___5;
      break;
    }
    while (1) {
      t0___6 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      t1___6 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[7] + (u64 const   )x[7])));
      e += t1___6;
      a = t0___6 + t1___6;
      break;
    }
    while (1) {
      t0___7 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      t1___7 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[8] + (u64 const   )x[8])));
      d += t1___7;
      h = t0___7 + t1___7;
      break;
    }
    while (1) {
      t0___8 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      t1___8 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[9] + (u64 const   )x[9])));
      c += t1___8;
      g = t0___8 + t1___8;
      break;
    }
    while (1) {
      t0___9 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      t1___9 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[10] + (u64 const   )x[10])));
      b += t1___9;
      f = t0___9 + t1___9;
      break;
    }
    while (1) {
      t0___10 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      t1___10 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[11] + (u64 const   )x[11])));
      a += t1___10;
      e = t0___10 + t1___10;
      break;
    }
    while (1) {
      t0___11 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      t1___11 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[12] + (u64 const   )x[12])));
      h += t1___11;
      d = t0___11 + t1___11;
      break;
    }
    while (1) {
      t0___12 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      t1___12 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[13] + (u64 const   )x[13])));
      g += t1___12;
      c = t0___12 + t1___12;
      break;
    }
    while (1) {
      t0___13 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      t1___13 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[14] + (u64 const   )x[14])));
      f += t1___13;
      b = t0___13 + t1___13;
      break;
    }
    while (1) {
      t0___14 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      t1___14 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[15] + (u64 const   )x[15])));
      e += t1___14;
      a = t0___14 + t1___14;
      break;
    }
    while (1) {
      t0___15 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___15 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[16] + (u64 const   )x[0])));
      d += t1___15;
      h = t0___15 + t1___15;
      break;
    }
    while (1) {
      t0___16 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___16 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[17] + (u64 const   )x[1])));
      c += t1___16;
      g = t0___16 + t1___16;
      break;
    }
    while (1) {
      t0___17 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___17 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[18] + (u64 const   )x[2])));
      b += t1___17;
      f = t0___17 + t1___17;
      break;
    }
    while (1) {
      t0___18 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___18 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[19] + (u64 const   )x[3])));
      a += t1___18;
      e = t0___18 + t1___18;
      break;
    }
    while (1) {
      t0___19 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___19 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[20] + (u64 const   )x[4])));
      h += t1___19;
      d = t0___19 + t1___19;
      break;
    }
    while (1) {
      t0___20 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___20 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[21] + (u64 const   )x[5])));
      g += t1___20;
      c = t0___20 + t1___20;
      break;
    }
    while (1) {
      t0___21 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___21 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[22] + (u64 const   )x[6])));
      f += t1___21;
      b = t0___21 + t1___21;
      break;
    }
    while (1) {
      t0___22 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___22 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[23] + (u64 const   )x[7])));
      e += t1___22;
      a = t0___22 + t1___22;
      break;
    }
    while (1) {
      t0___23 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___23 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[24] + (u64 const   )x[8])));
      d += t1___23;
      h = t0___23 + t1___23;
      break;
    }
    while (1) {
      t0___24 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___24 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[25] + (u64 const   )x[9])));
      c += t1___24;
      g = t0___24 + t1___24;
      break;
    }
    while (1) {
      t0___25 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___25 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[26] + (u64 const   )x[10])));
      b += t1___25;
      f = t0___25 + t1___25;
      break;
    }
    while (1) {
      t0___26 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___26 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[27] + (u64 const   )x[11])));
      a += t1___26;
      e = t0___26 + t1___26;
      break;
    }
    while (1) {
      t0___27 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___27 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[28] + (u64 const   )x[12])));
      h += t1___27;
      d = t0___27 + t1___27;
      break;
    }
    while (1) {
      t0___28 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___28 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[29] + (u64 const   )x[13])));
      g += t1___28;
      c = t0___28 + t1___28;
      break;
    }
    while (1) {
      t0___29 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___29 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[30] + (u64 const   )x[14])));
      f += t1___29;
      b = t0___29 + t1___29;
      break;
    }
    while (1) {
      t0___30 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___30 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[31] + (u64 const   )x[15])));
      e += t1___30;
      a = t0___30 + t1___30;
      break;
    }
    while (1) {
      t0___31 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___31 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[32] + (u64 const   )x[0])));
      d += t1___31;
      h = t0___31 + t1___31;
      break;
    }
    while (1) {
      t0___32 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___32 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[33] + (u64 const   )x[1])));
      c += t1___32;
      g = t0___32 + t1___32;
      break;
    }
    while (1) {
      t0___33 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___33 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[34] + (u64 const   )x[2])));
      b += t1___33;
      f = t0___33 + t1___33;
      break;
    }
    while (1) {
      t0___34 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___34 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[35] + (u64 const   )x[3])));
      a += t1___34;
      e = t0___34 + t1___34;
      break;
    }
    while (1) {
      t0___35 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___35 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[36] + (u64 const   )x[4])));
      h += t1___35;
      d = t0___35 + t1___35;
      break;
    }
    while (1) {
      t0___36 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___36 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[37] + (u64 const   )x[5])));
      g += t1___36;
      c = t0___36 + t1___36;
      break;
    }
    while (1) {
      t0___37 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___37 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[38] + (u64 const   )x[6])));
      f += t1___37;
      b = t0___37 + t1___37;
      break;
    }
    while (1) {
      t0___38 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___38 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[39] + (u64 const   )x[7])));
      e += t1___38;
      a = t0___38 + t1___38;
      break;
    }
    while (1) {
      t0___39 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___39 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[40] + (u64 const   )x[8])));
      d += t1___39;
      h = t0___39 + t1___39;
      break;
    }
    while (1) {
      t0___40 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___40 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[41] + (u64 const   )x[9])));
      c += t1___40;
      g = t0___40 + t1___40;
      break;
    }
    while (1) {
      t0___41 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___41 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[42] + (u64 const   )x[10])));
      b += t1___41;
      f = t0___41 + t1___41;
      break;
    }
    while (1) {
      t0___42 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___42 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[43] + (u64 const   )x[11])));
      a += t1___42;
      e = t0___42 + t1___42;
      break;
    }
    while (1) {
      t0___43 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___43 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[44] + (u64 const   )x[12])));
      h += t1___43;
      d = t0___43 + t1___43;
      break;
    }
    while (1) {
      t0___44 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___44 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[45] + (u64 const   )x[13])));
      g += t1___44;
      c = t0___44 + t1___44;
      break;
    }
    while (1) {
      t0___45 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___45 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[46] + (u64 const   )x[14])));
      f += t1___45;
      b = t0___45 + t1___45;
      break;
    }
    while (1) {
      t0___46 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___46 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[47] + (u64 const   )x[15])));
      e += t1___46;
      a = t0___46 + t1___46;
      break;
    }
    while (1) {
      t0___47 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___47 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[48] + (u64 const   )x[0])));
      d += t1___47;
      h = t0___47 + t1___47;
      break;
    }
    while (1) {
      t0___48 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___48 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[49] + (u64 const   )x[1])));
      c += t1___48;
      g = t0___48 + t1___48;
      break;
    }
    while (1) {
      t0___49 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___49 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[50] + (u64 const   )x[2])));
      b += t1___49;
      f = t0___49 + t1___49;
      break;
    }
    while (1) {
      t0___50 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___50 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[51] + (u64 const   )x[3])));
      a += t1___50;
      e = t0___50 + t1___50;
      break;
    }
    while (1) {
      t0___51 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___51 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[52] + (u64 const   )x[4])));
      h += t1___51;
      d = t0___51 + t1___51;
      break;
    }
    while (1) {
      t0___52 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___52 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[53] + (u64 const   )x[5])));
      g += t1___52;
      c = t0___52 + t1___52;
      break;
    }
    while (1) {
      t0___53 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___53 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[54] + (u64 const   )x[6])));
      f += t1___53;
      b = t0___53 + t1___53;
      break;
    }
    while (1) {
      t0___54 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___54 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[55] + (u64 const   )x[7])));
      e += t1___54;
      a = t0___54 + t1___54;
      break;
    }
    while (1) {
      t0___55 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___55 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[56] + (u64 const   )x[8])));
      d += t1___55;
      h = t0___55 + t1___55;
      break;
    }
    while (1) {
      t0___56 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___56 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[57] + (u64 const   )x[9])));
      c += t1___56;
      g = t0___56 + t1___56;
      break;
    }
    while (1) {
      t0___57 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___57 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[58] + (u64 const   )x[10])));
      b += t1___57;
      f = t0___57 + t1___57;
      break;
    }
    while (1) {
      t0___58 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___58 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[59] + (u64 const   )x[11])));
      a += t1___58;
      e = t0___58 + t1___58;
      break;
    }
    while (1) {
      t0___59 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___59 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[60] + (u64 const   )x[12])));
      h += t1___59;
      d = t0___59 + t1___59;
      break;
    }
    while (1) {
      t0___60 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___60 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[61] + (u64 const   )x[13])));
      g += t1___60;
      c = t0___60 + t1___60;
      break;
    }
    while (1) {
      t0___61 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___61 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[62] + (u64 const   )x[14])));
      f += t1___61;
      b = t0___61 + t1___61;
      break;
    }
    while (1) {
      t0___62 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___62 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[63] + (u64 const   )x[15])));
      e += t1___62;
      a = t0___62 + t1___62;
      break;
    }
    while (1) {
      t0___63 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
      t1___63 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[64] + (u64 const   )x[0])));
      d += t1___63;
      h = t0___63 + t1___63;
      break;
    }
    while (1) {
      t0___64 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
      t1___64 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[65] + (u64 const   )x[1])));
      c += t1___64;
      g = t0___64 + t1___64;
      break;
    }
    while (1) {
      t0___65 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
      t1___65 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[66] + (u64 const   )x[2])));
      b += t1___65;
      f = t0___65 + t1___65;
      break;
    }
    while (1) {
      t0___66 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
      t1___66 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[67] + (u64 const   )x[3])));
      a += t1___66;
      e = t0___66 + t1___66;
      break;
    }
    while (1) {
      t0___67 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
      t1___67 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[68] + (u64 const   )x[4])));
      h += t1___67;
      d = t0___67 + t1___67;
      break;
    }
    while (1) {
      t0___68 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
      t1___68 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[69] + (u64 const   )x[5])));
      g += t1___68;
      c = t0___68 + t1___68;
      break;
    }
    while (1) {
      t0___69 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
      t1___69 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[70] + (u64 const   )x[6])));
      f += t1___69;
      b = t0___69 + t1___69;
      break;
    }
    while (1) {
      t0___70 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
      t1___70 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[71] + (u64 const   )x[7])));
      e += t1___70;
      a = t0___70 + t1___70;
      break;
    }
    while (1) {
      t0___71 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
      t1___71 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[72] + (u64 const   )x[8])));
      d += t1___71;
      h = t0___71 + t1___71;
      break;
    }
    while (1) {
      t0___72 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
      t1___72 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[73] + (u64 const   )x[9])));
      c += t1___72;
      g = t0___72 + t1___72;
      break;
    }
    while (1) {
      t0___73 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
      t1___73 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[74] + (u64 const   )x[10])));
      b += t1___73;
      f = t0___73 + t1___73;
      break;
    }
    while (1) {
      t0___74 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
      t1___74 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[75] + (u64 const   )x[11])));
      a += t1___74;
      e = t0___74 + t1___74;
      break;
    }
    while (1) {
      t0___75 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
      t1___75 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[76] + (u64 const   )x[12])));
      h += t1___75;
      d = t0___75 + t1___75;
      break;
    }
    while (1) {
      t0___76 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
      t1___76 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[77] + (u64 const   )x[13])));
      g += t1___76;
      c = t0___76 + t1___76;
      break;
    }
    while (1) {
      t0___77 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
      t1___77 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[78] + (u64 const   )x[14])));
      f += t1___77;
      b = t0___77 + t1___77;
      break;
    }
    while (1) {
      t0___78 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
      t1___78 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[79] + (u64 const   )x[15])));
      e += t1___78;
      a = t0___78 + t1___78;
      break;
    }
    tmp = ctx->state[0] + a;
    ctx->state[0] = tmp;
    a = tmp;
    tmp___0 = ctx->state[1] + b;
    ctx->state[1] = tmp___0;
    b = tmp___0;
    tmp___1 = ctx->state[2] + c;
    ctx->state[2] = tmp___1;
    c = tmp___1;
    tmp___2 = ctx->state[3] + d;
    ctx->state[3] = tmp___2;
    d = tmp___2;
    tmp___3 = ctx->state[4] + e;
    ctx->state[4] = tmp___3;
    e = tmp___3;
    tmp___4 = ctx->state[5] + f;
    ctx->state[5] = tmp___4;
    f = tmp___4;
    tmp___5 = ctx->state[6] + g;
    ctx->state[6] = tmp___5;
    g = tmp___5;
    tmp___6 = ctx->state[7] + h;
    ctx->state[7] = tmp___6;
    h = tmp___6;
  }
  return;
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
void cycle_check_init(struct cycle_check_state *state ) ;
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
__inline static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 

  {
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
void cycle_check_init(struct cycle_check_state *state ) 
{ 

  {
  state->chdir_counter = (uintmax_t )0;
  state->magic = 9827862;
  return;
}
}
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ _Bool tmp ;

  {
  if (! (state->magic == 9827862)) {
    __assert_fail("state->magic == 9827862", "cycle-check.c", 60U, "cycle_check");
  }
  if (state->chdir_counter) {
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
        return ((_Bool)1);
      }
    }
  }
  (state->chdir_counter) ++;
  tmp = is_zero_or_power_of_two(state->chdir_counter);
  if (tmp) {
    if (state->chdir_counter == 0UL) {
      return ((_Bool)1);
    }
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
  return ((_Bool)0);
}
}
struct di_set *di_set_alloc(void) ;
int di_set_insert(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
void di_set_free(struct di_set *dis )  __attribute__((__nonnull__(1))) ;
int di_set_lookup(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
void *hash_lookup(Hash_table const   *table___1 , void const   *entry ) ;
void *hash_insert(Hash_table *table___1 , void const   *entry )  __attribute__((__warn_unused_result__)) ;
int hash_insert0(Hash_table *table___1 , void const   *entry , void const   **matched_ent ) ;
struct ino_map *ino_map_alloc(size_t next_mapped_ino ) ;
size_t ino_map_insert(struct ino_map *im , ino_t ino )  __attribute__((__nonnull__(1))) ;
static size_t di_ent_hash(void const   *x , size_t table_size ) 
{ struct di_ent  const  *p ;
  dev_t dev ;
  size_t h ;
  unsigned int i ;
  unsigned int n_words ;

  {
  p = (struct di_ent  const  *)x;
  dev = (dev_t )p->dev;
  h = dev;
  n_words = (unsigned int )(sizeof(dev) / sizeof(h) + (unsigned long )(sizeof(dev) % sizeof(h) != 0UL));
  i = 1U;
  while (i < n_words) {
    h ^= dev >> (8UL * sizeof(h)) * (unsigned long )i;
    i ++;
  }
  return (h % table_size);
}
}
static _Bool di_ent_compare(void const   *x , void const   *y ) 
{ struct di_ent  const  *a ;
  struct di_ent  const  *b ;

  {
  a = (struct di_ent  const  *)x;
  b = (struct di_ent  const  *)y;
  return ((_Bool )(a->dev == b->dev));
}
}
static void di_ent_free(void *v ) 
{ struct di_ent *a ;

  {
  a = (struct di_ent *)v;
  hash_free(a->ino_set);
  free((void *)a);
  return;
}
}
struct di_set *di_set_alloc(void) 
{ struct di_set *dis ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*dis));
  dis = (struct di_set *)tmp;
  if (dis) {
    dis->dev_map = hash_initialize((size_t )11, (Hash_tuning const   *)((void *)0),
                                   & di_ent_hash, & di_ent_compare, & di_ent_free);
    if (! dis->dev_map) {
      free((void *)dis);
      return ((struct di_set *)((void *)0));
    }
    dis->ino_map = (struct ino_map *)((void *)0);
    dis->probe = (struct di_ent *)((void *)0);
  }
  return (dis);
}
}
void di_set_free(struct di_set *dis )  __attribute__((__nonnull__(1))) ;
void di_set_free(struct di_set *dis ) 
{ 

  {
  hash_free(dis->dev_map);
  free((void *)dis->ino_map);
  free((void *)dis->probe);
  free((void *)dis);
  return;
}
}
static size_t di_ino_hash(void const   *i , size_t table_size ) 
{ 

  {
  return ((hashint )i % table_size);
}
}
static struct hash_table *map_device(struct di_set *dis , dev_t dev ) 
{ struct di_ent *ent ;
  struct di_ent *probe ;
  void *tmp ;
  void *tmp___0 ;

  {
  probe = dis->probe;
  if (probe) {
    if (probe->dev == dev) {
      return (probe->ino_set);
    }
  } else {
    tmp = malloc(sizeof(*probe));
    probe = (struct di_ent *)tmp;
    dis->probe = probe;
    if (! probe) {
      return ((struct hash_table *)((void *)0));
    }
  }
  probe->dev = dev;
  tmp___0 = hash_insert(dis->dev_map, (void const   *)probe);
  ent = (struct di_ent *)tmp___0;
  if (! ent) {
    return ((struct hash_table *)((void *)0));
  }
  if ((unsigned long )ent != (unsigned long )probe) {
    probe->ino_set = ent->ino_set;
  } else {
    dis->probe = (struct di_ent *)((void *)0);
    probe->ino_set = hash_initialize((size_t )1021, (Hash_tuning const   *)((void *)0),
                                     & di_ino_hash, (_Bool (*)(void const   * , void const   * ))((void *)0),
                                     (void (*)(void * ))((void *)0));
  }
  return (probe->ino_set);
}
}
static hashint map_inode_number(struct di_set *dis , ino_t ino ) 
{ size_t tmp ;

  {
  if (0UL < ino) {
    if (ino < 9223372036854775807UL) {
      return (ino);
    }
  }
  if (! dis->ino_map) {
    dis->ino_map = ino_map_alloc(9223372036854775807UL);
    if (! dis->ino_map) {
      return ((size_t )-1);
    }
  }
  tmp = ino_map_insert(dis->ino_map, ino);
  return (tmp);
}
}
int di_set_insert(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
int di_set_insert(struct di_set *dis , dev_t dev , ino_t ino ) 
{ hashint i ;
  struct hash_table *ino_set ;
  struct hash_table *tmp ;
  int tmp___0 ;

  {
  tmp = map_device(dis, dev);
  ino_set = tmp;
  if (! ino_set) {
    return (-1);
  }
  i = map_inode_number(dis, ino);
  if (i == 0xffffffffffffffffUL) {
    return (-1);
  }
  tmp___0 = hash_insert0(ino_set, (void const   *)i, (void const   **)((void *)0));
  return (tmp___0);
}
}
int di_set_lookup(struct di_set *dis , dev_t dev , ino_t ino )  __attribute__((__nonnull__(1))) ;
int di_set_lookup(struct di_set *dis , dev_t dev , ino_t ino ) 
{ hashint i ;
  struct hash_table *ino_set ;
  struct hash_table *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = map_device(dis, dev);
  ino_set = tmp;
  if (! ino_set) {
    return (-1);
  }
  i = map_inode_number(dis, ino);
  if (i == 0xffffffffffffffffUL) {
    return (-1);
  }
  tmp___0 = hash_lookup((Hash_table const   *)ino_set, (void const   *)i);
  if (tmp___0) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
char const   diacrit_base[256] ;
char const   diacrit_diac[256] ;
char const   diacrit_base[256]  = 
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'A', 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'C', 
        (char const   )'E',      (char const   )'E',      (char const   )'E',      (char const   )'E', 
        (char const   )'I',      (char const   )'I',      (char const   )'I',      (char const   )'I', 
        (char const   )0,      (char const   )'N',      (char const   )'O',      (char const   )'O', 
        (char const   )'O',      (char const   )'O',      (char const   )'O',      (char const   )0, 
        (char const   )'O',      (char const   )'U',      (char const   )'U',      (char const   )'U', 
        (char const   )'U',      (char const   )'Y',      (char const   )0,      (char const   )0, 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'a', 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'e',      (char const   )'e',      (char const   )'e', 
        (char const   )'i',      (char const   )'i',      (char const   )'i',      (char const   )'i', 
        (char const   )0,      (char const   )'n',      (char const   )'o',      (char const   )'o', 
        (char const   )'o',      (char const   )'o',      (char const   )'o',      (char const   )0, 
        (char const   )'o',      (char const   )'u',      (char const   )'u',      (char const   )'u', 
        (char const   )'u',      (char const   )'y',      (char const   )0,      (char const   )'y'};
char const   diacrit_diac[256]  = 
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )4,      (char const   )0, 
        (char const   )3,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )6,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0};
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern DIR *fdopendir(int __fd ) ;
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern int close(int __fd ) ;
int dup_safer(int fd ) ;
DIR *opendir_safer(char const   *name ) 
{ DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  tmp = opendir(name);
  dp = tmp;
  if (dp) {
    tmp___0 = dirfd(dp);
    fd = tmp___0;
    if (0 <= fd) {
      if (fd <= 2) {
        tmp___1 = dup_safer(fd);
        f = tmp___1;
        if (f < 0) {
          tmp___2 = __errno_location();
          e = *tmp___2;
          newdp = (DIR *)((void *)0);
        } else {
          newdp = fdopendir(f);
          tmp___3 = __errno_location();
          e = *tmp___3;
          if (! newdp) {
            close(f);
          }
        }
        closedir(dp);
        tmp___4 = __errno_location();
        *tmp___4 = e;
        dp = newdp;
      }
    }
  }
  return (dp);
}
}
char *dir_name(char const   *file ) ;
char *mdir_name(char const   *file ) ;
char *dir_name(char const   *file ) 
{ char *result ;
  char *tmp ;

  {
  tmp = mdir_name(file);
  result = tmp;
  if (! result) {
    xalloc_die();
  }
  return (result);
}
}
char *base_name(char const   *name ) ;
char *xstrndup(char const   *string , size_t n ) ;
char *base_name(char const   *name ) 
{ char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  tmp = last_component(name);
  base = (char const   *)tmp;
  if (! *base) {
    tmp___0 = base_len(name);
    tmp___1 = xstrndup(name, tmp___0);
    return (tmp___1);
  }
  length = base_len(base);
  if ((int const   )*(base + length) == 47) {
    length ++;
  }
  tmp___3 = xstrndup(base, length);
  return (tmp___3);
}
}
size_t dir_len(char const   *file ) ;
size_t dir_len(char const   *file ) 
{ size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  prefix_length = (size_t )0;
  if (prefix_length != 0UL) {
    tmp___0 = 0;
  } else {
    if ((int const   )*(file + 0) == 47) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  prefix_length += (size_t )tmp___0;
  tmp___1 = last_component(file);
  length = (size_t )(tmp___1 - (char *)file);
  while (prefix_length < length) {
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
      break;
    }
    length --;
  }
  return (length);
}
}
char *mdir_name(char const   *file ) 
{ size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = dir_len(file);
  length = tmp;
  if (length == 0UL) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  append_dot = (_Bool )tmp___0;
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
  dir = (char *)tmp___1;
  if (! dir) {
    return ((char *)((void *)0));
  }
  memcpy((void * __restrict  )dir, (void const   * __restrict  )file, length);
  if (append_dot) {
    tmp___2 = length;
    length ++;
    *(dir + tmp___2) = (char )'.';
  }
  *(dir + length) = (char )'\000';
  return (dir);
}
}
char *last_component(char const   *name ) 
{ char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
  base = name + 0;
  saw_slash = (_Bool)0;
  while ((int const   )*base == 47) {
    base ++;
  }
  p = base;
  while (*p) {
    if ((int const   )*p == 47) {
      saw_slash = (_Bool)1;
    } else
    if (saw_slash) {
      base = p;
      saw_slash = (_Bool)0;
    }
    p ++;
  }
  return ((char *)base);
}
}
size_t base_len(char const   *name ) 
{ size_t len ;
  size_t prefix_len ;

  {
  prefix_len = (size_t )0;
  len = strlen(name);
  while (1) {
    if (1UL < len) {
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
        break;
      }
    } else {
      break;
    }
    goto __Cont;
    __Cont: 
    len --;
  }
  return (len);
}
}
_Bool strip_trailing_slashes(char *file ) ;
_Bool strip_trailing_slashes(char *file ) 
{ char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  tmp = last_component((char const   *)file);
  base = tmp;
  if (! *base) {
    base = file;
  }
  tmp___0 = base_len((char const   *)base);
  base_lim = base + tmp___0;
  had_slash = (_Bool )((int )*base_lim != 0);
  *base_lim = (char )'\000';
  return (had_slash);
}
}
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x ) ;
int dtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , double x ) 
{ char format[sizeof("%-+ 0*.*Lg")] ;
  double abs_x ;
  double tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int __attribute__((__artificial__))  tmp___5 ;
  double tmp___6 ;

  {
  if (x < (double )0) {
    tmp = - x;
  } else {
    tmp = x;
  }
  abs_x = tmp;
  p = format;
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )'%';
  *p = (char )'-';
  p += (flags & 1) != 0;
  *p = (char )'+';
  p += (flags & 2) != 0;
  *p = (char )' ';
  p += (flags & 4) != 0;
  *p = (char )'0';
  p += (flags & 8) != 0;
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'*';
  tmp___2 = p;
  p ++;
  *tmp___2 = (char )'.';
  tmp___3 = p;
  p ++;
  *tmp___3 = (char )'*';
  *p = (char )'L';
  p += 0;
  tmp___4 = p;
  p ++;
  if (flags & 16) {
    *tmp___4 = (char )'G';
  } else {
    *tmp___4 = (char )'g';
  }
  *p = (char )'\000';
  if (abs_x < (double )2.22507385850720138309e-308L) {
    prec = 1;
  } else {
    prec = 15;
  }
  while (1) {
    tmp___5 = snprintf((char * __restrict  )buf___1, bufsize___0, (char const   * __restrict  )(format),
                       width, prec, x);
    n = (int )tmp___5;
    if (n < 0) {
      return (n);
    } else
    if (17 <= prec) {
      return (n);
    } else
    if ((size_t )n < bufsize___0) {
      tmp___6 = strtod((char const   * __restrict  )buf___1, (char ** __restrict  )((void *)0));
      if (tmp___6 == x) {
        return (n);
      }
    }
    prec ++;
  }
}
}
struct timespec dtotimespec(double sec ) ;
struct timespec dtotimespec(double sec ) 
{ double min_representable ;
  double max_representable ;
  struct timespec r ;
  time_t s ;
  double frac ;
  long ns ;

  {
  min_representable = (double )(~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
  max_representable = ((double )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) * (double )1000000000 + (double )999999999) / (double )1000000000;
  if (! (min_representable < sec)) {
    r.tv_sec = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
    r.tv_nsec = 0L;
  } else
  if (! (sec < max_representable)) {
    r.tv_sec = ((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L;
    r.tv_nsec = 999999999L;
  } else {
    s = (time_t )sec;
    frac = (double )1000000000 * (sec - (double )s);
    ns = (long )frac;
    ns += (long )((double )ns < frac);
    s += ns / 1000000000L;
    ns %= 1000000000L;
    if (ns < 0L) {
      s --;
      ns += 1000000000L;
    }
    r.tv_sec = s;
    r.tv_nsec = ns;
  }
  return (r);
}
}
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern int tolower(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = (__int32_t )*(*tmp + __c);
    } else {
      tmp___0 = (__int32_t )((__int32_t const   )__c);
    }
  } else {
    tmp___0 = (__int32_t )((__int32_t const   )__c);
  }
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern int toupper(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = (__int32_t )*(*tmp + __c);
    } else {
      tmp___0 = (__int32_t )((__int32_t const   )__c);
    }
  } else {
    tmp___0 = (__int32_t )((__int32_t const   )__c);
  }
  return (tmp___0);
}
}
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void)  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
int mbscasecmp(char const   *s1 , char const   *s2 )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncat)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                      wchar_t const   * __restrict  __s2 ,
                                                                                                                                      size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                                                                       wchar_t const   *__s2 ,
                                                                                                                                       size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemset)(wchar_t *__s ,
                                                                                                                                      wchar_t __c ,
                                                                                                                                      size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmempcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                       wchar_t const   * __restrict  __s2 ,
                                                                                                                                       size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc ) ;
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wcrtomb)(char * __restrict  __s ,
                                                                wchar_t __wchar ,
                                                                mbstate_t * __restrict  __ps ) ;
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   * __restrict  __s ,
                                                     size_t __n , mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   * __restrict  __s ,
                                                            size_t __n , mbstate_t * __restrict  __ps ) ;
extern wint_t __btowc_alias(int __c )  __asm__("btowc")  ;
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c ) ;
__inline extern wint_t btowc(int __c ) 
{ wint_t tmp ;

  {
  tmp = __btowc_alias(__c);
  return (tmp);
}
}
extern int __wctob_alias(wint_t __c )  __asm__("wctob")  ;
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc ) ;
__inline extern int wctob(wint_t __wc ) 
{ int tmp ;

  {
  tmp = __wctob_alias(__wc);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   * __restrict  __s ,
                                                            size_t __n , mbstate_t * __restrict  __ps ) ;
__inline extern size_t mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) 
{ size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    tmp = mbrtowc((wchar_t * __restrict  )((void *)0), __s, __n, (mbstate_t *)__ps);
    tmp___1 = tmp;
  } else {
    tmp___0 = __mbrlen(__s, __n, (mbstate_t * __restrict  )((void *)0));
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                      char const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsrtombs)(char * __restrict  __dst ,
                                                                                                                                      wchar_t const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsnrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                       char const   ** __restrict  __src ,
                                                                                                                                       size_t __nmc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsnrtombs)(char * __restrict  __dst ,
                                                                                                                                       wchar_t const   ** __restrict  __src ,
                                                                                                                                       size_t __nwc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpcpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fwprintf)(__FILE * __restrict  __stream ,
                                                                                                    wchar_t const   * __restrict  __fmt 
                                                                                                    , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wprintf)(wchar_t const   * __restrict  __fmt 
                                                                                                   , ...) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) swprintf)(wchar_t * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  wchar_t const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfwprintf)(__FILE * __restrict  __stream ,
                                                                                                     wchar_t const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vwprintf)(wchar_t const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vswprintf)(wchar_t * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   wchar_t const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws)(wchar_t * __restrict  __s ,
                                                                                                                               int __n ,
                                                                                                                               __FILE * __restrict  __stream ) ;
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws_unlocked)(wchar_t * __restrict  __s ,
                                                                                                                                        int __n ,
                                                                                                                                        __FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk(wchar_t * __restrict  __s1 ,
                                                            wchar_t const   * __restrict  __s2 ,
                                                            size_t __n , size_t __ns1 ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_alias(wchar_t * __restrict  __s1 ,
                                                              wchar_t const   * __restrict  __s2 ,
                                                              size_t __n )  __asm__("wmemcpy")  ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk_warn(wchar_t * __restrict  __s1 ,
                                                                 wchar_t const   * __restrict  __s2 ,
                                                                 size_t __n , size_t __ns1 )  __asm__("__wmemcpy_chk") __attribute__((__warning__("wmemcpy called with length bigger than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                      wchar_t const   * __restrict  __s2 ,
                                                                                                                                      size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemcpy)(wchar_t * __restrict  __s1 ,
                                                                                                        wchar_t const   * __restrict  __s2 ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s1, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s1, 0);
    tmp___0 = __wmemcpy_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s1, 0);
    if (__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__s1, 0);
      tmp___2 = __wmemcpy_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __wmemcpy_alias(__s1, __s2, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk(wchar_t *__s1 , wchar_t const   *__s2 ,
                                                             size_t __n , size_t __ns1 ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_alias(wchar_t *__s1 , wchar_t const   *__s2 ,
                                                               size_t __n )  __asm__("wmemmove")  ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk_warn(wchar_t *__s1 ,
                                                                  wchar_t const   *__s2 ,
                                                                  size_t __n , size_t __ns1 )  __asm__("__wmemmove_chk") __attribute__((__warning__("wmemmove called with length bigger than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                                                                       wchar_t const   *__s2 ,
                                                                                                                                       size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemmove)(wchar_t *__s1 ,
                                                                                                         wchar_t const   *__s2 ,
                                                                                                         size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s1, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s1, 0);
    tmp___0 = __wmemmove_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s1, 0);
    if (__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__s1, 0);
      tmp___2 = __wmemmove_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __wmemmove_alias(__s1, __s2, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk(wchar_t * __restrict  __s1 ,
                                                             wchar_t const   * __restrict  __s2 ,
                                                             size_t __n , size_t __ns1 ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_alias(wchar_t * __restrict  __s1 ,
                                                               wchar_t const   * __restrict  __s2 ,
                                                               size_t __n )  __asm__("wmempcpy")  ;
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk_warn(wchar_t * __restrict  __s1 ,
                                                                  wchar_t const   * __restrict  __s2 ,
                                                                  size_t __n , size_t __ns1 )  __asm__("__wmempcpy_chk") __attribute__((__warning__("wmempcpy called with length bigger than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmempcpy)(wchar_t * __restrict  __s1 ,
                                                                                                                                       wchar_t const   * __restrict  __s2 ,
                                                                                                                                       size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmempcpy)(wchar_t * __restrict  __s1 ,
                                                                                                         wchar_t const   * __restrict  __s2 ,
                                                                                                         size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s1, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s1, 0);
    tmp___0 = __wmempcpy_chk(__s1, __s2, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s1, 0);
    if (__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__s1, 0);
      tmp___2 = __wmempcpy_chk_warn(__s1, __s2, __n, tmp___1 / sizeof(wchar_t ));
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __wmempcpy_alias(__s1, __s2, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk(wchar_t *__s , wchar_t __c ,
                                                            size_t __n , size_t __ns ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_alias(wchar_t *__s , wchar_t __c ,
                                                              size_t __n )  __asm__("wmemset")  ;
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk_warn(wchar_t *__s , wchar_t __c ,
                                                                 size_t __n , size_t __ns )  __asm__("__wmemset_chk") __attribute__((__warning__("wmemset called with length bigger than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemset)(wchar_t *__s ,
                                                                                                                                      wchar_t __c ,
                                                                                                                                      size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wmemset)(wchar_t *__s ,
                                                                                                        wchar_t __c ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 0);
    tmp___0 = __wmemset_chk(__s, __c, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 0);
    if (__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__s, 0);
      tmp___2 = __wmemset_chk_warn(__s, __c, __n, tmp___1 / sizeof(wchar_t ));
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __wmemset_alias(__s, __c, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_chk(wchar_t * __restrict  __dest ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __n ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_alias(wchar_t * __restrict  __dest ,
                                                             wchar_t const   * __restrict  __src )  __asm__("wcscpy")  ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                                       wchar_t const   * __restrict  __src ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcscpy_chk(__dest, __src, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
  tmp___2 = __wcscpy_alias(__dest, __src);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_chk(wchar_t * __restrict  __dest ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __destlen ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_alias(wchar_t * __restrict  __dest ,
                                                             wchar_t const   * __restrict  __src )  __asm__("wcpcpy")  ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpcpy)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpcpy)(wchar_t * __restrict  __dest ,
                                                                                                       wchar_t const   * __restrict  __src ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcpcpy_chk(__dest, __src, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
  tmp___2 = __wcpcpy_alias(__dest, __src);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk(wchar_t * __restrict  __dest ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __n , size_t __destlen ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_alias(wchar_t * __restrict  __dest ,
                                                              wchar_t const   * __restrict  __src ,
                                                              size_t __n )  __asm__("wcsncpy")  ;
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk_warn(wchar_t * __restrict  __dest ,
                                                                 wchar_t const   * __restrict  __src ,
                                                                 size_t __n , size_t __destlen )  __asm__("__wcsncpy_chk") __attribute__((__warning__("wcsncpy called with length bigger than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                                        wchar_t const   * __restrict  __src ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dest, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcsncpy_chk(__dest, __src, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__dest, 1);
    if (__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dest, 1);
      tmp___2 = __wcsncpy_chk_warn(__dest, __src, __n, tmp___1 / sizeof(wchar_t ));
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __wcsncpy_alias(__dest, __src, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk(wchar_t * __restrict  __dest ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __n , size_t __destlen ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_alias(wchar_t * __restrict  __dest ,
                                                              wchar_t const   * __restrict  __src ,
                                                              size_t __n )  __asm__("wcpncpy")  ;
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk_warn(wchar_t * __restrict  __dest ,
                                                                 wchar_t const   * __restrict  __src ,
                                                                 size_t __n , size_t __destlen )  __asm__("__wcpncpy_chk") __attribute__((__warning__("wcpncpy called with length bigger than size of destination buffer"))) ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpncpy)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcpncpy)(wchar_t * __restrict  __dest ,
                                                                                                        wchar_t const   * __restrict  __src ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dest, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcpncpy_chk(__dest, __src, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__dest, 1);
    if (__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dest, 1);
      tmp___2 = __wcpncpy_chk_warn(__dest, __src, __n, tmp___1 / sizeof(wchar_t ));
      return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __wcpncpy_alias(__dest, __src, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_chk(wchar_t * __restrict  __dest ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __destlen ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_alias(wchar_t * __restrict  __dest ,
                                                             wchar_t const   * __restrict  __src )  __asm__("wcscat")  ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                                                                     wchar_t const   * __restrict  __src ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcscat)(wchar_t * __restrict  __dest ,
                                                                                                       wchar_t const   * __restrict  __src ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcscat_chk(__dest, __src, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
  tmp___2 = __wcscat_alias(__dest, __src);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_chk(wchar_t * __restrict  __dest ,
                                                            wchar_t const   * __restrict  __src ,
                                                            size_t __n , size_t __destlen ) ;
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_alias(wchar_t * __restrict  __dest ,
                                                              wchar_t const   * __restrict  __src ,
                                                              size_t __n )  __asm__("wcsncat")  ;
__inline extern  __attribute__((__nothrow__)) wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncat)(wchar_t * __restrict  __dest ,
                                                                                                                                      wchar_t const   * __restrict  __src ,
                                                                                                                                      size_t __n ) ;
__inline extern wchar_t __attribute__((__artificial__))  *( __attribute__((__always_inline__)) wcsncat)(wchar_t * __restrict  __dest ,
                                                                                                        wchar_t const   * __restrict  __src ,
                                                                                                        size_t __n ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__dest, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dest, 1);
    tmp___0 = __wcsncat_chk(__dest, __src, __n, tmp / sizeof(wchar_t ));
    return ((wchar_t __attribute__((__artificial__))  *)tmp___0);
  }
  tmp___2 = __wcsncat_alias(__dest, __src, __n);
  return ((wchar_t __attribute__((__artificial__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) int __swprintf_chk(wchar_t * __restrict  __s ,
                                                        size_t __n , int __flag ,
                                                        size_t __s_len , wchar_t const   * __restrict  __format 
                                                        , ...) ;
extern  __attribute__((__nothrow__)) int __swprintf_alias(wchar_t * __restrict  __s ,
                                                          size_t __n , wchar_t const   * __restrict  __fmt 
                                                          , ...)  __asm__("swprintf")  ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) swprintf)(wchar_t * __restrict  __s ,
                                                                                                                                  size_t __n ,
                                                                                                                                  wchar_t const   * __restrict  __fmt 
                                                                                                                                  , ...) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) swprintf)(wchar_t * __restrict  __s ,
                                                                                                    size_t __n ,
                                                                                                    wchar_t const   * __restrict  __fmt 
                                                                                                    , ...) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __swprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __builtin_va_arg_pack());
    return ((int __attribute__((__artificial__))  )tmp___0);
  } else {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __swprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __builtin_va_arg_pack());
    return ((int __attribute__((__artificial__))  )tmp___0);
  }
  tmp___2 = __swprintf_alias(__s, __n, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp___2);
}
}
extern  __attribute__((__nothrow__)) int __vswprintf_chk(wchar_t * __restrict  __s ,
                                                         size_t __n , int __flag ,
                                                         size_t __s_len , wchar_t const   * __restrict  __format ,
                                                         __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int __vswprintf_alias(wchar_t * __restrict  __s ,
                                                           size_t __n , wchar_t const   * __restrict  __fmt ,
                                                           __gnuc_va_list __ap )  __asm__("vswprintf")  ;
__inline extern  __attribute__((__nothrow__)) int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vswprintf)(wchar_t * __restrict  __s ,
                                                                                                                                   size_t __n ,
                                                                                                                                   wchar_t const   * __restrict  __fmt ,
                                                                                                                                   __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vswprintf)(wchar_t * __restrict  __s ,
                                                                                                     size_t __n ,
                                                                                                     wchar_t const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __vswprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __ap);
    return ((int __attribute__((__artificial__))  )tmp___0);
  } else {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __vswprintf_chk(__s, __n, 1, tmp / sizeof(wchar_t ), __fmt, __ap);
    return ((int __attribute__((__artificial__))  )tmp___0);
  }
  tmp___2 = __vswprintf_alias(__s, __n, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp___2);
}
}
extern int __fwprintf_chk(__FILE * __restrict  __stream , int __flag , wchar_t const   * __restrict  __format 
                          , ...) ;
extern int __wprintf_chk(int __flag , wchar_t const   * __restrict  __format  , ...) ;
extern int __vfwprintf_chk(__FILE * __restrict  __stream , int __flag , wchar_t const   * __restrict  __format ,
                           __gnuc_va_list __ap ) ;
extern int __vwprintf_chk(int __flag , wchar_t const   * __restrict  __format , __gnuc_va_list __ap ) ;
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wprintf)(wchar_t const   * __restrict  __fmt 
                                                                                                   , ...) 
{ int tmp ;

  {
  tmp = __wprintf_chk(1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) fwprintf)(__FILE * __restrict  __stream ,
                                                                                                    wchar_t const   * __restrict  __fmt 
                                                                                                    , ...) 
{ int tmp ;

  {
  tmp = __fwprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vwprintf)(wchar_t const   * __restrict  __fmt ,
                                                                                                    __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __vwprintf_chk(1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
__inline extern int __attribute__((__artificial__))  ( __attribute__((__always_inline__)) vfwprintf)(__FILE * __restrict  __stream ,
                                                                                                     wchar_t const   * __restrict  __fmt ,
                                                                                                     __gnuc_va_list __ap ) 
{ int tmp ;

  {
  tmp = __vfwprintf_chk(__stream, 1, __fmt, __ap);
  return ((int __attribute__((__artificial__))  )tmp);
}
}
extern wchar_t *__fgetws_chk(wchar_t * __restrict  __s , size_t __size , int __n ,
                             __FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern wchar_t *__fgetws_alias(wchar_t * __restrict  __s , int __n , __FILE * __restrict  __stream )  __asm__("fgetws") __attribute__((__warn_unused_result__)) ;
extern wchar_t *__fgetws_chk_warn(wchar_t * __restrict  __s , size_t __size , int __n ,
                                  __FILE * __restrict  __stream )  __asm__("__fgetws_chk") __attribute__((__warning__("fgetws called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws)(wchar_t * __restrict  __s ,
                                                                                                                               int __n ,
                                                                                                                               __FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgetws_chk(__s, tmp / sizeof(wchar_t ), __n, __stream);
    return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgetws_chk_warn(__s, tmp___1 / sizeof(wchar_t ), __n, __stream);
      return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __fgetws_alias(__s, __n, __stream);
  return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
extern wchar_t *__fgetws_unlocked_chk(wchar_t * __restrict  __s , size_t __size ,
                                      int __n , __FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
extern wchar_t *__fgetws_unlocked_alias(wchar_t * __restrict  __s , int __n , __FILE * __restrict  __stream )  __asm__("fgetws_unlocked") __attribute__((__warn_unused_result__)) ;
extern wchar_t *__fgetws_unlocked_chk_warn(wchar_t * __restrict  __s , size_t __size ,
                                           int __n , __FILE * __restrict  __stream )  __asm__("__fgetws_unlocked_chk") __attribute__((__warning__("fgetws_unlocked called with bigger size than length of destination buffer"),
__warn_unused_result__)) ;
__inline extern wchar_t __attribute__((__warn_unused_result__, __artificial__))  *( __attribute__((__always_inline__)) fgetws_unlocked)(wchar_t * __restrict  __s ,
                                                                                                                                        int __n ,
                                                                                                                                        __FILE * __restrict  __stream ) 
{ unsigned long tmp ;
  wchar_t *tmp___0 ;
  unsigned long tmp___1 ;
  wchar_t *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  wchar_t *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgetws_unlocked_chk(__s, tmp / sizeof(wchar_t ), __n, __stream);
    return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgetws_unlocked_chk_warn(__s, tmp___1 / sizeof(wchar_t ), __n, __stream);
      return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___2);
    }
  }
  tmp___5 = __fgetws_unlocked_alias(__s, __n, __stream);
  return ((wchar_t __attribute__((__warn_unused_result__, __artificial__))  *)tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __wcrtomb_chk(char * __restrict  __s ,
                                                          wchar_t __wchar , mbstate_t * __restrict  __p ,
                                                          size_t __buflen )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) size_t __wcrtomb_alias(char * __restrict  __s ,
                                                            wchar_t __wchar , mbstate_t * __restrict  __ps )  __asm__("wcrtomb") __attribute__((__warn_unused_result__)) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__warn_unused_result__,
__artificial__))  ( __attribute__((__always_inline__)) wcrtomb)(char * __restrict  __s ,
                                                                wchar_t __wchar ,
                                                                mbstate_t * __restrict  __ps ) ;
__inline extern size_t __attribute__((__warn_unused_result__, __artificial__))  ( __attribute__((__always_inline__)) wcrtomb)(char * __restrict  __s ,
                                                                                                                              wchar_t __wchar ,
                                                                                                                              mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___2) {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wcrtomb_chk(__s, __wchar, __ps, tmp);
      return ((size_t __attribute__((__artificial__))  )tmp___0);
    }
  }
  tmp___3 = __wcrtomb_alias(__s, __wchar, __ps);
  return ((size_t __attribute__((__artificial__))  )tmp___3);
}
}
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk(wchar_t * __restrict  __dst ,
                                                            char const   ** __restrict  __src ,
                                                            size_t __len , mbstate_t * __restrict  __ps ,
                                                            size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_alias(wchar_t * __restrict  __dst ,
                                                              char const   ** __restrict  __src ,
                                                              size_t __len , mbstate_t * __restrict  __ps )  __asm__("mbsrtowcs")  ;
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                 char const   ** __restrict  __src ,
                                                                 size_t __len , mbstate_t * __restrict  __ps ,
                                                                 size_t __dstlen )  __asm__("__mbsrtowcs_chk") __attribute__((__warning__("mbsrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                      char const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                        char const   ** __restrict  __src ,
                                                                                                        size_t __len ,
                                                                                                        mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbsrtowcs_chk(__dst, __src, __len, __ps, tmp / sizeof(wchar_t ));
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbsrtowcs_chk_warn(__dst, __src, __len, __ps, tmp___1 / sizeof(wchar_t ));
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __mbsrtowcs_alias(__dst, __src, __len, __ps);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk(char * __restrict  __dst ,
                                                            wchar_t const   ** __restrict  __src ,
                                                            size_t __len , mbstate_t * __restrict  __ps ,
                                                            size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_alias(char * __restrict  __dst ,
                                                              wchar_t const   ** __restrict  __src ,
                                                              size_t __len , mbstate_t * __restrict  __ps )  __asm__("wcsrtombs")  ;
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk_warn(char * __restrict  __dst ,
                                                                 wchar_t const   ** __restrict  __src ,
                                                                 size_t __len , mbstate_t * __restrict  __ps ,
                                                                 size_t __dstlen )  __asm__("__wcsrtombs_chk") __attribute__((__warning__("wcsrtombs called with dst buffer smaller than len"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsrtombs)(char * __restrict  __dst ,
                                                                                                                                      wchar_t const   ** __restrict  __src ,
                                                                                                                                      size_t __len ,
                                                                                                                                      mbstate_t * __restrict  __ps ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsrtombs)(char * __restrict  __dst ,
                                                                                                        wchar_t const   ** __restrict  __src ,
                                                                                                        size_t __len ,
                                                                                                        mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcsrtombs_chk(__dst, __src, __len, __ps, tmp);
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcsrtombs_chk_warn(__dst, __src, __len, __ps, tmp___1);
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __wcsrtombs_alias(__dst, __src, __len, __ps);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk(wchar_t * __restrict  __dst ,
                                                             char const   ** __restrict  __src ,
                                                             size_t __nmc , size_t __len ,
                                                             mbstate_t * __restrict  __ps ,
                                                             size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_alias(wchar_t * __restrict  __dst ,
                                                               char const   ** __restrict  __src ,
                                                               size_t __nmc , size_t __len ,
                                                               mbstate_t * __restrict  __ps )  __asm__("mbsnrtowcs")  ;
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                  char const   ** __restrict  __src ,
                                                                  size_t __nmc , size_t __len ,
                                                                  mbstate_t * __restrict  __ps ,
                                                                  size_t __dstlen )  __asm__("__mbsnrtowcs_chk") __attribute__((__warning__("mbsnrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsnrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                                                       char const   ** __restrict  __src ,
                                                                                                                                       size_t __nmc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) mbsnrtowcs)(wchar_t * __restrict  __dst ,
                                                                                                         char const   ** __restrict  __src ,
                                                                                                         size_t __nmc ,
                                                                                                         size_t __len ,
                                                                                                         mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbsnrtowcs_chk(__dst, __src, __nmc, __len, __ps, tmp / sizeof(wchar_t ));
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbsnrtowcs_chk_warn(__dst, __src, __nmc, __len, __ps, tmp___1 / sizeof(wchar_t ));
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __mbsnrtowcs_alias(__dst, __src, __nmc, __len, __ps);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk(char * __restrict  __dst ,
                                                             wchar_t const   ** __restrict  __src ,
                                                             size_t __nwc , size_t __len ,
                                                             mbstate_t * __restrict  __ps ,
                                                             size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_alias(char * __restrict  __dst ,
                                                               wchar_t const   ** __restrict  __src ,
                                                               size_t __nwc , size_t __len ,
                                                               mbstate_t * __restrict  __ps )  __asm__("wcsnrtombs")  ;
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk_warn(char * __restrict  __dst ,
                                                                  wchar_t const   ** __restrict  __src ,
                                                                  size_t __nwc , size_t __len ,
                                                                  mbstate_t * __restrict  __ps ,
                                                                  size_t __dstlen )  __asm__("__wcsnrtombs_chk") __attribute__((__warning__("wcsnrtombs called with dst buffer smaller than len"))) ;
__inline extern  __attribute__((__nothrow__)) size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsnrtombs)(char * __restrict  __dst ,
                                                                                                                                       wchar_t const   ** __restrict  __src ,
                                                                                                                                       size_t __nwc ,
                                                                                                                                       size_t __len ,
                                                                                                                                       mbstate_t * __restrict  __ps ) ;
__inline extern size_t __attribute__((__artificial__))  ( __attribute__((__always_inline__)) wcsnrtombs)(char * __restrict  __dst ,
                                                                                                         wchar_t const   ** __restrict  __src ,
                                                                                                         size_t __nwc ,
                                                                                                         size_t __len ,
                                                                                                         mbstate_t * __restrict  __ps ) 
{ unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcsnrtombs_chk(__dst, __src, __nwc, __len, __ps, tmp);
    return ((size_t __attribute__((__artificial__))  )tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcsnrtombs_chk_warn(__dst, __src, __nwc, __len, __ps, tmp___1);
      return ((size_t __attribute__((__artificial__))  )tmp___2);
    }
  }
  tmp___5 = __wcsnrtombs_alias(__dst, __src, __nwc, __len, __ps);
  return ((size_t __attribute__((__artificial__))  )tmp___5);
}
}
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) ;
struct exclude *new_exclude(void) ;
void free_exclude(struct exclude *ex ) ;
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
size_t hash_string(char const   *string , size_t n_buckets ) ;
unsigned int const   is_basic_table[8] ;
__inline static _Bool is_basic(char c ) 
{ 

  {
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
size_t strnlen1(char const   *string , size_t maxlen ) ;
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  if (iter->next_done) {
    return;
  }
  if (iter->in_shift) {
    goto with_shift;
  }
  tmp___3 = is_basic((char )*(iter->cur.ptr));
  if (tmp___3) {
    iter->cur.bytes = (size_t )1;
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
    iter->cur.wc_valid = (_Bool)1;
  } else {
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
    if (! tmp) {
      __assert_fail("mbsinit (&iter->state)", "mbuiter.h", 142U, "mbuiter_multi_next");
    }
    iter->in_shift = (_Bool)1;
    with_shift: 
    tmp___0 = __ctype_get_mb_cur_max();
    tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
    iter->cur.bytes = mbrtowc((wchar_t * __restrict  )(& iter->cur.wc), (char const   * __restrict  )iter->cur.ptr,
                              tmp___1, & iter->state);
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
      iter->cur.bytes = (size_t )1;
      iter->cur.wc_valid = (_Bool)0;
    } else
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      iter->cur.bytes = strlen(iter->cur.ptr);
      iter->cur.wc_valid = (_Bool)0;
    } else {
      if (iter->cur.bytes == 0UL) {
        iter->cur.bytes = (size_t )1;
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          __assert_fail("*iter->cur.ptr == \'\\0\'", "mbuiter.h", 170U, "mbuiter_multi_next");
        }
        if (! (iter->cur.wc == 0)) {
          __assert_fail("iter->cur.wc == 0", "mbuiter.h", 171U, "mbuiter_multi_next");
        }
      }
      iter->cur.wc_valid = (_Bool)1;
      tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
      if (tmp___2) {
        iter->in_shift = (_Bool)0;
      }
    }
  }
  iter->next_done = (_Bool)1;
  return;
}
}
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
void *x2realloc(void *p , size_t *pn ) ;
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ size_t n ;
  void *tmp ;

  {
  n = *pn;
  if (! p) {
    if (! n) {
      n = 128UL / s;
      n += (size_t )(! n);
    }
  } else {
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      xalloc_die();
    }
    n += (n + 1UL) / 2UL;
  }
  *pn = n;
  tmp = xrealloc(p, n * s);
  return (tmp);
}
}
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ char const   *cset ;
  size_t n ;
  unsigned long tmp___9 ;

  {
  cset = "\\?*[]";
  if (options & (1 << 1)) {
    cset ++;
  }
  while (*str) {
    tmp___9 = __builtin_strcspn(str, cset);
    n = tmp___9;
    if ((int const   )*(str + n) == 0) {
      break;
    } else
    if ((int const   )*(str + n) == 92) {
      str += n + 1UL;
      if (*str) {
        str ++;
      }
    } else {
      return ((_Bool)1);
    }
  }
  return ((_Bool)0);
}
}
static void unescape_pattern(char *str ) 
{ int inset ;
  char *q ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
  inset = 0;
  q = str;
  while (1) {
    if (inset) {
      if ((int )*q == 93) {
        inset = 0;
      }
    } else
    if ((int )*q == 91) {
      inset = 1;
    } else
    if ((int )*q == 92) {
      q ++;
    }
    tmp = str;
    str ++;
    tmp___1 = q;
    q ++;
    tmp___0 = *tmp___1;
    *tmp = tmp___0;
    if (! tmp___0) {
      break;
    }
  }
  return;
}
}
struct exclude *new_exclude(void) 
{ struct exclude *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = xzalloc(sizeof(*tmp));
  return ((struct exclude *)tmp___0);
}
}
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ char const   *p ;
  size_t tmp ;

  {
  p = (char const   *)data;
  tmp = hash_string(p, n_buckets);
  return (tmp);
}
}
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  p = (char const   *)data;
  value = (size_t )0;
  iter.cur.ptr = p;
  iter.in_shift = (_Bool)0;
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
  iter.next_done = (_Bool)0;
  while (1) {
    mbuiter_multi_next(& iter);
    if (iter.cur.wc_valid) {
      if (iter.cur.wc == 0) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
    } else {
      tmp___0 = 1;
    }
    if (! tmp___0) {
      break;
    }
    m = iter.cur;
    if (m.wc_valid) {
      tmp = towlower((wint_t )m.wc);
      wc = (wchar_t )tmp;
    } else {
      wc = (wchar_t )*(m.ptr);
    }
    value = (value * 31UL + (size_t )wc) % n_buckets;
    iter.cur.ptr += iter.cur.bytes;
    iter.next_done = (_Bool)0;
  }
  return (value);
}
}
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ char const   *p1 ;
  char const   *p2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  p1 = (char const   *)data1;
  p2 = (char const   *)data2;
  if (0) {
    __s1_len = __builtin_strlen(p1);
    __s2_len = __builtin_strlen(p2);
    if (! ((size_t )((void const   *)(p1 + 1)) - (size_t )((void const   *)p1) == 1UL)) {
      goto _L___0;
    } else
    if (__s1_len >= 4UL) {
      _L___0: 
      if (! ((size_t )((void const   *)(p2 + 1)) - (size_t )((void const   *)p2) == 1UL)) {
        tmp___5 = 1;
      } else
      if (__s2_len >= 4UL) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 0;
    }
    if (tmp___5) {
      tmp___0 = __builtin_strcmp(p1, p2);
      tmp___4 = tmp___0;
    } else {
      tmp___3 = __builtin_strcmp(p1, p2);
      tmp___4 = tmp___3;
    }
  } else {
    tmp___3 = __builtin_strcmp(p1, p2);
    tmp___4 = tmp___3;
  }
  return ((_Bool )(tmp___4 == 0));
}
}
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  p1 = (char const   *)data1;
  p2 = (char const   *)data2;
  tmp = mbscasecmp(p1, p2);
  return ((_Bool )(tmp == 0));
}
}
static void string_free(void *data ) 
{ 

  {
  free(data);
  return;
}
}
static struct exclude_segment *new_exclude_segment(struct exclude *ex , enum exclude_type type ,
                                                   int options ) 
{ struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  tmp = xzalloc(sizeof(struct exclude_segment ));
  sp = (struct exclude_segment *)tmp;
  sp->type = type;
  sp->options = options;
  switch ((int )type) {
  case 1: 
  break;
  case 0: 
  if (options & (1 << 4)) {
    tmp___0 = & string_compare_ci;
  } else {
    tmp___0 = & string_compare;
  }
  if (options & (1 << 4)) {
    tmp___1 = & string_hasher_ci;
  } else {
    tmp___1 = & string_hasher;
  }
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  break;
  }
  if (ex->tail) {
    (ex->tail)->next = sp;
  } else {
    ex->head = sp;
  }
  ex->tail = sp;
  return (sp);
}
}
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 

  {
  switch ((int )seg->type) {
  case 1: 
  free((void *)seg->v.pat.exclude);
  break;
  case 0: 
  hash_free(seg->v.table);
  break;
  }
  free((void *)seg);
  return;
}
}
void free_exclude(struct exclude *ex ) 
{ struct exclude_segment *seg ;
  struct exclude_segment *next ;

  {
  seg = ex->head;
  while (seg) {
    next = seg->next;
    free_exclude_segment(seg);
    seg = next;
  }
  free((void *)ex);
  return;
}
}
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t patlen ;
  size_t tmp___8 ;
  int r ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *fcopy ;
  char *tmp___22 ;
  char *p ;
  int r___0 ;
  char *tmp___23 ;
  char *tmp___25 ;

  {
  if (! (options & (1 << 3))) {
    if (options & (1 << 4)) {
      tmp = mbscasecmp(pattern, f);
      tmp___7 = tmp;
    } else {
      if (0) {
        __s1_len = __builtin_strlen(pattern);
        __s2_len = __builtin_strlen(f);
        if (! ((size_t )((void const   *)(pattern + 1)) - (size_t )((void const   *)pattern) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)(f + 1)) - (size_t )((void const   *)f) == 1UL)) {
            tmp___6 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (tmp___6) {
          tmp___1 = __builtin_strcmp(pattern, f);
          tmp___5 = tmp___1;
        } else {
          tmp___4 = __builtin_strcmp(pattern, f);
          tmp___5 = tmp___4;
        }
      } else {
        tmp___4 = __builtin_strcmp(pattern, f);
        tmp___5 = tmp___4;
      }
      tmp___7 = tmp___5;
    }
    return (tmp___7);
  } else
  if (! (options & (1 << 4))) {
    tmp___8 = strlen(pattern);
    patlen = tmp___8;
    if (0) {
      if (0) {
        __s1_len___0 = __builtin_strlen(pattern);
        __s2_len___0 = __builtin_strlen(f);
        if (! ((size_t )((void const   *)(pattern + 1)) - (size_t )((void const   *)pattern) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)(f + 1)) - (size_t )((void const   *)f) == 1UL)) {
            tmp___17 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___17 = 1;
          } else {
            tmp___17 = 0;
          }
        } else {
          tmp___17 = 0;
        }
        if (tmp___17) {
          tmp___12 = __builtin_strcmp(pattern, f);
          tmp___16 = tmp___12;
        } else {
          tmp___15 = __builtin_strcmp(pattern, f);
          tmp___16 = tmp___15;
        }
      } else {
        tmp___15 = __builtin_strcmp(pattern, f);
        tmp___16 = tmp___15;
      }
      tmp___19 = tmp___16;
    } else {
      tmp___18 = strncmp(pattern, f, patlen);
      tmp___19 = tmp___18;
    }
    r = tmp___19;
    if (! r) {
      r = (int )*(f + patlen);
      if (r == 47) {
        r = 0;
      }
    }
    return (r);
  } else {
    tmp___22 = xstrdup(f);
    fcopy = tmp___22;
    p = fcopy;
    while (1) {
      tmp___25 = __builtin_strchr(p, '/');
      p = tmp___25;
      if (p) {
        *p = (char )'\000';
      }
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      if (! p) {
        break;
      } else
      if (r___0 <= 0) {
        break;
      }
      tmp___23 = p;
      p ++;
      *tmp___23 = (char )'/';
    }
    free((void *)fcopy);
    return (r___0);
  }
}
}
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
  if (options & (1 << 28)) {
    tmp = & fnmatch;
  } else {
    tmp = & fnmatch_no_wildcards;
  }
  matcher = tmp;
  tmp___0 = (*matcher)(pattern, f, options);
  matched = (_Bool )(tmp___0 == 0);
  if (! (options & (1 << 30))) {
    p = f;
    while (1) {
      if (*p) {
        if (! (! matched)) {
          break;
        }
      } else {
        break;
      }
      if ((int const   )*p == 47) {
        if ((int const   )*(p + 1) != 47) {
          tmp___1 = (*matcher)(pattern, p + 1, options);
          matched = (_Bool )(tmp___1 == 0);
        }
      }
      p ++;
    }
  }
  return (matched);
}
}
static _Bool excluded_file_pattern_p(struct exclude_segment  const  *seg , char const   *f ) 
{ size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool excluded ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
  exclude_count = (size_t )seg->v.pat.exclude_count;
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
  excluded = (_Bool )(! (! ((exclude + 0)->options & (int const   )(1 << 29))));
  i = (size_t )0;
  while (i < exclude_count) {
    pattern = (char const   *)(exclude + i)->pattern;
    options = (int )(exclude + i)->options;
    tmp = exclude_fnmatch(pattern, f, options);
    if (tmp) {
      return ((_Bool )(! excluded));
    }
    i ++;
  }
  return (excluded);
}
}
static _Bool excluded_file_name_p(struct exclude_segment  const  *seg , char const   *f ,
                                  char *buffer ) 
{ int options ;
  _Bool excluded ;
  Hash_table *table___1 ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
  options = (int )seg->options;
  excluded = (_Bool )(! (! (options & (1 << 29))));
  table___1 = (Hash_table *)seg->v.table;
  while (1) {
    strcpy((char * __restrict  )buffer, (char const   * __restrict  )f);
    while (1) {
      tmp = hash_lookup((Hash_table const   *)table___1, (void const   *)buffer);
      if (tmp) {
        return ((_Bool )(! excluded));
      }
      if (options & (1 << 3)) {
        tmp___0 = strrchr((char const   *)buffer, '/');
        p = tmp___0;
        if (p) {
          *p = (char)0;
          continue;
        }
      }
      break;
    }
    if (! (options & (1 << 30))) {
      tmp___2 = __builtin_strchr((char *)f, '/');
      f = (char const   *)tmp___2;
      if (f) {
        f ++;
      }
    } else {
      break;
    }
    if (! f) {
      break;
    }
  }
  return (excluded);
}
}
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ struct exclude_segment *seg ;
  _Bool excluded ;
  char *filename ;
  _Bool rc ;
  size_t tmp ;
  void *tmp___0 ;

  {
  filename = (char *)((void *)0);
  if (! ex->head) {
    return ((_Bool)0);
  }
  excluded = (_Bool )(! (! ((ex->head)->options & (1 << 29))));
  seg = (struct exclude_segment *)ex->head;
  while (seg) {
    switch ((int )seg->type) {
    case 1: 
    rc = excluded_file_pattern_p((struct exclude_segment  const  *)seg, f);
    break;
    case 0: 
    if (! filename) {
      tmp = strlen(f);
      tmp___0 = xmalloc(tmp + 1UL);
      filename = (char *)tmp___0;
    }
    rc = excluded_file_name_p((struct exclude_segment  const  *)seg, f, filename);
    break;
    default: 
    abort();
    }
    if ((int )rc != (int )excluded) {
      excluded = rc;
      break;
    }
    seg = seg->next;
  }
  free((void *)filename);
  return (excluded);
}
}
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  char *str ;
  char *p ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  if (options & (1 << 28)) {
    tmp___2 = fnmatch_pattern_has_wildcards(pattern, options);
    if (tmp___2) {
      if (ex->tail) {
        if ((unsigned int )(ex->tail)->type == 1U) {
          if (((ex->tail)->options & (1 << 29)) == (options & (1 << 29))) {
            seg = ex->tail;
          } else {
            seg = new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        } else {
          seg = new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      } else {
        seg = new_exclude_segment(ex, (enum exclude_type )1, options);
      }
      pat = & seg->v.pat;
      if (pat->exclude_count == pat->exclude_alloc) {
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
        pat->exclude = (struct patopts *)tmp;
      }
      tmp___0 = pat->exclude_count;
      (pat->exclude_count) ++;
      patopts = pat->exclude + tmp___0;
      patopts->pattern = pattern;
      patopts->options = options;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (ex->tail) {
      if ((unsigned int )(ex->tail)->type == 0U) {
        if (((ex->tail)->options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4))) == (options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4)))) {
          seg = ex->tail;
        } else {
          seg = new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      } else {
        seg = new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    } else {
      seg = new_exclude_segment(ex, (enum exclude_type )0, options);
    }
    str = xstrdup(pattern);
    if (options & (1 << 28)) {
      unescape_pattern(str);
    }
    tmp___1 = hash_insert(seg->v.table, (void const   *)str);
    p = (char *)tmp___1;
    if ((unsigned long )p != (unsigned long )str) {
      free((void *)str);
    }
  }
  return;
}
}
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf___1 ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
  if ((int const   )*(file_name___1 + 0) == 45) {
    if (! *(file_name___1 + 1)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  use_stdin = (_Bool )tmp;
  buf___1 = (char *)((void *)0);
  buf_alloc = (size_t )0;
  buf_count = (size_t )0;
  e = 0;
  if (use_stdin) {
    in = stdin;
  } else {
    in = fopen((char const   * __restrict  )file_name___1, (char const   * __restrict  )"r");
    if (! in) {
      return (-1);
    }
  }
  while (1) {
    c = getc_unlocked(in);
    if (! (c != -1)) {
      break;
    }
    if (buf_count == buf_alloc) {
      tmp___0 = x2realloc((void *)buf___1, & buf_alloc);
      buf___1 = (char *)tmp___0;
    }
    tmp___1 = buf_count;
    buf_count ++;
    *(buf___1 + tmp___1) = (char )c;
  }
  tmp___3 = ferror_unlocked(in);
  if (tmp___3) {
    tmp___2 = __errno_location();
    e = *tmp___2;
  }
  if (! use_stdin) {
    tmp___5 = rpl_fclose(in);
    if (tmp___5 != 0) {
      tmp___4 = __errno_location();
      e = *tmp___4;
    }
  }
  tmp___6 = xrealloc((void *)buf___1, buf_count + 1UL);
  buf___1 = (char *)tmp___6;
  *(buf___1 + buf_count) = line_end;
  if (buf_count == 0UL) {
    tmp___7 = 0;
  } else
  if ((int )*(buf___1 + (buf_count - 1UL)) == (int )line_end) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  lim = (char const   *)((buf___1 + buf_count) + tmp___7);
  pattern = (char const   *)buf___1;
  p = buf___1;
  while ((unsigned long )p < (unsigned long )lim) {
    if ((int )*p == (int )line_end) {
      pattern_end = p;
      tmp___9 = __ctype_b_loc();
      if ((int const   )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
        while (1) {
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
            goto next_pattern;
          } else {
            tmp___8 = __ctype_b_loc();
            if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
              break;
            }
          }
          pattern_end --;
        }
      }
      *pattern_end = (char )'\000';
      (*add_func)(ex, pattern, options);
      next_pattern: 
      pattern = (char const   *)(p + 1);
    }
    p ++;
  }
  tmp___10 = __errno_location();
  *tmp___10 = e;
  if (e) {
    tmp___11 = -1;
  } else {
    tmp___11 = 0;
  }
  return (tmp___11);
}
}
int volatile   exit_failure  =    (int volatile   )1;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice ) ;
void fadvise(FILE *fp , fadvice_t advice ) ;
void fdadvise(int fd , off_t offset , off_t len , fadvice_t advice ) 
{ int __x ;
  int tmp ;

  {
  tmp = posix_fadvise(fd, offset, len, (int )advice);
  __x = tmp;
  return;
}
}
void fadvise(FILE *fp , fadvice_t advice ) 
{ int tmp ;

  {
  if (fp) {
    tmp = fileno(fp);
    fdadvise(tmp, (off_t )0, (off_t )0, advice);
  }
  return;
}
}
int creat_safer(char const   *file , mode_t mode ) ;
extern int creat(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
int fd_safer(int fd ) ;
int creat_safer(char const   *file , mode_t mode ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = creat(file, mode);
  tmp___0 = fd_safer(tmp);
  return (tmp___0);
}
}
int open_safer(char const   *file , int flags  , ...) ;
int open_safer(char const   *file , int flags  , ...) 
{ mode_t mode ;
  va_list ap ;
  int __attribute__((__artificial__))  tmp ;
  int tmp___0 ;

  {
  mode = (mode_t )0;
  if (flags & 64) {
    __builtin_va_start(ap, flags);
    mode = __builtin_va_arg(ap, mode_t );
    __builtin_va_end(ap);
  }
  tmp = open(file, flags, mode);
  tmp___0 = fd_safer((int )tmp);
  return (tmp___0);
}
}
int dup_safer_flag(int fd , int flag ) ;
int fd_safer_flag(int fd , int flag ) ;
int fd_safer_flag(int fd , int flag ) 
{ int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  if (0 <= fd) {
    if (fd <= 2) {
      tmp = dup_safer_flag(fd, flag);
      f = tmp;
      tmp___0 = __errno_location();
      e = *tmp___0;
      close(fd);
      tmp___1 = __errno_location();
      *tmp___1 = e;
      fd = f;
    }
  }
  return (fd);
}
}
int dup_safer_flag(int fd , int flag ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (flag & 524288) {
    tmp = 1030;
  } else {
    tmp = 0;
  }
  tmp___0 = rpl_fcntl(fd, tmp, 3);
  return (tmp___0);
}
}
int rpl_futimens(int fd , struct timespec  const  *times ) ;
int rpl_utimensat(int fd , char const   *file , struct timespec  const  *times , int flag )  __attribute__((__nonnull__(2))) ;
int fdutimensat(int fd , int dir , char const   *file , struct timespec  const  *ts ,
                int atflag ) ;
int fdutimensat(int fd , int dir , char const   *file , struct timespec  const  *ts ,
                int atflag ) 
{ int result ;
  int *tmp ;
  int *tmp___0 ;

  {
  result = 1;
  if (0 <= fd) {
    result = rpl_futimens(fd, ts);
  }
  if (file) {
    if (fd < 0) {
      result = rpl_utimensat(dir, file, ts, atflag);
    } else
    if (result == -1) {
      tmp = __errno_location();
      if (*tmp == 38) {
        result = rpl_utimensat(dir, file, ts, atflag);
      }
    }
  }
  if (result == 1) {
    tmp___0 = __errno_location();
    *tmp___0 = 9;
    result = -1;
  }
  return (result);
}
}
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats )  __attribute__((__nonnull__(2,3))) ;
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats ) 
{ struct F_triple *ent ;
  void *tmp ;
  struct F_triple *ent_from_table ;
  void *tmp___0 ;

  {
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
    return;
  }
  tmp = xmalloc(sizeof(*ent));
  ent = (struct F_triple *)tmp;
  ent->name = xstrdup(file);
  ent->st_ino = (ino_t )stats->st_ino;
  ent->st_dev = (dev_t )stats->st_dev;
  tmp___0 = hash_insert(ht___0, (void const   *)ent);
  ent_from_table = (struct F_triple *)tmp___0;
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
    xalloc_die();
  }
  if ((unsigned long )ent_from_table != (unsigned long )ent) {
    triple_free((void *)ent);
  }
  return;
}
}
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) 
{ struct F_triple new_ent ;
  void *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  new_ent.name = (char *)file;
  new_ent.st_ino = (ino_t )stats->st_ino;
  new_ent.st_dev = (dev_t )stats->st_dev;
  tmp = hash_lookup(ht___0, (void const   *)(& new_ent));
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
}
}
char const   *file_type(struct stat  const  *st ) ;
char const   *file_type(struct stat  const  *st ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;

  {
  if ((st->st_mode & 61440U) == 32768U) {
    if (st->st_size == 0L) {
      tmp = dcgettext((char const   *)((void *)0), "regular empty file", 5);
      tmp___1 = tmp;
    } else {
      tmp___0 = dcgettext((char const   *)((void *)0), "regular file", 5);
      tmp___1 = tmp___0;
    }
    return ((char const   *)tmp___1);
  }
  if ((st->st_mode & 61440U) == 16384U) {
    tmp___2 = dcgettext((char const   *)((void *)0), "directory", 5);
    return ((char const   *)tmp___2);
  }
  if ((st->st_mode & 61440U) == 24576U) {
    tmp___3 = dcgettext((char const   *)((void *)0), "block special file", 5);
    return ((char const   *)tmp___3);
  }
  if ((st->st_mode & 61440U) == 8192U) {
    tmp___4 = dcgettext((char const   *)((void *)0), "character special file", 5);
    return ((char const   *)tmp___4);
  }
  if ((st->st_mode & 61440U) == 4096U) {
    tmp___5 = dcgettext((char const   *)((void *)0), "fifo", 5);
    return ((char const   *)tmp___5);
  }
  if ((st->st_mode & 61440U) == 40960U) {
    tmp___6 = dcgettext((char const   *)((void *)0), "symbolic link", 5);
    return ((char const   *)tmp___6);
  }
  if ((st->st_mode & 61440U) == 49152U) {
    tmp___7 = dcgettext((char const   *)((void *)0), "socket", 5);
    return ((char const   *)tmp___7);
  }
  if (st->st_mode - st->st_mode) {
    tmp___8 = dcgettext((char const   *)((void *)0), "message queue", 5);
    return ((char const   *)tmp___8);
  }
  if (st->st_mode - st->st_mode) {
    tmp___9 = dcgettext((char const   *)((void *)0), "semaphore", 5);
    return ((char const   *)tmp___9);
  }
  if (st->st_mode - st->st_mode) {
    tmp___10 = dcgettext((char const   *)((void *)0), "shared memory object", 5);
    return ((char const   *)tmp___10);
  }
  tmp___12 = dcgettext((char const   *)((void *)0), "weird file", 5);
  return ((char const   *)tmp___12);
}
}
void strmode(mode_t mode , char *str ) ;
void filemodestring(struct stat  const  *statp , char *str ) ;
static char ftypelet(mode_t bits ) 
{ 

  {
  if ((bits & 61440U) == 32768U) {
    return ((char )'-');
  }
  if ((bits & 61440U) == 16384U) {
    return ((char )'d');
  }
  if ((bits & 61440U) == 24576U) {
    return ((char )'b');
  }
  if ((bits & 61440U) == 8192U) {
    return ((char )'c');
  }
  if ((bits & 61440U) == 40960U) {
    return ((char )'l');
  }
  if ((bits & 61440U) == 4096U) {
    return ((char )'p');
  }
  if ((bits & 61440U) == 49152U) {
    return ((char )'s');
  }
  return ((char )'?');
}
}
void strmode(mode_t mode , char *str ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  *(str + 0) = ftypelet(mode);
  if (mode & 256U) {
    *(str + 1) = (char )'r';
  } else {
    *(str + 1) = (char )'-';
  }
  if (mode & 128U) {
    *(str + 2) = (char )'w';
  } else {
    *(str + 2) = (char )'-';
  }
  if (mode & 2048U) {
    if (mode & 64U) {
      tmp = 's';
    } else {
      tmp = 'S';
    }
    *(str + 3) = (char )tmp;
  } else {
    if (mode & 64U) {
      tmp___0 = 'x';
    } else {
      tmp___0 = '-';
    }
    *(str + 3) = (char )tmp___0;
  }
  if (mode & (unsigned int )(256 >> 3)) {
    *(str + 4) = (char )'r';
  } else {
    *(str + 4) = (char )'-';
  }
  if (mode & (unsigned int )(128 >> 3)) {
    *(str + 5) = (char )'w';
  } else {
    *(str + 5) = (char )'-';
  }
  if (mode & 1024U) {
    if (mode & (unsigned int )(64 >> 3)) {
      tmp___1 = 's';
    } else {
      tmp___1 = 'S';
    }
    *(str + 6) = (char )tmp___1;
  } else {
    if (mode & (unsigned int )(64 >> 3)) {
      tmp___2 = 'x';
    } else {
      tmp___2 = '-';
    }
    *(str + 6) = (char )tmp___2;
  }
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
    *(str + 7) = (char )'r';
  } else {
    *(str + 7) = (char )'-';
  }
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
    *(str + 8) = (char )'w';
  } else {
    *(str + 8) = (char )'-';
  }
  if (mode & 512U) {
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
      tmp___3 = 't';
    } else {
      tmp___3 = 'T';
    }
    *(str + 9) = (char )tmp___3;
  } else {
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
      tmp___4 = 'x';
    } else {
      tmp___4 = '-';
    }
    *(str + 9) = (char )tmp___4;
  }
  *(str + 10) = (char )' ';
  *(str + 11) = (char )'\000';
  return;
}
}
void filemodestring(struct stat  const  *statp , char *str ) 
{ 

  {
  strmode((mode_t )statp->st_mode, str);
  if (statp->st_mode - statp->st_mode) {
    *(str + 0) = (char )'F';
  } else
  if (statp->st_mode - statp->st_mode) {
    *(str + 0) = (char )'Q';
  } else
  if (statp->st_mode - statp->st_mode) {
    *(str + 0) = (char )'S';
  }
  return;
}
}
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ char *p ;
  char *tmp ;

  {
  tmp = mfile_name_concat(dir, abase, base_in_result);
  p = tmp;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    xalloc_die();
  }
  return (p);
}
}
static char const   *longest_relative_suffix(char const   *f ) 
{ 

  {
  f += 0;
  while ((int const   )*f == 47) {
    goto __Cont;
    __Cont: 
    f ++;
  }
  return (f);
}
}
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   *tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void __attribute__((__artificial__))  *tmp___5 ;
  int tmp___6 ;
  void __attribute__((__artificial__))  *tmp___7 ;

  {
  tmp = last_component(dir);
  dirbase = (char const   *)tmp;
  tmp___0 = base_len(dirbase);
  dirbaselen = tmp___0;
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  if (dirbaselen) {
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  needs_separator = (size_t )tmp___1;
  tmp___2 = longest_relative_suffix(abase);
  base = tmp___2;
  tmp___3 = strlen(base);
  baselen = tmp___3;
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
  p_concat = (char *)tmp___4;
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp___5 = mempcpy((void * __restrict  )p_concat, (void const   * __restrict  )dir,
                    dirlen);
  p = (char *)tmp___5;
  *p = (char )'/';
  p += needs_separator;
  if (base_in_result) {
    if ((int const   )*(abase + 0) == 47) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
    *base_in_result = p - tmp___6;
  }
  tmp___7 = mempcpy((void * __restrict  )p, (void const   * __restrict  )base, baselen);
  p = (char *)tmp___7;
  *p = (char )'\000';
  return (p_concat);
}
}
int filevercmp(char const   *s1 , char const   *s2 ) ;
static char const   *match_suffix(char const   **str ) 
{ char const   *match ;
  _Bool read_alpha ;
  int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
  match = (char const   *)((void *)0);
  read_alpha = (_Bool)0;
  while (*(*str)) {
    if (read_alpha) {
      read_alpha = (_Bool)0;
      __c = (int )*(*str);
      if ((__c & -33) >= 65) {
        if ((__c & -33) <= 90) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      if (! tmp) {
        if (126 != (int )*(*str)) {
          match = (char const   *)((void *)0);
        }
      }
    } else
    if (46 == (int )*(*str)) {
      read_alpha = (_Bool)1;
      if (! match) {
        match = *str;
      }
    } else {
      __c___0 = (int )*(*str);
      if (__c___0 >= 48) {
        if (__c___0 <= 57) {
          tmp___0 = 1;
        } else {
          goto _L;
        }
      } else
      _L: 
      if ((__c___0 & -33) >= 65) {
        if ((__c___0 & -33) <= 90) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      if (! tmp___0) {
        if (126 != (int )*(*str)) {
          match = (char const   *)((void *)0);
        }
      }
    }
    (*str) ++;
  }
  return (match);
}
}
__inline static int order(unsigned char c ) 
{ int __c ;
  int tmp ;
  int __c___0 ;
  int tmp___0 ;

  {
  __c___0 = (int )c;
  if (__c___0 >= 48) {
    if (__c___0 <= 57) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  if (tmp___0) {
    return (0);
  } else {
    __c = (int )c;
    if ((__c & -33) >= 65) {
      if ((__c & -33) <= 90) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    if (tmp) {
      return ((int )c);
    } else
    if ((int )c == 126) {
      return (-1);
    } else {
      return (((int )c + 255) + 1);
    }
  }
}
}
static int verrevcmp(char const   *s1 , size_t s1_len , char const   *s2 , size_t s2_len ) 
{ size_t s1_pos ;
  size_t s2_pos ;
  int first_diff ;
  int s1_c ;
  int tmp ;
  int tmp___0 ;
  int s2_c ;
  int tmp___1 ;
  int tmp___2 ;
  int __c ;
  int tmp___3 ;
  int __c___0 ;
  int tmp___4 ;
  int __c___1 ;
  int tmp___5 ;
  int __c___2 ;
  int tmp___6 ;
  int __c___3 ;
  int tmp___7 ;
  int __c___4 ;
  int tmp___8 ;

  {
  s1_pos = (size_t )0;
  s2_pos = (size_t )0;
  while (1) {
    if (! (s1_pos < s1_len)) {
      if (! (s2_pos < s2_len)) {
        break;
      }
    }
    first_diff = 0;
    while (1) {
      if (s1_pos < s1_len) {
        __c = (int )*(s1 + s1_pos);
        if (__c >= 48) {
          if (__c <= 57) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        if (tmp___3) {
          goto _L;
        }
      } else
      _L: 
      if (s2_pos < s2_len) {
        __c___0 = (int )*(s2 + s2_pos);
        if (__c___0 >= 48) {
          if (__c___0 <= 57) {
            tmp___4 = 1;
          } else {
            tmp___4 = 0;
          }
        } else {
          tmp___4 = 0;
        }
        if (tmp___4) {
          break;
        }
      } else {
        break;
      }
      if (s1_pos == s1_len) {
        tmp___0 = 0;
      } else {
        tmp = order((unsigned char )*(s1 + s1_pos));
        tmp___0 = tmp;
      }
      s1_c = tmp___0;
      if (s2_pos == s2_len) {
        tmp___2 = 0;
      } else {
        tmp___1 = order((unsigned char )*(s2 + s2_pos));
        tmp___2 = tmp___1;
      }
      s2_c = tmp___2;
      if (s1_c != s2_c) {
        return (s1_c - s2_c);
      }
      s1_pos ++;
      s2_pos ++;
    }
    while ((int const   )*(s1 + s1_pos) == 48) {
      s1_pos ++;
    }
    while ((int const   )*(s2 + s2_pos) == 48) {
      s2_pos ++;
    }
    while (1) {
      __c___1 = (int )*(s1 + s1_pos);
      if (__c___1 >= 48) {
        if (__c___1 <= 57) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
      } else {
        tmp___5 = 0;
      }
      if (tmp___5) {
        __c___2 = (int )*(s2 + s2_pos);
        if (__c___2 >= 48) {
          if (__c___2 <= 57) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (! tmp___6) {
          break;
        }
      } else {
        break;
      }
      if (! first_diff) {
        first_diff = (int )((int const   )*(s1 + s1_pos) - (int const   )*(s2 + s2_pos));
      }
      s1_pos ++;
      s2_pos ++;
    }
    __c___3 = (int )*(s1 + s1_pos);
    if (__c___3 >= 48) {
      if (__c___3 <= 57) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    if (tmp___7) {
      return (1);
    }
    __c___4 = (int )*(s2 + s2_pos);
    if (__c___4 >= 48) {
      if (__c___4 <= 57) {
        tmp___8 = 1;
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
    if (tmp___8) {
      return (-1);
    }
    if (first_diff) {
      return (first_diff);
    }
  }
  return (0);
}
}
int filevercmp(char const   *s1 , char const   *s2 ) 
{ char const   *s1_pos ;
  char const   *s2_pos ;
  char const   *s1_suffix ;
  char const   *s2_suffix ;
  size_t s1_len ;
  size_t s2_len ;
  int result ;
  int simple_cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___49 ;

  {
  if (0) {
    __s1_len = __builtin_strlen(s1);
    __s2_len = __builtin_strlen(s2);
    if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
      goto _L___0;
    } else
    if (__s1_len >= 4UL) {
      _L___0: 
      if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
        tmp___5 = 1;
      } else
      if (__s2_len >= 4UL) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 0;
    }
    if (tmp___5) {
      tmp___0 = __builtin_strcmp(s1, s2);
      tmp___4 = tmp___0;
    } else {
      tmp___3 = __builtin_strcmp(s1, s2);
      tmp___4 = tmp___3;
    }
  } else {
    tmp___3 = __builtin_strcmp(s1, s2);
    tmp___4 = tmp___3;
  }
  simple_cmp = tmp___4;
  if (simple_cmp == 0) {
    return (0);
  }
  if (! *s1) {
    return (-1);
  }
  if (! *s2) {
    return (1);
  }
  if (0) {
    __s1_len___0 = __builtin_strlen(".");
    __s2_len___0 = __builtin_strlen(s1);
    if (! ((size_t )((void const   *)("." + 1)) - (size_t )((void const   *)".") == 1UL)) {
      goto _L___2;
    } else
    if (__s1_len___0 >= 4UL) {
      _L___2: 
      if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
        tmp___12 = 1;
      } else
      if (__s2_len___0 >= 4UL) {
        tmp___12 = 1;
      } else {
        tmp___12 = 0;
      }
    } else {
      tmp___12 = 0;
    }
    if (tmp___12) {
      tmp___7 = __builtin_strcmp(".", s1);
      tmp___11 = tmp___7;
    } else {
      tmp___10 = __builtin_strcmp(".", s1);
      tmp___11 = tmp___10;
    }
  } else {
    tmp___10 = __builtin_strcmp(".", s1);
    tmp___11 = tmp___10;
  }
  if (0 == tmp___11) {
    return (-1);
  }
  if (0) {
    __s1_len___1 = __builtin_strlen(".");
    __s2_len___1 = __builtin_strlen(s2);
    if (! ((size_t )((void const   *)("." + 1)) - (size_t )((void const   *)".") == 1UL)) {
      goto _L___4;
    } else
    if (__s1_len___1 >= 4UL) {
      _L___4: 
      if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
        tmp___19 = 1;
      } else
      if (__s2_len___1 >= 4UL) {
        tmp___19 = 1;
      } else {
        tmp___19 = 0;
      }
    } else {
      tmp___19 = 0;
    }
    if (tmp___19) {
      tmp___14 = __builtin_strcmp(".", s2);
      tmp___18 = tmp___14;
    } else {
      tmp___17 = __builtin_strcmp(".", s2);
      tmp___18 = tmp___17;
    }
  } else {
    tmp___17 = __builtin_strcmp(".", s2);
    tmp___18 = tmp___17;
  }
  if (0 == tmp___18) {
    return (1);
  }
  if (0) {
    __s1_len___2 = __builtin_strlen("..");
    __s2_len___2 = __builtin_strlen(s1);
    if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
      goto _L___6;
    } else
    if (__s1_len___2 >= 4UL) {
      _L___6: 
      if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
        tmp___26 = 1;
      } else
      if (__s2_len___2 >= 4UL) {
        tmp___26 = 1;
      } else {
        tmp___26 = 0;
      }
    } else {
      tmp___26 = 0;
    }
    if (tmp___26) {
      tmp___21 = __builtin_strcmp("..", s1);
      tmp___25 = tmp___21;
    } else {
      tmp___24 = __builtin_strcmp("..", s1);
      tmp___25 = tmp___24;
    }
  } else {
    tmp___24 = __builtin_strcmp("..", s1);
    tmp___25 = tmp___24;
  }
  if (0 == tmp___25) {
    return (-1);
  }
  if (0) {
    __s1_len___3 = __builtin_strlen("..");
    __s2_len___3 = __builtin_strlen(s2);
    if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
      goto _L___8;
    } else
    if (__s1_len___3 >= 4UL) {
      _L___8: 
      if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
        tmp___33 = 1;
      } else
      if (__s2_len___3 >= 4UL) {
        tmp___33 = 1;
      } else {
        tmp___33 = 0;
      }
    } else {
      tmp___33 = 0;
    }
    if (tmp___33) {
      tmp___28 = __builtin_strcmp("..", s2);
      tmp___32 = tmp___28;
    } else {
      tmp___31 = __builtin_strcmp("..", s2);
      tmp___32 = tmp___31;
    }
  } else {
    tmp___31 = __builtin_strcmp("..", s2);
    tmp___32 = tmp___31;
  }
  if (0 == tmp___32) {
    return (1);
  }
  if ((int const   )*s1 == 46) {
    if ((int const   )*s2 != 46) {
      return (-1);
    }
  }
  if ((int const   )*s1 != 46) {
    if ((int const   )*s2 == 46) {
      return (1);
    }
  }
  if ((int const   )*s1 == 46) {
    if ((int const   )*s2 == 46) {
      s1 ++;
      s2 ++;
    }
  }
  s1_pos = s1;
  s2_pos = s2;
  s1_suffix = match_suffix(& s1_pos);
  s2_suffix = match_suffix(& s2_pos);
  if (s1_suffix) {
    tmp___34 = s1_suffix;
  } else {
    tmp___34 = s1_pos;
  }
  s1_len = (size_t )(tmp___34 - s1);
  if (s2_suffix) {
    tmp___35 = s2_suffix;
  } else {
    tmp___35 = s2_pos;
  }
  s2_len = (size_t )(tmp___35 - s2);
  if (s1_suffix) {
    goto _L___11;
  } else
  if (s2_suffix) {
    _L___11: 
    if (s1_len == s2_len) {
      if (0) {
        if (0) {
          __s1_len___4 = __builtin_strlen(s1);
          __s2_len___4 = __builtin_strlen(s2);
          if (! ((size_t )((void const   *)(s1 + 1)) - (size_t )((void const   *)s1) == 1UL)) {
            goto _L___10;
          } else
          if (__s1_len___4 >= 4UL) {
            _L___10: 
            if (! ((size_t )((void const   *)(s2 + 1)) - (size_t )((void const   *)s2) == 1UL)) {
              tmp___44 = 1;
            } else
            if (__s2_len___4 >= 4UL) {
              tmp___44 = 1;
            } else {
              tmp___44 = 0;
            }
          } else {
            tmp___44 = 0;
          }
          if (tmp___44) {
            tmp___39 = __builtin_strcmp(s1, s2);
            tmp___43 = tmp___39;
          } else {
            tmp___42 = __builtin_strcmp(s1, s2);
            tmp___43 = tmp___42;
          }
        } else {
          tmp___42 = __builtin_strcmp(s1, s2);
          tmp___43 = tmp___42;
        }
        tmp___46 = tmp___43;
      } else {
        tmp___45 = strncmp(s1, s2, s1_len);
        tmp___46 = tmp___45;
      }
      if (0 == tmp___46) {
        s1_len = (size_t )(s1_pos - s1);
        s2_len = (size_t )(s2_pos - s2);
      }
    }
  }
  result = verrevcmp(s1, s1_len, s2, s2_len);
  if (result == 0) {
    tmp___49 = simple_cmp;
  } else {
    tmp___49 = result;
  }
  return (tmp___49);
}
}
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes )  __attribute__((__warn_unused_result__)) ;
FILE *fopen_safer(char const   *file , char const   *mode ) ;
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  tmp = fopen((char const   * __restrict  )file, (char const   * __restrict  )mode);
  fp = tmp;
  if (fp) {
    tmp___0 = fileno(fp);
    fd = tmp___0;
    if (0 <= fd) {
      if (fd <= 2) {
        tmp___1 = dup_safer(fd);
        f = tmp___1;
        if (f < 0) {
          tmp___2 = __errno_location();
          e = *tmp___2;
          rpl_fclose(fp);
          tmp___3 = __errno_location();
          *tmp___3 = e;
          return ((FILE *)((void *)0));
        }
        tmp___6 = rpl_fclose(fp);
        if (tmp___6 != 0) {
          goto _L;
        } else {
          fp = fdopen(f, mode);
          if (! fp) {
            _L: 
            tmp___4 = __errno_location();
            e___0 = *tmp___4;
            close(f);
            tmp___5 = __errno_location();
            *tmp___5 = e___0;
            return ((FILE *)((void *)0));
          }
        }
      }
    }
  }
  return (fp);
}
}
extern int fputc(int __c , FILE *__stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
__inline static size_t __attribute__((__nonnull__(1,4)))  rpl_fwrite(void const   *ptr ,
                                                                     size_t s , size_t n ,
                                                                     FILE *stream ) 
{ size_t r ;
  size_t tmp ;

  {
  tmp = fwrite((void const   * __restrict  )ptr, s, n, (FILE * __restrict  )stream);
  r = tmp;
  return ((size_t __attribute__((__nonnull__(1,4)))  )r);
}
}
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
  while (1) {
    tmp___1 = len;
    len --;
    if (! (tmp___1 > 0UL)) {
      break;
    }
    if (sizeof((unsigned char )*src) > 1UL) {
      __res = tolower((int )((unsigned char )*src));
    } else {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*src));
    }
    fputc(__res, fp);
    src ++;
  }
  return;
}
}
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
  while (1) {
    tmp___1 = len;
    len --;
    if (! (tmp___1 > 0UL)) {
      break;
    }
    if (sizeof((unsigned char )*src) > 1UL) {
      __res = toupper((int )((unsigned char )*src));
    } else {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*src));
    }
    fputc(__res, fp);
    src ++;
  }
  return;
}
}
__inline static int iso_week_days(int yday , int wday ) 
{ int big_enough_multiple_of_7 ;

  {
  big_enough_multiple_of_7 = 378;
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
static size_t strftime_case_(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                             int ut , int ns ) 
{ size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  size_t _i___5 ;
  size_t _i___6 ;
  size_t __attribute__((__nonnull__(1,4)))  __x ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___13 ;
  int century ;
  int tmp___14 ;
  int tmp___15 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___16 ;
  size_t _incr___3 ;
  size_t tmp___17 ;
  size_t _delta___3 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___18 ;
  size_t _incr___4 ;
  size_t tmp___19 ;
  size_t _delta___4 ;
  size_t _i___10 ;
  size_t _i___11 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___20 ;
  size_t _incr___5 ;
  size_t tmp___21 ;
  size_t _delta___5 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___22 ;
  size_t _incr___6 ;
  size_t tmp___23 ;
  size_t _delta___6 ;
  size_t _i___15 ;
  size_t _i___16 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___24 ;
  size_t _incr___7 ;
  size_t tmp___25 ;
  size_t _delta___7 ;
  size_t _i___17 ;
  size_t _i___18 ;
  size_t __attribute__((__nonnull__(1,4)))  __x___0 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___26 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___27 ;
  size_t _incr___8 ;
  size_t tmp___28 ;
  size_t _delta___8 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___29 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___30 ;
  size_t _incr___9 ;
  size_t tmp___31 ;
  size_t _delta___9 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year___0 ;
  int tmp___32 ;
  int year_adjust ;
  int days ;
  int tmp___33 ;
  int tmp___34 ;
  int d___0 ;
  int tmp___35 ;
  int tmp___36 ;
  int yy ;
  int tmp___37 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___38 ;
  size_t _w___10 ;
  int tmp___39 ;
  size_t _incr___10 ;
  size_t tmp___40 ;
  size_t _delta___10 ;
  size_t _i___23 ;
  size_t _i___24 ;
  size_t __attribute__((__nonnull__(1,4)))  __x___1 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___41 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___42 ;
  size_t _incr___11 ;
  size_t tmp___43 ;
  size_t _delta___11 ;
  size_t _i___25 ;
  size_t _i___26 ;
  size_t __attribute__((__nonnull__(1,4)))  __x___2 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___44 ;

  {
  maxsize = (size_t )-1;
  hour12 = (int )tp->tm_hour;
  i = (size_t )0;
  p = s;
  zone = (char const   *)((void *)0);
  zone = (char const   *)tp->tm_zone;
  if (hour12 > 12) {
    hour12 -= 12;
  } else
  if (hour12 == 0) {
    hour12 = 12;
  }
  f = format;
  while ((int const   )*f != 0) {
    pad = 0;
    digits = 0;
    width = -1;
    to_lowcase = (_Bool)0;
    to_uppcase = upcase;
    change_case = (_Bool)0;
    if ((int const   )*f != 37) {
      while (1) {
        _n = (size_t )1;
        if (width < 0) {
          tmp = 0;
        } else {
          tmp = width;
        }
        _w = (size_t )tmp;
        if (_n < _w) {
          tmp___0 = _w;
        } else {
          tmp___0 = _n;
        }
        _incr = tmp___0;
        if (_incr >= maxsize - i) {
          return ((size_t )0);
        }
        if (p) {
          if (digits == 0) {
            if (_n < _w) {
              _delta = (size_t )width - _n;
              if (pad == 48) {
                while (1) {
                  _i = (size_t )0;
                  while (_i < _delta) {
                    fputc('0', p);
                    _i ++;
                  }
                  break;
                }
              } else {
                while (1) {
                  _i___0 = (size_t )0;
                  while (_i___0 < _delta) {
                    fputc(' ', p);
                    _i___0 ++;
                  }
                  break;
                }
              }
            }
          }
          fputc((int )*f, p);
        }
        i += _incr;
        break;
      }
      goto __Cont;
    }
    while (1) {
      f ++;
      switch ((int )*f) {
      case 95: 
      case 45: 
      case 48: 
      pad = (int )*f;
      continue;
      case 94: 
      to_uppcase = (_Bool)1;
      continue;
      case 35: 
      change_case = (_Bool)1;
      continue;
      default: 
      break;
      }
      break;
    }
    if ((unsigned int )*f - 48U <= 9U) {
      width = 0;
      while (1) {
        if (width > 214748364) {
          width = 2147483647;
        } else
        if (width == 214748364) {
          if ((int const   )*f - 48 > 7) {
            width = 2147483647;
          } else {
            width *= 10;
            width += (int )((int const   )*f - 48);
          }
        } else {
          width *= 10;
          width += (int )((int const   )*f - 48);
        }
        f ++;
        if (! ((unsigned int )*f - 48U <= 9U)) {
          break;
        }
      }
    }
    switch ((int )*f) {
    case 69: 
    case 79: 
    tmp___1 = f;
    f ++;
    modifier = (int )*tmp___1;
    break;
    default: 
    modifier = 0;
    break;
    }
    format_char = (int )*f;
    switch (format_char) {
    case 37: 
    if (modifier != 0) {
      goto bad_format;
    }
    while (1) {
      _n___0 = (size_t )1;
      if (width < 0) {
        tmp___2 = 0;
      } else {
        tmp___2 = width;
      }
      _w___0 = (size_t )tmp___2;
      if (_n___0 < _w___0) {
        tmp___3 = _w___0;
      } else {
        tmp___3 = _n___0;
      }
      _incr___0 = tmp___3;
      if (_incr___0 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___0 < _w___0) {
            _delta___0 = (size_t )width - _n___0;
            if (pad == 48) {
              while (1) {
                _i___1 = (size_t )0;
                while (_i___1 < _delta___0) {
                  fputc('0', p);
                  _i___1 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___2 = (size_t )0;
                while (_i___2 < _delta___0) {
                  fputc(' ', p);
                  _i___2 ++;
                }
                break;
              }
            }
          }
        }
        fputc((int )*f, p);
      }
      i += _incr___0;
      break;
    }
    break;
    case 97: 
    if (modifier != 0) {
      goto bad_format;
    }
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    goto underlying_strftime;
    case 65: 
    if (modifier != 0) {
      goto bad_format;
    }
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    goto underlying_strftime;
    case 98: 
    case 104: 
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    if (modifier != 0) {
      goto bad_format;
    }
    goto underlying_strftime;
    case 66: 
    if (modifier != 0) {
      goto bad_format;
    }
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    goto underlying_strftime;
    case 99: 
    if (modifier == 79) {
      goto bad_format;
    }
    goto underlying_strftime;
    subformat: 
    tmp___4 = strftime_case_(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut, ns);
    len = tmp___4;
    while (1) {
      _n___1 = len;
      if (width < 0) {
        tmp___5 = 0;
      } else {
        tmp___5 = width;
      }
      _w___1 = (size_t )tmp___5;
      if (_n___1 < _w___1) {
        tmp___6 = _w___1;
      } else {
        tmp___6 = _n___1;
      }
      _incr___1 = tmp___6;
      if (_incr___1 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___1 < _w___1) {
            _delta___1 = (size_t )width - _n___1;
            if (pad == 48) {
              while (1) {
                _i___3 = (size_t )0;
                while (_i___3 < _delta___1) {
                  fputc('0', p);
                  _i___3 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___4 = (size_t )0;
                while (_i___4 < _delta___1) {
                  fputc(' ', p);
                  _i___4 ++;
                }
                break;
              }
            }
          }
        }
        strftime_case_(to_uppcase, p, subfmt, tp, ut, ns);
      }
      i += _incr___1;
      break;
    }
    break;
    underlying_strftime: 
    u = ufmt;
    tmp___7 = u;
    u ++;
    *tmp___7 = (char )' ';
    tmp___8 = u;
    u ++;
    *tmp___8 = (char )'%';
    if (modifier != 0) {
      tmp___9 = u;
      u ++;
      *tmp___9 = (char )modifier;
    }
    tmp___10 = u;
    u ++;
    *tmp___10 = (char )format_char;
    *u = (char )'\000';
    len___0 = strftime((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )(ufmt),
                       (struct tm  const  * __restrict  )tp);
    if (len___0 != 0UL) {
      while (1) {
        _n___2 = len___0 - 1UL;
        if (width < 0) {
          tmp___11 = 0;
        } else {
          tmp___11 = width;
        }
        _w___2 = (size_t )tmp___11;
        if (_n___2 < _w___2) {
          tmp___12 = _w___2;
        } else {
          tmp___12 = _n___2;
        }
        _incr___2 = tmp___12;
        if (_incr___2 >= maxsize - i) {
          return ((size_t )0);
        }
        if (p) {
          if (digits == 0) {
            if (_n___2 < _w___2) {
              _delta___2 = (size_t )width - _n___2;
              if (pad == 48) {
                while (1) {
                  _i___5 = (size_t )0;
                  while (_i___5 < _delta___2) {
                    fputc('0', p);
                    _i___5 ++;
                  }
                  break;
                }
              } else {
                while (1) {
                  _i___6 = (size_t )0;
                  while (_i___6 < _delta___2) {
                    fputc(' ', p);
                    _i___6 ++;
                  }
                  break;
                }
              }
            }
          }
          while (1) {
            if (to_lowcase) {
              fwrite_lowcase(p, (char const   *)(ubuf + 1), _n___2);
            } else
            if (to_uppcase) {
              fwrite_uppcase(p, (char const   *)(ubuf + 1), _n___2);
            } else {
              tmp___13 = rpl_fwrite((void const   *)(ubuf + 1), _n___2, (size_t )1,
                                    p);
              __x = tmp___13;
            }
            break;
          }
        }
        i += _incr___2;
        break;
      }
    }
    break;
    case 67: 
    if (modifier == 79) {
      goto bad_format;
    }
    if (modifier == 69) {
      goto underlying_strftime;
    }
    century = (int )(tp->tm_year / 100 + 19);
    if (tp->tm_year % 100 < 0) {
      if (0 < century) {
        tmp___14 = 1;
      } else {
        tmp___14 = 0;
      }
    } else {
      tmp___14 = 0;
    }
    century -= tmp___14;
    digits = 2;
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )century;
    goto do_signed_number;
    case 120: 
    if (modifier == 79) {
      goto bad_format;
    }
    goto underlying_strftime;
    case 68: 
    if (modifier != 0) {
      goto bad_format;
    }
    subfmt = "%m/%d/%y";
    goto subformat;
    case 100: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_mday;
    goto do_number;
    case 101: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_mday;
    goto do_number_spacepad;
    do_tz_offset: 
    always_output_a_sign = (_Bool)1;
    goto do_number_body;
    do_number_spacepad: 
    if (pad != 48) {
      if (pad != 45) {
        pad = '_';
      }
    }
    do_number: 
    negative_number = (_Bool )(number_value < 0);
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
    always_output_a_sign = (_Bool)0;
    tz_colon_mask = 0;
    do_number_body: 
    if (modifier == 79) {
      if (! negative_number) {
        goto underlying_strftime;
      }
    }
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    if (negative_number) {
      u_number_value = - u_number_value;
    }
    while (1) {
      if (tz_colon_mask & 1) {
        bufp --;
        *bufp = (char )':';
      }
      tz_colon_mask >>= 1;
      bufp --;
      *bufp = (char )(u_number_value % 10U + 48U);
      u_number_value /= 10U;
      if (! (u_number_value != 0U)) {
        if (! (tz_colon_mask != 0)) {
          break;
        }
      }
    }
    do_number_sign_and_padding: 
    if (digits < width) {
      digits = width;
    }
    if (negative_number) {
      sign_char = (char )'-';
    } else {
      if (always_output_a_sign) {
        tmp___15 = '+';
      } else {
        tmp___15 = 0;
      }
      sign_char = (char )tmp___15;
    }
    if (pad == 45) {
      if (sign_char) {
        while (1) {
          _n___3 = (size_t )1;
          if (width < 0) {
            tmp___16 = 0;
          } else {
            tmp___16 = width;
          }
          _w___3 = (size_t )tmp___16;
          if (_n___3 < _w___3) {
            tmp___17 = _w___3;
          } else {
            tmp___17 = _n___3;
          }
          _incr___3 = tmp___17;
          if (_incr___3 >= maxsize - i) {
            return ((size_t )0);
          }
          if (p) {
            if (digits == 0) {
              if (_n___3 < _w___3) {
                _delta___3 = (size_t )width - _n___3;
                if (pad == 48) {
                  while (1) {
                    _i___7 = (size_t )0;
                    while (_i___7 < _delta___3) {
                      fputc('0', p);
                      _i___7 ++;
                    }
                    break;
                  }
                } else {
                  while (1) {
                    _i___8 = (size_t )0;
                    while (_i___8 < _delta___3) {
                      fputc(' ', p);
                      _i___8 ++;
                    }
                    break;
                  }
                }
              }
            }
            fputc((int )sign_char, p);
          }
          i += _incr___3;
          break;
        }
      }
    } else {
      padding = (digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - ! (! sign_char);
      if (padding > 0) {
        if (pad == 95) {
          if ((size_t )padding >= maxsize - i) {
            return ((size_t )0);
          }
          if (p) {
            while (1) {
              _i___9 = (size_t )0;
              while (_i___9 < (size_t )padding) {
                fputc(' ', p);
                _i___9 ++;
              }
              break;
            }
          }
          i += (size_t )padding;
          if (width > padding) {
            width -= padding;
          } else {
            width = 0;
          }
          if (sign_char) {
            while (1) {
              _n___4 = (size_t )1;
              if (width < 0) {
                tmp___18 = 0;
              } else {
                tmp___18 = width;
              }
              _w___4 = (size_t )tmp___18;
              if (_n___4 < _w___4) {
                tmp___19 = _w___4;
              } else {
                tmp___19 = _n___4;
              }
              _incr___4 = tmp___19;
              if (_incr___4 >= maxsize - i) {
                return ((size_t )0);
              }
              if (p) {
                if (digits == 0) {
                  if (_n___4 < _w___4) {
                    _delta___4 = (size_t )width - _n___4;
                    if (pad == 48) {
                      while (1) {
                        _i___10 = (size_t )0;
                        while (_i___10 < _delta___4) {
                          fputc('0', p);
                          _i___10 ++;
                        }
                        break;
                      }
                    } else {
                      while (1) {
                        _i___11 = (size_t )0;
                        while (_i___11 < _delta___4) {
                          fputc(' ', p);
                          _i___11 ++;
                        }
                        break;
                      }
                    }
                  }
                }
                fputc((int )sign_char, p);
              }
              i += _incr___4;
              break;
            }
          }
        } else {
          if ((size_t )digits >= maxsize - i) {
            return ((size_t )0);
          }
          if (sign_char) {
            while (1) {
              _n___5 = (size_t )1;
              if (width < 0) {
                tmp___20 = 0;
              } else {
                tmp___20 = width;
              }
              _w___5 = (size_t )tmp___20;
              if (_n___5 < _w___5) {
                tmp___21 = _w___5;
              } else {
                tmp___21 = _n___5;
              }
              _incr___5 = tmp___21;
              if (_incr___5 >= maxsize - i) {
                return ((size_t )0);
              }
              if (p) {
                if (digits == 0) {
                  if (_n___5 < _w___5) {
                    _delta___5 = (size_t )width - _n___5;
                    if (pad == 48) {
                      while (1) {
                        _i___12 = (size_t )0;
                        while (_i___12 < _delta___5) {
                          fputc('0', p);
                          _i___12 ++;
                        }
                        break;
                      }
                    } else {
                      while (1) {
                        _i___13 = (size_t )0;
                        while (_i___13 < _delta___5) {
                          fputc(' ', p);
                          _i___13 ++;
                        }
                        break;
                      }
                    }
                  }
                }
                fputc((int )sign_char, p);
              }
              i += _incr___5;
              break;
            }
          }
          if (p) {
            while (1) {
              _i___14 = (size_t )0;
              while (_i___14 < (size_t )padding) {
                fputc('0', p);
                _i___14 ++;
              }
              break;
            }
          }
          i += (size_t )padding;
          width = 0;
        }
      } else
      if (sign_char) {
        while (1) {
          _n___6 = (size_t )1;
          if (width < 0) {
            tmp___22 = 0;
          } else {
            tmp___22 = width;
          }
          _w___6 = (size_t )tmp___22;
          if (_n___6 < _w___6) {
            tmp___23 = _w___6;
          } else {
            tmp___23 = _n___6;
          }
          _incr___6 = tmp___23;
          if (_incr___6 >= maxsize - i) {
            return ((size_t )0);
          }
          if (p) {
            if (digits == 0) {
              if (_n___6 < _w___6) {
                _delta___6 = (size_t )width - _n___6;
                if (pad == 48) {
                  while (1) {
                    _i___15 = (size_t )0;
                    while (_i___15 < _delta___6) {
                      fputc('0', p);
                      _i___15 ++;
                    }
                    break;
                  }
                } else {
                  while (1) {
                    _i___16 = (size_t )0;
                    while (_i___16 < _delta___6) {
                      fputc(' ', p);
                      _i___16 ++;
                    }
                    break;
                  }
                }
              }
            }
            fputc((int )sign_char, p);
          }
          i += _incr___6;
          break;
        }
      }
    }
    while (1) {
      _n___7 = (size_t )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
      if (width < 0) {
        tmp___24 = 0;
      } else {
        tmp___24 = width;
      }
      _w___7 = (size_t )tmp___24;
      if (_n___7 < _w___7) {
        tmp___25 = _w___7;
      } else {
        tmp___25 = _n___7;
      }
      _incr___7 = tmp___25;
      if (_incr___7 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___7 < _w___7) {
            _delta___7 = (size_t )width - _n___7;
            if (pad == 48) {
              while (1) {
                _i___17 = (size_t )0;
                while (_i___17 < _delta___7) {
                  fputc('0', p);
                  _i___17 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___18 = (size_t )0;
                while (_i___18 < _delta___7) {
                  fputc(' ', p);
                  _i___18 ++;
                }
                break;
              }
            }
          }
        }
        while (1) {
          if (to_lowcase) {
            fwrite_lowcase(p, (char const   *)bufp, _n___7);
          } else
          if (to_uppcase) {
            fwrite_uppcase(p, (char const   *)bufp, _n___7);
          } else {
            tmp___26 = rpl_fwrite((void const   *)bufp, _n___7, (size_t )1, p);
            __x___0 = tmp___26;
          }
          break;
        }
      }
      i += _incr___7;
      break;
    }
    break;
    case 70: 
    if (modifier != 0) {
      goto bad_format;
    }
    subfmt = "%Y-%m-%d";
    goto subformat;
    case 72: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_hour;
    goto do_number;
    case 73: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = hour12;
    goto do_number;
    case 107: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_hour;
    goto do_number_spacepad;
    case 108: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = hour12;
    goto do_number_spacepad;
    case 106: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 3;
    negative_number = (_Bool )(tp->tm_yday < -1);
    u_number_value = (unsigned int )tp->tm_yday + 1U;
    goto do_signed_number;
    case 77: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_min;
    goto do_number;
    case 109: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    negative_number = (_Bool )(tp->tm_mon < -1);
    u_number_value = (unsigned int )tp->tm_mon + 1U;
    goto do_signed_number;
    case 78: 
    if (modifier == 69) {
      goto bad_format;
    }
    number_value = ns;
    if (width == -1) {
      width = 9;
    } else {
      j = width;
      while (j < 9) {
        number_value /= 10;
        j ++;
      }
    }
    digits = width;
    number_value = number_value;
    goto do_number;
    case 110: 
    while (1) {
      _n___8 = (size_t )1;
      if (width < 0) {
        tmp___27 = 0;
      } else {
        tmp___27 = width;
      }
      _w___8 = (size_t )tmp___27;
      if (_n___8 < _w___8) {
        tmp___28 = _w___8;
      } else {
        tmp___28 = _n___8;
      }
      _incr___8 = tmp___28;
      if (_incr___8 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___8 < _w___8) {
            _delta___8 = (size_t )width - _n___8;
            if (pad == 48) {
              while (1) {
                _i___19 = (size_t )0;
                while (_i___19 < _delta___8) {
                  fputc('0', p);
                  _i___19 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___20 = (size_t )0;
                while (_i___20 < _delta___8) {
                  fputc(' ', p);
                  _i___20 ++;
                }
                break;
              }
            }
          }
        }
        fputc('\n', p);
      }
      i += _incr___8;
      break;
    }
    break;
    case 80: 
    to_lowcase = (_Bool)1;
    format_char = 'p';
    case 112: 
    if (change_case) {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
    }
    goto underlying_strftime;
    case 82: 
    subfmt = "%H:%M";
    goto subformat;
    case 114: 
    goto underlying_strftime;
    case 83: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_sec;
    goto do_number;
    case 115: 
    ltm = (struct tm )*tp;
    t = mktime(& ltm);
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    negative_number = (_Bool )(t < 0L);
    while (1) {
      d = (int )(t % 10L);
      t /= 10L;
      bufp --;
      if (negative_number) {
        tmp___29 = - d;
      } else {
        tmp___29 = d;
      }
      *bufp = (char )(tmp___29 + 48);
      if (! (t != 0L)) {
        break;
      }
    }
    digits = 1;
    always_output_a_sign = (_Bool)0;
    goto do_number_sign_and_padding;
    case 88: 
    if (modifier == 79) {
      goto bad_format;
    }
    goto underlying_strftime;
    case 84: 
    subfmt = "%H:%M:%S";
    goto subformat;
    case 116: 
    while (1) {
      _n___9 = (size_t )1;
      if (width < 0) {
        tmp___30 = 0;
      } else {
        tmp___30 = width;
      }
      _w___9 = (size_t )tmp___30;
      if (_n___9 < _w___9) {
        tmp___31 = _w___9;
      } else {
        tmp___31 = _n___9;
      }
      _incr___9 = tmp___31;
      if (_incr___9 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___9 < _w___9) {
            _delta___9 = (size_t )width - _n___9;
            if (pad == 48) {
              while (1) {
                _i___21 = (size_t )0;
                while (_i___21 < _delta___9) {
                  fputc('0', p);
                  _i___21 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___22 = (size_t )0;
                while (_i___22 < _delta___9) {
                  fputc(' ', p);
                  _i___22 ++;
                }
                break;
              }
            }
          }
        }
        fputc('\t', p);
      }
      i += _incr___9;
      break;
    }
    break;
    case 117: 
    digits = 1;
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
    goto do_number;
    case 85: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
    goto do_number;
    case 86: 
    case 103: 
    case 71: 
    if (modifier == 69) {
      goto bad_format;
    }
    if (tp->tm_year < 0) {
      tmp___32 = 300;
    } else {
      tmp___32 = -100;
    }
    year___0 = (int )(tp->tm_year + (int const   )tmp___32);
    year_adjust = 0;
    tmp___33 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
    days = tmp___33;
    if (days < 0) {
      year_adjust = -1;
      if ((year___0 - 1) % 4 == 0) {
        if ((year___0 - 1) % 100 != 0) {
          tmp___34 = 1;
        } else
        if ((year___0 - 1) % 400 == 0) {
          tmp___34 = 1;
        } else {
          tmp___34 = 0;
        }
      } else {
        tmp___34 = 0;
      }
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___34)), (int )tp->tm_wday);
    } else {
      if (year___0 % 4 == 0) {
        if (year___0 % 100 != 0) {
          tmp___35 = 1;
        } else
        if (year___0 % 400 == 0) {
          tmp___35 = 1;
        } else {
          tmp___35 = 0;
        }
      } else {
        tmp___35 = 0;
      }
      tmp___36 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___35)),
                               (int )tp->tm_wday);
      d___0 = tmp___36;
      if (0 <= d___0) {
        year_adjust = 1;
        days = d___0;
      }
    }
    switch ((int )*f) {
    case 103: 
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
    digits = 2;
    if (0 <= yy) {
      number_value = yy;
    } else {
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
        tmp___37 = - yy;
      } else {
        tmp___37 = yy + 100;
      }
      number_value = tmp___37;
    }
    goto do_number;
    case 71: 
    digits = 4;
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
    goto do_signed_number;
    default: 
    digits = 2;
    number_value = days / 7 + 1;
    goto do_number;
    }
    case 87: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
    goto do_number;
    case 119: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 1;
    number_value = (int )tp->tm_wday;
    goto do_number;
    case 89: 
    if (modifier == 69) {
      goto underlying_strftime;
    }
    if (modifier == 79) {
      goto bad_format;
    } else {
      digits = 4;
    }
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )tp->tm_year + 1900U;
    goto do_signed_number;
    case 121: 
    if (modifier == 69) {
      goto underlying_strftime;
    }
    yy___0 = (int )(tp->tm_year % 100);
    if (yy___0 < 0) {
      if (tp->tm_year < -1900) {
        yy___0 = - yy___0;
      } else {
        yy___0 += 100;
      }
    }
    digits = 2;
    number_value = yy___0;
    goto do_number;
    case 90: 
    if (change_case) {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
    }
    if (! zone) {
      zone = "";
    }
    while (1) {
      tmp___38 = strlen(zone);
      _n___10 = tmp___38;
      if (width < 0) {
        tmp___39 = 0;
      } else {
        tmp___39 = width;
      }
      _w___10 = (size_t )tmp___39;
      if (_n___10 < _w___10) {
        tmp___40 = _w___10;
      } else {
        tmp___40 = _n___10;
      }
      _incr___10 = tmp___40;
      if (_incr___10 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___10 < _w___10) {
            _delta___10 = (size_t )width - _n___10;
            if (pad == 48) {
              while (1) {
                _i___23 = (size_t )0;
                while (_i___23 < _delta___10) {
                  fputc('0', p);
                  _i___23 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___24 = (size_t )0;
                while (_i___24 < _delta___10) {
                  fputc(' ', p);
                  _i___24 ++;
                }
                break;
              }
            }
          }
        }
        while (1) {
          if (to_lowcase) {
            fwrite_lowcase(p, zone, _n___10);
          } else
          if (to_uppcase) {
            fwrite_uppcase(p, zone, _n___10);
          } else {
            tmp___41 = rpl_fwrite((void const   *)zone, _n___10, (size_t )1, p);
            __x___1 = tmp___41;
          }
          break;
        }
      }
      i += _incr___10;
      break;
    }
    break;
    case 58: 
    colons = (size_t )1;
    while ((int const   )*(f + colons) == 58) {
      goto __Cont___0;
      __Cont___0: 
      colons ++;
    }
    if ((int const   )*(f + colons) != 122) {
      goto bad_format;
    }
    f += colons;
    goto do_z_conversion;
    case 122: 
    colons = (size_t )0;
    do_z_conversion: 
    if (tp->tm_isdst < 0) {
      break;
    }
    diff = (int )tp->tm_gmtoff;
    hour_diff = (diff / 60) / 60;
    min_diff = (diff / 60) % 60;
    sec_diff = diff % 60;
    switch ((int )colons) {
    case 0: 
    digits = 5;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    goto do_tz_offset;
    tz_hh_mm: 
    case 1: 
    digits = 6;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 4;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2: 
    digits = 9;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 20;
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
    goto do_tz_offset;
    case 3: 
    if (sec_diff != 0) {
      goto tz_hh_mm_ss;
    }
    if (min_diff != 0) {
      goto tz_hh_mm;
    }
    digits = 3;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )hour_diff;
    goto do_tz_offset;
    default: 
    goto bad_format;
    }
    case 0: 
    f --;
    bad_format: 
    default: 
    flen = 1;
    while ((int const   )*(f + (1 - flen)) != 37) {
      goto __Cont___1;
      __Cont___1: 
      flen ++;
    }
    while (1) {
      _n___11 = (size_t )flen;
      if (width < 0) {
        tmp___42 = 0;
      } else {
        tmp___42 = width;
      }
      _w___11 = (size_t )tmp___42;
      if (_n___11 < _w___11) {
        tmp___43 = _w___11;
      } else {
        tmp___43 = _n___11;
      }
      _incr___11 = tmp___43;
      if (_incr___11 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___11 < _w___11) {
            _delta___11 = (size_t )width - _n___11;
            if (pad == 48) {
              while (1) {
                _i___25 = (size_t )0;
                while (_i___25 < _delta___11) {
                  fputc('0', p);
                  _i___25 ++;
                }
                break;
              }
            } else {
              while (1) {
                _i___26 = (size_t )0;
                while (_i___26 < _delta___11) {
                  fputc(' ', p);
                  _i___26 ++;
                }
                break;
              }
            }
          }
        }
        while (1) {
          if (to_lowcase) {
            fwrite_lowcase(p, f + (1 - flen), _n___11);
          } else
          if (to_uppcase) {
            fwrite_uppcase(p, f + (1 - flen), _n___11);
          } else {
            tmp___44 = rpl_fwrite((void const   *)(f + (1 - flen)), _n___11, (size_t )1,
                                  p);
            __x___2 = tmp___44;
          }
          break;
        }
      }
      i += _incr___11;
      break;
    }
    break;
    }
    __Cont: 
    f ++;
  }
  return (i);
}
}
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ size_t tmp ;

  {
  tmp = strftime_case_((_Bool)0, s, format, tp, ut, ns);
  return (tmp);
}
}
size_t freadahead(FILE *fp ) 
{ int tmp ;

  {
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
    return ((size_t )0);
  }
  if (fp->_flags & 256) {
    tmp = fp->_IO_save_end - fp->_IO_save_base;
  } else {
    tmp = 0;
  }
  return ((size_t )((fp->_IO_read_end - fp->_IO_read_ptr) + tmp));
}
}
char const   *freadptr(FILE *fp , size_t *sizep ) ;
char const   *freadptr(FILE *fp , size_t *sizep ) 
{ size_t size ;

  {
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
    return ((char const   *)((void *)0));
  }
  size = (size_t )(fp->_IO_read_end - fp->_IO_read_ptr);
  if (size == 0UL) {
    return ((char const   *)((void *)0));
  }
  *sizep = size;
  return ((char const   *)fp->_IO_read_ptr);
}
}
extern int fgetc(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
int freadseek(FILE *fp , size_t offset ) ;
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
__inline static void freadptrinc(FILE *fp , size_t increment ) 
{ 

  {
  fp->_IO_read_ptr += increment;
  return;
}
}
int freadseek(FILE *fp , size_t offset ) 
{ size_t total_buffered ;
  int fd ;
  size_t buffered ;
  size_t increment ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char buf___1[4096] ;
  size_t count ;
  unsigned long tmp___3 ;
  size_t __attribute__((__artificial__))  tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;
  size_t __attribute__((__artificial__))  tmp___7 ;

  {
  if (offset == 0UL) {
    return (0);
  }
  total_buffered = freadahead(fp);
  while (total_buffered > 0UL) {
    tmp___0 = freadptr(fp, & buffered);
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      if (buffered > 0UL) {
        if (buffered < offset) {
          tmp = buffered;
        } else {
          tmp = offset;
        }
        increment = tmp;
        freadptrinc(fp, increment);
        offset -= increment;
        if (offset == 0UL) {
          return (0);
        }
        total_buffered -= increment;
        if (total_buffered == 0UL) {
          break;
        }
      }
    }
    tmp___1 = fgetc(fp);
    if (tmp___1 == -1) {
      goto eof;
    }
    offset --;
    if (offset == 0UL) {
      return (0);
    }
    total_buffered --;
  }
  fd = fileno(fp);
  if (fd >= 0) {
    tmp___5 = lseek(fd, (__off_t )0, 1);
    if (tmp___5 >= 0L) {
      tmp___2 = rpl_fseeko(fp, (off_t )offset, 1);
      return (tmp___2);
    } else {
      goto _L;
    }
  } else {
    _L: 
    while (1) {
      if (sizeof(buf___1) < offset) {
        tmp___3 = sizeof(buf___1);
      } else {
        tmp___3 = offset;
      }
      count = tmp___3;
      tmp___7 = (size_t __attribute__((__artificial__))  )fread((void * __restrict  )(buf___1),
                                                                (size_t )1, count,
                                                                (FILE * __restrict  )fp);
      tmp___4 = tmp___7;
      if (tmp___4 < (size_t __attribute__((__artificial__))  )count) {
        goto eof;
      }
      offset -= count;
      if (! (offset > 0UL)) {
        break;
      }
    }
    return (0);
  }
  eof: 
  tmp___6 = ferror(fp);
  if (tmp___6) {
    return (-1);
  } else {
    return (0);
  }
}
}
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream )  __attribute__((__warn_unused_result__)) ;
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
static _Bool protect_fd(int fd ) 
{ int value ;
  int __attribute__((__artificial__))  tmp ;
  int *tmp___0 ;

  {
  tmp = open("/dev/null", 0);
  value = (int )tmp;
  if (value != fd) {
    if (0 <= value) {
      close(value);
      tmp___0 = __errno_location();
      *tmp___0 = 9;
    }
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) 
{ _Bool protect_in ;
  _Bool protect_out ;
  _Bool protect_err ;
  int saved_errno ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
  protect_in = (_Bool)0;
  protect_out = (_Bool)0;
  protect_err = (_Bool)0;
  tmp = fileno(f);
  switch (tmp) {
  default: 
  tmp___0 = dup2(2, 2);
  if (tmp___0 != 2) {
    protect_err = (_Bool)1;
  }
  case 2: 
  tmp___1 = dup2(1, 1);
  if (tmp___1 != 1) {
    protect_out = (_Bool)1;
  }
  case 1: 
  tmp___2 = dup2(0, 0);
  if (tmp___2 != 0) {
    protect_in = (_Bool)1;
  }
  case 0: 
  break;
  }
  if (protect_in) {
    tmp___5 = protect_fd(0);
    if (tmp___5) {
      goto _L___0;
    } else {
      f = (FILE *)((void *)0);
    }
  } else
  _L___0: 
  if (protect_out) {
    tmp___4 = protect_fd(1);
    if (tmp___4) {
      goto _L;
    } else {
      f = (FILE *)((void *)0);
    }
  } else
  _L: 
  if (protect_err) {
    tmp___3 = protect_fd(2);
    if (tmp___3) {
      f = freopen((char const   * __restrict  )name, (char const   * __restrict  )mode,
                  (FILE * __restrict  )f);
    } else {
      f = (FILE *)((void *)0);
    }
  } else {
    f = freopen((char const   * __restrict  )name, (char const   * __restrict  )mode,
                (FILE * __restrict  )f);
  }
  tmp___6 = __errno_location();
  saved_errno = *tmp___6;
  if (protect_err) {
    close(2);
  }
  if (protect_out) {
    close(1);
  }
  if (protect_in) {
    close(0);
  }
  if (! f) {
    tmp___7 = __errno_location();
    *tmp___7 = saved_errno;
  }
  return (f);
}
}
void fseterr(FILE *fp ) ;
void fseterr(FILE *fp ) 
{ 

  {
  fp->_flags |= 32;
  return;
}
}
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x ) ;
extern  __attribute__((__nothrow__)) float strtof(char const   * __restrict  __nptr ,
                                                  char ** __restrict  __endptr )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
int ftoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , float x ) 
{ char format[sizeof("%-+ 0*.*Lg")] ;
  float abs_x ;
  float tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int __attribute__((__artificial__))  tmp___5 ;
  float tmp___6 ;

  {
  if (x < (float )0) {
    tmp = - x;
  } else {
    tmp = x;
  }
  abs_x = tmp;
  p = format;
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )'%';
  *p = (char )'-';
  p += (flags & 1) != 0;
  *p = (char )'+';
  p += (flags & 2) != 0;
  *p = (char )' ';
  p += (flags & 4) != 0;
  *p = (char )'0';
  p += (flags & 8) != 0;
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'*';
  tmp___2 = p;
  p ++;
  *tmp___2 = (char )'.';
  tmp___3 = p;
  p ++;
  *tmp___3 = (char )'*';
  *p = (char )'L';
  p += 0;
  tmp___4 = p;
  p ++;
  if (flags & 16) {
    *tmp___4 = (char )'G';
  } else {
    *tmp___4 = (char )'g';
  }
  *p = (char )'\000';
  if (abs_x < 1.17549435082228750797e-38F) {
    prec = 1;
  } else {
    prec = 6;
  }
  while (1) {
    tmp___5 = snprintf((char * __restrict  )buf___1, bufsize___0, (char const   * __restrict  )(format),
                       width, prec, (double )x);
    n = (int )tmp___5;
    if (n < 0) {
      return (n);
    } else
    if (9 <= prec) {
      return (n);
    } else
    if ((size_t )n < bufsize___0) {
      tmp___6 = strtof((char const   * __restrict  )buf___1, (char ** __restrict  )((void *)0));
      if (tmp___6 == x) {
        return (n);
      }
    }
    prec ++;
  }
}
}
size_t full_read(int fd , void *buf___1 , size_t count ) ;
size_t safe_read(int fd , void *buf___1 , size_t count ) ;
size_t full_read(int fd , void *buf___1 , size_t count ) 
{ size_t total ;
  char *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
  total = (size_t )0;
  ptr = (char *)buf___1;
  while (count > 0UL) {
    tmp = safe_read(fd, (void *)ptr, count);
    n_rw = tmp;
    if (n_rw == 0xffffffffffffffffUL) {
      break;
    }
    if (n_rw == 0UL) {
      tmp___0 = __errno_location();
      *tmp___0 = 0;
      break;
    }
    total += n_rw;
    ptr += n_rw;
    count -= n_rw;
  }
  return (total);
}
}
size_t full_write(int fd , void const   *buf___1 , size_t count ) ;
size_t safe_write(int fd , void const   *buf___1 , size_t count ) ;
size_t full_write(int fd , void const   *buf___1 , size_t count ) 
{ size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
  total = (size_t )0;
  ptr = (char const   *)buf___1;
  while (count > 0UL) {
    tmp = safe_write(fd, (void const   *)ptr, count);
    n_rw = tmp;
    if (n_rw == 0xffffffffffffffffUL) {
      break;
    }
    if (n_rw == 0UL) {
      tmp___0 = __errno_location();
      *tmp___0 = 28;
      break;
    }
    total += n_rw;
    ptr += n_rw;
    count -= n_rw;
  }
  return (total);
}
}
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) ;
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) 
{ size_t nbytes_avail ;
  char *read_pos ;
  ssize_t bytes_stored ;
  char *ptr ;
  size_t size ;
  _Bool found_delimiter ;
  void *tmp ;
  int c ;
  char const   *buffer ;
  size_t buffer_len ;
  char const   *end ;
  void *tmp___0 ;
  size_t newsize ;
  size_t tmp___1 ;
  char *newptr ;
  size_t newsizemax ;
  void *tmp___2 ;
  size_t copy_len ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  bytes_stored = (ssize_t )-1;
  ptr = *lineptr;
  size = *linesize;
  if (! ptr) {
    if (nmax < 64UL) {
      size = nmax;
    } else {
      size = (size_t )64;
    }
    tmp = malloc(size);
    ptr = (char *)tmp;
    if (! ptr) {
      return ((ssize_t )-1);
    }
  }
  if (size < offset) {
    goto done;
  }
  nbytes_avail = size - offset;
  read_pos = ptr + offset;
  if (nbytes_avail == 0UL) {
    if (nmax <= size) {
      goto done;
    }
  }
  if (delim1 == -1) {
    delim1 = delim2;
  } else
  if (delim2 == -1) {
    delim2 = delim1;
  }
  found_delimiter = (_Bool)0;
  while (1) {
    buffer = freadptr(stream, & buffer_len);
    if (buffer) {
      if (delim1 != -1) {
        tmp___0 = memchr2((void const   *)buffer, delim1, delim2, buffer_len);
        end = (char const   *)tmp___0;
        if (end) {
          buffer_len = (size_t )((end - buffer) + 1);
          found_delimiter = (_Bool)1;
        }
      }
    } else {
      c = getc_unlocked(stream);
      if (c == -1) {
        if ((unsigned long )read_pos == (unsigned long )ptr) {
          goto unlock_done;
        } else {
          break;
        }
      }
      if (c == delim1) {
        found_delimiter = (_Bool)1;
      } else
      if (c == delim2) {
        found_delimiter = (_Bool)1;
      }
      buffer_len = (size_t )1;
    }
    if (nbytes_avail < buffer_len + 1UL) {
      if (size < nmax) {
        if (size < 64UL) {
          tmp___1 = size + 64UL;
        } else {
          tmp___1 = 2UL * size;
        }
        newsize = tmp___1;
        if (newsize - (size_t )(read_pos - ptr) < buffer_len + 1UL) {
          newsize = ((size_t )(read_pos - ptr) + buffer_len) + 1UL;
        }
        if (size < newsize) {
          if (! (newsize <= nmax)) {
            newsize = nmax;
          }
        } else {
          newsize = nmax;
        }
        if (9223372036854775807UL < newsize - offset) {
          newsizemax = (offset + 9223372036854775807UL) + 1UL;
          if (size == newsizemax) {
            goto unlock_done;
          }
          newsize = newsizemax;
        }
        nbytes_avail = newsize - (size_t )(read_pos - ptr);
        tmp___2 = realloc((void *)ptr, newsize);
        newptr = (char *)tmp___2;
        if (! newptr) {
          goto unlock_done;
        }
        ptr = newptr;
        size = newsize;
        read_pos = ptr + (size - nbytes_avail);
      }
    }
    if (1UL < nbytes_avail) {
      copy_len = nbytes_avail - 1UL;
      if (buffer_len < copy_len) {
        copy_len = buffer_len;
      }
      if (buffer) {
        memcpy((void * __restrict  )read_pos, (void const   * __restrict  )buffer,
               copy_len);
      } else {
        *read_pos = (char )c;
      }
      read_pos += copy_len;
      nbytes_avail -= copy_len;
    }
    if (buffer) {
      tmp___3 = freadseek(stream, buffer_len);
      if (tmp___3) {
        goto unlock_done;
      }
    }
    if (! (! found_delimiter)) {
      break;
    }
  }
  *read_pos = (char )'\000';
  bytes_stored = (ssize_t )(read_pos - (ptr + offset));
  unlock_done: ;
  done: 
  *lineptr = ptr;
  *linesize = size;
  if (bytes_stored) {
    tmp___4 = bytes_stored;
  } else {
    tmp___4 = (ssize_t )-1;
  }
  return (tmp___4);
}
}
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
void gettime(struct timespec *ts ) ;
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
void gettime(struct timespec *ts ) 
{ int tmp ;
  struct timeval tv ;

  {
  tmp = clock_gettime(0, ts);
  if (tmp == 0) {
    return;
  }
  gettimeofday((struct timeval * __restrict  )(& tv), (__timezone_ptr_t )((void *)0));
  ts->tv_sec = tv.tv_sec;
  ts->tv_nsec = tv.tv_usec * 1000L;
  return;
}
}
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) ;
extern void setgrent(void) ;
extern void endgrent(void) ;
extern struct group *getgrent(void) ;
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) 
{ int count ;
  char **cp ;
  struct group *grp ;
  int *tmp ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  count = 0;
  if (gid != 4294967295U) {
    if (maxcount != 0) {
      *(grouplist + count) = gid;
    }
    count ++;
  }
  setgrent();
  while (1) {
    tmp = __errno_location();
    *tmp = 0;
    grp = getgrent();
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
      break;
    }
    cp = grp->gr_mem;
    while (*cp) {
      if (0) {
        __s1_len = __builtin_strlen(username);
        __s2_len = __builtin_strlen((char const   *)*cp);
        if (! ((size_t )((void const   *)(username + 1)) - (size_t )((void const   *)username) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)(*cp + 1)) - (size_t )((void const   *)*cp) == 1UL)) {
            tmp___6 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (tmp___6) {
          tmp___1 = __builtin_strcmp(username, (char const   *)*cp);
          tmp___5 = tmp___1;
        } else {
          tmp___4 = __builtin_strcmp(username, (char const   *)*cp);
          tmp___5 = tmp___4;
        }
      } else {
        tmp___4 = __builtin_strcmp(username, (char const   *)*cp);
        tmp___5 = tmp___4;
      }
      if (! (tmp___5 == 0)) {
        goto __Cont;
      }
      n = 0;
      while (n < count) {
        if (grouplist) {
          if (*(grouplist + n) == grp->gr_gid) {
            break;
          }
        }
        n ++;
      }
      if (n == count) {
        if (maxcount != 0) {
          if (count >= maxcount) {
            goto done;
          }
          *(grouplist + count) = grp->gr_gid;
        }
        if (count == 2147483647) {
          tmp___7 = __errno_location();
          *tmp___7 = 75;
          goto done;
        }
        count ++;
      }
      __Cont: 
      cp ++;
    }
  }
  tmp___8 = __errno_location();
  if (*tmp___8 != 0) {
    count = -1;
  }
  done: 
  tmp___9 = __errno_location();
  saved_errno = *tmp___9;
  endgrent();
  tmp___10 = __errno_location();
  *tmp___10 = saved_errno;
  return (count);
}
}
_Bool hard_locale(int category ) ;
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
_Bool hard_locale(int category ) 
{ _Bool hard ;
  char const   *p ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *locale ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  hard = (_Bool)1;
  tmp = setlocale(category, (char const   *)((void *)0));
  p = (char const   *)tmp;
  if (p) {
    if (1) {
      if (0) {
        __s1_len = __builtin_strlen(p);
        __s2_len = __builtin_strlen("C");
        if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)("C" + 1)) - (size_t )((void const   *)"C") == 1UL)) {
            tmp___6 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (tmp___6) {
          tmp___1 = __builtin_strcmp(p, "C");
          tmp___5 = tmp___1;
        } else {
          tmp___4 = __builtin_strcmp(p, "C");
          tmp___5 = tmp___4;
        }
      } else {
        tmp___4 = __builtin_strcmp(p, "C");
        tmp___5 = tmp___4;
      }
      if (tmp___5 == 0) {
        hard = (_Bool)0;
      } else {
        if (0) {
          __s1_len___0 = __builtin_strlen(p);
          __s2_len___0 = __builtin_strlen("POSIX");
          if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
            goto _L___2;
          } else
          if (__s1_len___0 >= 4UL) {
            _L___2: 
            if (! ((size_t )((void const   *)("POSIX" + 1)) - (size_t )((void const   *)"POSIX") == 1UL)) {
              tmp___13 = 1;
            } else
            if (__s2_len___0 >= 4UL) {
              tmp___13 = 1;
            } else {
              tmp___13 = 0;
            }
          } else {
            tmp___13 = 0;
          }
          if (tmp___13) {
            tmp___8 = __builtin_strcmp(p, "POSIX");
            tmp___12 = tmp___8;
          } else {
            tmp___11 = __builtin_strcmp(p, "POSIX");
            tmp___12 = tmp___11;
          }
        } else {
          tmp___11 = __builtin_strcmp(p, "POSIX");
          tmp___12 = tmp___11;
        }
        if (tmp___12 == 0) {
          hard = (_Bool)0;
        }
      }
    } else {
      tmp___19 = __strdup(p);
      locale = tmp___19;
      if (locale) {
        tmp___20 = setlocale(category, "C");
        p = (char const   *)tmp___20;
        if (p) {
          if (0) {
            __s1_len___1 = __builtin_strlen(p);
            __s2_len___1 = __builtin_strlen((char const   *)locale);
            if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
              goto _L___4;
            } else
            if (__s1_len___1 >= 4UL) {
              _L___4: 
              if (! ((size_t )((void const   *)(locale + 1)) - (size_t )((void const   *)locale) == 1UL)) {
                tmp___27 = 1;
              } else
              if (__s2_len___1 >= 4UL) {
                tmp___27 = 1;
              } else {
                tmp___27 = 0;
              }
            } else {
              tmp___27 = 0;
            }
            if (tmp___27) {
              tmp___22 = __builtin_strcmp(p, (char const   *)locale);
              tmp___26 = tmp___22;
            } else {
              tmp___25 = __builtin_strcmp(p, (char const   *)locale);
              tmp___26 = tmp___25;
            }
          } else {
            tmp___25 = __builtin_strcmp(p, (char const   *)locale);
            tmp___26 = tmp___25;
          }
          if (tmp___26 == 0) {
            hard = (_Bool)0;
          } else {
            goto _L___7;
          }
        } else {
          _L___7: 
          tmp___28 = setlocale(category, "POSIX");
          p = (char const   *)tmp___28;
          if (p) {
            if (0) {
              __s1_len___2 = __builtin_strlen(p);
              __s2_len___2 = __builtin_strlen((char const   *)locale);
              if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
                goto _L___6;
              } else
              if (__s1_len___2 >= 4UL) {
                _L___6: 
                if (! ((size_t )((void const   *)(locale + 1)) - (size_t )((void const   *)locale) == 1UL)) {
                  tmp___35 = 1;
                } else
                if (__s2_len___2 >= 4UL) {
                  tmp___35 = 1;
                } else {
                  tmp___35 = 0;
                }
              } else {
                tmp___35 = 0;
              }
              if (tmp___35) {
                tmp___30 = __builtin_strcmp(p, (char const   *)locale);
                tmp___34 = tmp___30;
              } else {
                tmp___33 = __builtin_strcmp(p, (char const   *)locale);
                tmp___34 = tmp___33;
              }
            } else {
              tmp___33 = __builtin_strcmp(p, (char const   *)locale);
              tmp___34 = tmp___33;
            }
            if (tmp___34 == 0) {
              hard = (_Bool)0;
            }
          }
        }
        setlocale(category, (char const   *)locale);
        free((void *)locale);
      }
    }
  }
  return (hard);
}
}
size_t hash_get_n_buckets(Hash_table const   *table___1 ) ;
size_t hash_get_n_buckets_used(Hash_table const   *table___1 ) ;
size_t hash_get_n_entries(Hash_table const   *table___1 ) ;
size_t hash_get_max_bucket_length(Hash_table const   *table___1 ) ;
_Bool hash_table_ok(Hash_table const   *table___1 ) ;
void hash_print_statistics(Hash_table const   *table___1 , FILE *stream ) ;
void *hash_get_first(Hash_table const   *table___1 ) ;
void *hash_get_next(Hash_table const   *table___1 , void const   *entry ) ;
size_t hash_get_entries(Hash_table const   *table___1 , void **buffer , size_t buffer_size ) ;
size_t hash_do_for_each(Hash_table const   *table___1 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
void hash_reset_tuning(Hash_tuning *tuning ) ;
void hash_clear(Hash_table *table___1 ) ;
_Bool hash_rehash(Hash_table *table___1 , size_t candidate )  __attribute__((__warn_unused_result__)) ;
void *hash_delete(Hash_table *table___1 , void const   *entry ) ;
__inline static size_t rotr_sz(size_t x , int n ) 
{ 

  {
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
size_t hash_get_n_buckets(Hash_table const   *table___1 ) 
{ 

  {
  return ((size_t )table___1->n_buckets);
}
}
size_t hash_get_n_buckets_used(Hash_table const   *table___1 ) 
{ 

  {
  return ((size_t )table___1->n_buckets_used);
}
}
size_t hash_get_n_entries(Hash_table const   *table___1 ) 
{ 

  {
  return ((size_t )table___1->n_entries);
}
}
size_t hash_get_max_bucket_length(Hash_table const   *table___1 ) 
{ struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
  max_bucket_length = (size_t )0;
  bucket = (struct hash_entry  const  *)table___1->bucket;
  while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
    if (bucket->data) {
      cursor = bucket;
      bucket_length = (size_t )1;
      while (1) {
        cursor = (struct hash_entry  const  *)cursor->next;
        if (! cursor) {
          break;
        }
        bucket_length ++;
      }
      if (bucket_length > max_bucket_length) {
        max_bucket_length = bucket_length;
      }
    }
    bucket ++;
  }
  return (max_bucket_length);
}
}
_Bool hash_table_ok(Hash_table const   *table___1 ) 
{ struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
  n_buckets_used = (size_t )0;
  n_entries = (size_t )0;
  bucket = (struct hash_entry  const  *)table___1->bucket;
  while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
    if (bucket->data) {
      cursor = bucket;
      n_buckets_used ++;
      n_entries ++;
      while (1) {
        cursor = (struct hash_entry  const  *)cursor->next;
        if (! cursor) {
          break;
        }
        n_entries ++;
      }
    }
    bucket ++;
  }
  if (n_buckets_used == (size_t )table___1->n_buckets_used) {
    if (n_entries == (size_t )table___1->n_entries) {
      return ((_Bool)1);
    }
  }
  return ((_Bool)0);
}
}
void hash_print_statistics(Hash_table const   *table___1 , FILE *stream ) 
{ size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  tmp = hash_get_n_entries(table___1);
  n_entries = tmp;
  tmp___0 = hash_get_n_buckets(table___1);
  n_buckets = tmp___0;
  tmp___1 = hash_get_n_buckets_used(table___1);
  n_buckets_used = tmp___1;
  tmp___2 = hash_get_max_bucket_length(table___1);
  max_bucket_length = tmp___2;
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# entries:         %lu\n",
          n_entries);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# buckets:         %lu\n",
          n_buckets);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"max bucket length: %lu\n",
          max_bucket_length);
  return;
}
}
static struct hash_entry *safe_hasher(Hash_table const   *table___1 , void const   *key ) 
{ size_t n ;
  size_t tmp ;

  {
  tmp = (*(table___1->hasher))(key, (size_t )table___1->n_buckets);
  n = tmp;
  if (! (n < (size_t )table___1->n_buckets)) {
    abort();
  }
  return ((struct hash_entry *)(table___1->bucket + n));
}
}
void *hash_lookup(Hash_table const   *table___1 , void const   *entry ) 
{ struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  tmp = safe_hasher(table___1, entry);
  bucket = (struct hash_entry  const  *)tmp;
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  cursor = bucket;
  while (cursor) {
    if ((unsigned long )entry == (unsigned long )cursor->data) {
      return ((void *)cursor->data);
    } else {
      tmp___0 = (*(table___1->comparator))(entry, (void const   *)cursor->data);
      if (tmp___0) {
        return ((void *)cursor->data);
      }
    }
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  return ((void *)0);
}
}
void *hash_get_first(Hash_table const   *table___1 ) 
{ struct hash_entry  const  *bucket ;

  {
  if (table___1->n_entries == 0UL) {
    return ((void *)0);
  }
  bucket = (struct hash_entry  const  *)table___1->bucket;
  while (1) {
    if (! ((unsigned long )bucket < (unsigned long )table___1->bucket_limit)) {
      abort();
    } else
    if (bucket->data) {
      return ((void *)bucket->data);
    }
    bucket ++;
  }
}
}
void *hash_get_next(Hash_table const   *table___1 , void const   *entry ) 
{ struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  tmp = safe_hasher(table___1, entry);
  bucket = (struct hash_entry  const  *)tmp;
  cursor = bucket;
  while (1) {
    if ((unsigned long )cursor->data == (unsigned long )entry) {
      if (cursor->next) {
        return ((cursor->next)->data);
      }
    }
    cursor = (struct hash_entry  const  *)cursor->next;
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
      break;
    }
  }
  while (1) {
    bucket ++;
    if (! ((unsigned long )bucket < (unsigned long )table___1->bucket_limit)) {
      break;
    }
    if (bucket->data) {
      return ((void *)bucket->data);
    }
  }
  return ((void *)0);
}
}
size_t hash_get_entries(Hash_table const   *table___1 , void **buffer , size_t buffer_size ) 
{ size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
  counter = (size_t )0;
  bucket = (struct hash_entry  const  *)table___1->bucket;
  while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
    if (bucket->data) {
      cursor = bucket;
      while (cursor) {
        if (counter >= buffer_size) {
          return (counter);
        }
        tmp = counter;
        counter ++;
        *(buffer + tmp) = (void *)cursor->data;
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
    bucket ++;
  }
  return (counter);
}
}
size_t hash_do_for_each(Hash_table const   *table___1 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) 
{ size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
  counter = (size_t )0;
  bucket = (struct hash_entry  const  *)table___1->bucket;
  while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
    if (bucket->data) {
      cursor = bucket;
      while (cursor) {
        tmp = (*processor)((void *)cursor->data, processor_data);
        if (! tmp) {
          return (counter);
        }
        counter ++;
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
    bucket ++;
  }
  return (counter);
}
}
size_t hash_string(char const   *string , size_t n_buckets ) 
{ size_t value ;
  unsigned char ch ;

  {
  value = (size_t )0;
  while (1) {
    ch = (unsigned char )*string;
    if (! ch) {
      break;
    }
    value = (value * 31UL + (size_t )ch) % n_buckets;
    string ++;
  }
  return (value);
}
}
static _Bool is_prime(size_t candidate ) 
{ size_t divisor ;
  size_t square ;
  int tmp ;

  {
  divisor = (size_t )3;
  square = divisor * divisor;
  while (1) {
    if (square < candidate) {
      if (! (candidate % divisor)) {
        break;
      }
    } else {
      break;
    }
    divisor ++;
    square += 4UL * divisor;
    divisor ++;
  }
  if (candidate % divisor) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static size_t next_prime(size_t candidate ) 
{ _Bool tmp ;

  {
  if (candidate < 10UL) {
    candidate = (size_t )10;
  }
  candidate |= 1UL;
  while (1) {
    if (0xffffffffffffffffUL != candidate) {
      tmp = is_prime(candidate);
      if (tmp) {
        break;
      }
    } else {
      break;
    }
    candidate += 2UL;
  }
  return (candidate);
}
}
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 

  {
  *tuning = (Hash_tuning )default_tuning;
  return;
}
}
static size_t raw_hasher(void const   *data , size_t n ) 
{ size_t val ;
  size_t tmp ;

  {
  tmp = rotr_sz((size_t )data, 3);
  val = tmp;
  return (val % n);
}
}
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 

  {
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
static _Bool check_tuning(Hash_table *table___1 ) 
{ Hash_tuning const   *tuning ;
  float epsilon ;

  {
  tuning = table___1->tuning;
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
    return ((_Bool)1);
  }
  epsilon = 0.1f;
  if (epsilon < (float )tuning->growth_threshold) {
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
        if ((float const   )0 <= tuning->shrink_threshold) {
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
            if (tuning->shrink_factor <= (float const   )1) {
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
  table___1->tuning = & default_tuning;
  return ((_Bool)0);
}
}
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ float new_candidate ;
  int tmp ;

  {
  if (! tuning->is_n_buckets) {
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
    if ((float )0xffffffffffffffffUL <= new_candidate) {
      return ((size_t )0);
    }
    candidate = (size_t )new_candidate;
  }
  candidate = next_prime(candidate);
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    tmp = -1;
  } else {
    tmp = -2;
  }
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
    return ((size_t )0);
  }
  return (candidate);
}
}
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) )  __attribute__((__warn_unused_result__)) ;
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ Hash_table *table___1 ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
    hasher = & raw_hasher;
  }
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
    comparator = & raw_comparator;
  }
  tmp = malloc(sizeof(*table___1));
  table___1 = (Hash_table *)tmp;
  if ((unsigned long )table___1 == (unsigned long )((void *)0)) {
    return ((Hash_table *)((void *)0));
  }
  if (! tuning) {
    tuning = & default_tuning;
  }
  table___1->tuning = tuning;
  tmp___0 = check_tuning(table___1);
  if (! tmp___0) {
    goto fail;
  }
  table___1->n_buckets = compute_bucket_size(candidate, tuning);
  if (! table___1->n_buckets) {
    goto fail;
  }
  tmp___1 = calloc(table___1->n_buckets, sizeof(*(table___1->bucket)));
  table___1->bucket = (struct hash_entry *)tmp___1;
  if ((unsigned long )table___1->bucket == (unsigned long )((void *)0)) {
    goto fail;
  }
  table___1->bucket_limit = (struct hash_entry  const  *)(table___1->bucket + table___1->n_buckets);
  table___1->n_buckets_used = (size_t )0;
  table___1->n_entries = (size_t )0;
  table___1->hasher = hasher;
  table___1->comparator = comparator;
  table___1->data_freer = data_freer;
  table___1->free_entry_list = (struct hash_entry *)((void *)0);
  return (table___1);
  fail: 
  free((void *)table___1);
  return ((Hash_table *)((void *)0));
}
}
void hash_clear(Hash_table *table___1 ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
  bucket = table___1->bucket;
  while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
    if (bucket->data) {
      cursor = bucket->next;
      while (cursor) {
        if (table___1->data_freer) {
          (*(table___1->data_freer))(cursor->data);
        }
        cursor->data = (void *)0;
        next = cursor->next;
        cursor->next = table___1->free_entry_list;
        table___1->free_entry_list = cursor;
        cursor = next;
      }
      if (table___1->data_freer) {
        (*(table___1->data_freer))(bucket->data);
      }
      bucket->data = (void *)0;
      bucket->next = (struct hash_entry *)((void *)0);
    }
    bucket ++;
  }
  table___1->n_buckets_used = (size_t )0;
  table___1->n_entries = (size_t )0;
  return;
}
}
void hash_free(Hash_table *table___1 ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
  if (table___1->data_freer) {
    if (table___1->n_entries) {
      bucket = table___1->bucket;
      while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
        if (bucket->data) {
          cursor = bucket;
          while (cursor) {
            (*(table___1->data_freer))(cursor->data);
            cursor = cursor->next;
          }
        }
        bucket ++;
      }
    }
  }
  bucket = table___1->bucket;
  while ((unsigned long )bucket < (unsigned long )table___1->bucket_limit) {
    cursor = bucket->next;
    while (cursor) {
      next = cursor->next;
      free((void *)cursor);
      cursor = next;
    }
    bucket ++;
  }
  cursor = table___1->free_entry_list;
  while (cursor) {
    next = cursor->next;
    free((void *)cursor);
    cursor = next;
  }
  free((void *)table___1->bucket);
  free((void *)table___1);
  return;
}
}
static struct hash_entry *allocate_entry(Hash_table *table___1 ) 
{ struct hash_entry *new ;
  void *tmp ;

  {
  if (table___1->free_entry_list) {
    new = table___1->free_entry_list;
    table___1->free_entry_list = new->next;
  } else {
    tmp = malloc(sizeof(*new));
    new = (struct hash_entry *)tmp;
  }
  return (new);
}
}
static void free_entry(Hash_table *table___1 , struct hash_entry *entry ) 
{ 

  {
  entry->data = (void *)0;
  entry->next = table___1->free_entry_list;
  table___1->free_entry_list = entry;
  return;
}
}
static void *hash_find_entry(Hash_table *table___1 , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  tmp = safe_hasher((Hash_table const   *)table___1, entry);
  bucket = tmp;
  *bucket_head = bucket;
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  if ((unsigned long )entry == (unsigned long )bucket->data) {
    goto _L;
  } else {
    tmp___0 = (*(table___1->comparator))(entry, (void const   *)bucket->data);
    if (tmp___0) {
      _L: 
      data = bucket->data;
      if (delete) {
        if (bucket->next) {
          next = bucket->next;
          *bucket = *next;
          free_entry(table___1, next);
        } else {
          bucket->data = (void *)0;
        }
      }
      return (data);
    }
  }
  cursor = bucket;
  while (cursor->next) {
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
      goto _L___0;
    } else {
      tmp___1 = (*(table___1->comparator))(entry, (void const   *)(cursor->next)->data);
      if (tmp___1) {
        _L___0: 
        data___0 = (cursor->next)->data;
        if (delete) {
          next___0 = cursor->next;
          cursor->next = next___0->next;
          free_entry(table___1, next___0);
        }
        return (data___0);
      }
    }
    cursor = cursor->next;
  }
  return ((void *)0);
}
}
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
  bucket = src->bucket;
  while ((unsigned long )bucket < (unsigned long )src->bucket_limit) {
    if (bucket->data) {
      cursor = bucket->next;
      while (cursor) {
        data = cursor->data;
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
        next = cursor->next;
        if (new_bucket->data) {
          cursor->next = new_bucket->next;
          new_bucket->next = cursor;
        } else {
          new_bucket->data = data;
          (dst->n_buckets_used) ++;
          free_entry(dst, cursor);
        }
        cursor = next;
      }
      data = bucket->data;
      bucket->next = (struct hash_entry *)((void *)0);
      if (safe) {
        goto __Cont;
      }
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      if (new_bucket->data) {
        tmp = allocate_entry(dst);
        new_entry = tmp;
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
          return ((_Bool)0);
        }
        new_entry->data = data;
        new_entry->next = new_bucket->next;
        new_bucket->next = new_entry;
      } else {
        new_bucket->data = data;
        (dst->n_buckets_used) ++;
      }
      bucket->data = (void *)0;
      (src->n_buckets_used) --;
    }
    __Cont: 
    bucket ++;
  }
  return ((_Bool)1);
}
}
_Bool hash_rehash(Hash_table *table___1 , size_t candidate )  __attribute__((__warn_unused_result__)) ;
_Bool hash_rehash(Hash_table *table___1 , size_t candidate ) 
{ Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp = compute_bucket_size(candidate, table___1->tuning);
  new_size = tmp;
  if (! new_size) {
    return ((_Bool)0);
  }
  if (new_size == table___1->n_buckets) {
    return ((_Bool)1);
  }
  new_table = & storage;
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
  new_table->bucket = (struct hash_entry *)tmp___0;
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  new_table->n_buckets = new_size;
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
  new_table->n_buckets_used = (size_t )0;
  new_table->n_entries = (size_t )0;
  new_table->tuning = table___1->tuning;
  new_table->hasher = table___1->hasher;
  new_table->comparator = table___1->comparator;
  new_table->data_freer = table___1->data_freer;
  new_table->free_entry_list = table___1->free_entry_list;
  tmp___1 = transfer_entries(new_table, table___1, (_Bool)0);
  if (tmp___1) {
    free((void *)table___1->bucket);
    table___1->bucket = new_table->bucket;
    table___1->bucket_limit = new_table->bucket_limit;
    table___1->n_buckets = new_table->n_buckets;
    table___1->n_buckets_used = new_table->n_buckets_used;
    table___1->free_entry_list = new_table->free_entry_list;
    return ((_Bool)1);
  }
  table___1->free_entry_list = new_table->free_entry_list;
  tmp___2 = transfer_entries(table___1, new_table, (_Bool)1);
  if (tmp___2) {
    tmp___3 = transfer_entries(table___1, new_table, (_Bool)0);
    if (! tmp___3) {
      abort();
    }
  } else {
    abort();
  }
  free((void *)new_table->bucket);
  return ((_Bool)0);
}
}
int hash_insert0(Hash_table *table___1 , void const   *entry , void const   **matched_ent ) 
{ void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
  if (! entry) {
    abort();
  }
  data = hash_find_entry(table___1, entry, & bucket, (_Bool)0);
  if ((unsigned long )data != (unsigned long )((void *)0)) {
    if (matched_ent) {
      *matched_ent = (void const   *)data;
    }
    return (0);
  }
  if ((float const   )table___1->n_buckets_used > (table___1->tuning)->growth_threshold * (float const   )table___1->n_buckets) {
    check_tuning(table___1);
    if ((float const   )table___1->n_buckets_used > (table___1->tuning)->growth_threshold * (float const   )table___1->n_buckets) {
      tuning = table___1->tuning;
      if (tuning->is_n_buckets) {
        tmp = (float )((float const   )table___1->n_buckets * tuning->growth_factor);
      } else {
        tmp = (float )(((float const   )table___1->n_buckets * tuning->growth_factor) * tuning->growth_threshold);
      }
      candidate = tmp;
      if ((float )0xffffffffffffffffUL <= candidate) {
        return (-1);
      }
      tmp___0 = hash_rehash(table___1, (size_t )candidate);
      if (! tmp___0) {
        return (-1);
      }
      tmp___1 = hash_find_entry(table___1, entry, & bucket, (_Bool)0);
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        abort();
      }
    }
  }
  if (bucket->data) {
    tmp___2 = allocate_entry(table___1);
    new_entry = tmp___2;
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
      return (-1);
    }
    new_entry->data = (void *)entry;
    new_entry->next = bucket->next;
    bucket->next = new_entry;
    (table___1->n_entries) ++;
    return (1);
  }
  bucket->data = (void *)entry;
  (table___1->n_entries) ++;
  (table___1->n_buckets_used) ++;
  return (1);
}
}
void *hash_insert(Hash_table *table___1 , void const   *entry )  __attribute__((__warn_unused_result__)) ;
void *hash_insert(Hash_table *table___1 , void const   *entry ) 
{ void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = hash_insert0(table___1, entry, & matched_ent);
  err = tmp;
  if (err == -1) {
    tmp___1 = (void *)0;
  } else {
    if (err == 0) {
      tmp___0 = matched_ent;
    } else {
      tmp___0 = entry;
    }
    tmp___1 = (void *)tmp___0;
  }
  return (tmp___1);
}
}
void *hash_delete(Hash_table *table___1 , void const   *entry ) 
{ void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  data = hash_find_entry(table___1, entry, & bucket, (_Bool)1);
  if (! data) {
    return ((void *)0);
  }
  (table___1->n_entries) --;
  if (! bucket->data) {
    (table___1->n_buckets_used) --;
    if ((float const   )table___1->n_buckets_used < (table___1->tuning)->shrink_threshold * (float const   )table___1->n_buckets) {
      check_tuning(table___1);
      if ((float const   )table___1->n_buckets_used < (table___1->tuning)->shrink_threshold * (float const   )table___1->n_buckets) {
        tuning = table___1->tuning;
        if (tuning->is_n_buckets) {
          tmp = (float )((float const   )table___1->n_buckets * tuning->shrink_factor);
        } else {
          tmp = (float )(((float const   )table___1->n_buckets * tuning->shrink_factor) * tuning->growth_threshold);
        }
        candidate = (size_t )tmp;
        tmp___0 = hash_rehash(table___1, candidate);
        if (! tmp___0) {
          cursor = table___1->free_entry_list;
          while (cursor) {
            next = cursor->next;
            free((void *)cursor);
            cursor = next;
          }
          table___1->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
  return (data);
}
}
size_t hash_pjw(void const   *x , size_t tablesize ) ;
size_t hash_pjw(void const   *x , size_t tablesize ) 
{ char const   *s ;
  size_t h ;

  {
  h = (size_t )0;
  s = (char const   *)x;
  while (*s) {
    h = (unsigned long )*s + ((h << 9) | (h >> (sizeof(size_t ) * 8UL - 9UL)));
    s ++;
  }
  return (h % tablesize);
}
}
size_t triple_hash_no_name(void const   *x , size_t table_size ) ;
_Bool triple_compare(void const   *x , void const   *y ) ;
_Bool same_name(char const   *source , char const   *dest ) ;
size_t triple_hash(void const   *x , size_t table_size ) 
{ struct F_triple  const  *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  p = (struct F_triple  const  *)x;
  tmp___0 = hash_pjw((void const   *)p->name, table_size);
  tmp = tmp___0;
  return ((tmp ^ (unsigned long )p->st_ino) % table_size);
}
}
size_t triple_hash_no_name(void const   *x , size_t table_size ) 
{ struct F_triple  const  *p ;

  {
  p = (struct F_triple  const  *)x;
  return ((size_t )(p->st_ino % (unsigned long const   )table_size));
}
}
_Bool triple_compare(void const   *x , void const   *y ) 
{ struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  a = (struct F_triple  const  *)x;
  b = (struct F_triple  const  *)y;
  if (a->st_ino == b->st_ino) {
    if (a->st_dev == b->st_dev) {
      tmp___1 = same_name((char const   *)a->name, (char const   *)b->name);
      if (tmp___1) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
}
}
_Bool triple_compare_ino_str(void const   *x , void const   *y ) 
{ struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  a = (struct F_triple  const  *)x;
  b = (struct F_triple  const  *)y;
  if (a->st_ino == b->st_ino) {
    if (a->st_dev == b->st_dev) {
      if (0) {
        __s1_len___0 = __builtin_strlen((char const   *)a->name);
        __s2_len___0 = __builtin_strlen((char const   *)b->name);
        if (! ((size_t )((void const   *)(a->name + 1)) - (size_t )((void const   *)a->name) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)(b->name + 1)) - (size_t )((void const   *)b->name) == 1UL)) {
            tmp___13 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___13 = 1;
          } else {
            tmp___13 = 0;
          }
        } else {
          tmp___13 = 0;
        }
        if (tmp___13) {
          tmp___8 = __builtin_strcmp((char const   *)a->name, (char const   *)b->name);
          tmp___12 = tmp___8;
        } else {
          tmp___11 = __builtin_strcmp((char const   *)a->name, (char const   *)b->name);
          tmp___12 = tmp___11;
        }
      } else {
        tmp___11 = __builtin_strcmp((char const   *)a->name, (char const   *)b->name);
        tmp___12 = tmp___11;
      }
      if (tmp___12 == 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  return ((_Bool )tmp___6);
}
}
void triple_free(void *x ) 
{ struct F_triple *a ;

  {
  a = (struct F_triple *)x;
  free((void *)a->name);
  free((void *)a);
  return;
}
}
struct heap *heap_alloc(int (*compare)(void const   * , void const   * ) , size_t n_reserve ) ;
void heap_free(struct heap *heap ) ;
int heap_insert(struct heap *heap , void *item ) ;
void *heap_remove_top(struct heap *heap ) ;
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
__inline static void *xnmalloc(size_t n , size_t s ) 
{ int tmp ;
  void *tmp___0 ;

  {
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    tmp = -1;
  } else {
    tmp = -2;
  }
  if ((size_t )tmp / s < n) {
    xalloc_die();
  }
  tmp___0 = xmalloc(n * s);
  return (tmp___0);
}
}
static int heap_default_compare(void const   *a , void const   *b ) ;
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const   * ,
                                                                                         void const   * ) ) ;
static void heapify_up(void **array , size_t count , int (*compare)(void const   * ,
                                                                    void const   * ) ) ;
struct heap *heap_alloc(int (*compare)(void const   * , void const   * ) , size_t n_reserve ) 
{ struct heap *heap ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = xmalloc(sizeof(*heap));
  heap = (struct heap *)tmp;
  if (n_reserve == 0UL) {
    n_reserve = (size_t )1;
  }
  tmp___0 = xnmalloc(n_reserve, sizeof(*(heap->array)));
  heap->array = (void **)tmp___0;
  *(heap->array + 0) = (void *)0;
  heap->capacity = n_reserve;
  heap->count = (size_t )0;
  if (compare) {
    heap->compare = compare;
  } else {
    heap->compare = & heap_default_compare;
  }
  return (heap);
}
}
static int heap_default_compare(void const   *a , void const   *b ) 
{ 

  {
  return (0);
}
}
void heap_free(struct heap *heap ) 
{ 

  {
  free((void *)heap->array);
  free((void *)heap);
  return;
}
}
int heap_insert(struct heap *heap , void *item ) 
{ void *tmp ;

  {
  if (heap->capacity - 1UL <= heap->count) {
    tmp = x2nrealloc((void *)heap->array, & heap->capacity, sizeof(*(heap->array)));
    heap->array = (void **)tmp;
  }
  (heap->count) ++;
  *(heap->array + heap->count) = item;
  heapify_up(heap->array, heap->count, heap->compare);
  return (0);
}
}
void *heap_remove_top(struct heap *heap ) 
{ void *top ;
  size_t tmp ;

  {
  if (heap->count == 0UL) {
    return ((void *)0);
  }
  top = *(heap->array + 1);
  tmp = heap->count;
  (heap->count) --;
  *(heap->array + 1) = *(heap->array + tmp);
  heapify_down(heap->array, heap->count, (size_t )1, heap->compare);
  return (top);
}
}
static size_t heapify_down(void **array , size_t count , size_t initial , int (*compare)(void const   * ,
                                                                                         void const   * ) ) 
{ void *element ;
  size_t parent ;
  size_t child ;
  int tmp ;
  int tmp___0 ;

  {
  element = *(array + initial);
  parent = initial;
  while (parent <= count / 2UL) {
    child = 2UL * parent;
    if (child < count) {
      tmp = (*compare)((void const   *)*(array + child), (void const   *)*(array + (child + 1UL)));
      if (tmp < 0) {
        child ++;
      }
    }
    tmp___0 = (*compare)((void const   *)*(array + child), (void const   *)element);
    if (tmp___0 <= 0) {
      break;
    }
    *(array + parent) = *(array + child);
    parent = child;
  }
  *(array + parent) = element;
  return (parent);
}
}
static void heapify_up(void **array , size_t count , int (*compare)(void const   * ,
                                                                    void const   * ) ) 
{ size_t k ;
  void *new_element ;
  int tmp ;

  {
  k = count;
  new_element = *(array + k);
  while (1) {
    if (k != 1UL) {
      tmp = (*compare)((void const   *)*(array + k / 2UL), (void const   *)new_element);
      if (! (tmp <= 0)) {
        break;
      }
    } else {
      break;
    }
    *(array + k) = *(array + k / 2UL);
    k /= 2UL;
  }
  *(array + k) = new_element;
  return;
}
}
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern intmax_t strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                   int base ) 
{ long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern uintmax_t strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) 
{ unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t const   * __restrict  __nptr ,
                                                            __gwchar_t ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                   int base ) 
{ long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t const   * __restrict  __nptr ,
                                                                      __gwchar_t ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                    int base ) 
{ unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) ;
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
static char const   power_letter[9]  = 
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
static long double adjust_value(int inexact_style , long double value ) 
{ uintmax_t u ;
  int tmp ;

  {
  if (inexact_style != 1) {
    if (value < (long double )0xffffffffffffffffUL) {
      u = (uintmax_t )value;
      if (inexact_style == 0) {
        if ((long double )u != value) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      value = (long double )(u + (uintmax_t )tmp);
    }
  }
  return (value);
}
}
static char *group_number(char *number , size_t numberlen , char const   *grouping ,
                          char const   *thousands_sep ) 
{ register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf___1[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL) + 1UL] ;
  unsigned char g ;

  {
  grouplen = 0xffffffffffffffffUL;
  tmp = strlen(thousands_sep);
  thousands_seplen = tmp;
  i = numberlen;
  memcpy((void * __restrict  )(buf___1), (void const   * __restrict  )number, numberlen);
  d = number + numberlen;
  while (1) {
    g = (unsigned char )*grouping;
    if (g) {
      if ((int )g < 127) {
        grouplen = (size_t )g;
      } else {
        grouplen = i;
      }
      grouping ++;
    }
    if (i < grouplen) {
      grouplen = i;
    }
    d -= grouplen;
    i -= grouplen;
    memcpy((void * __restrict  )d, (void const   * __restrict  )(buf___1 + i), grouplen);
    if (i == 0UL) {
      return (d);
    }
    d -= thousands_seplen;
    memcpy((void * __restrict  )d, (void const   * __restrict  )thousands_sep, thousands_seplen);
  }
}
}
char *human_readable(uintmax_t n , char *buf___1 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) 
{ int inexact_style ;
  unsigned int base ;
  int tmp ;
  uintmax_t amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const   *integerlim ;
  int rounding ;
  char const   *decimal_point ;
  size_t decimal_pointlen ;
  char const   *grouping ;
  char const   *thousands_sep ;
  struct lconv  const  *l ;
  struct lconv *tmp___0 ;
  size_t pointlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uintmax_t multiplier ;
  uintmax_t divisor ;
  uintmax_t r10 ;
  uintmax_t r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double tmp___3 ;
  long double e ;
  long double tmp___4 ;
  long double tmp___5 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int digit ;
  uintmax_t power ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  inexact_style = opts & 3;
  if (opts & 32) {
    tmp = 1024;
  } else {
    tmp = 1000;
  }
  base = (unsigned int )tmp;
  exponent = -1;
  exponent_max = (int )(sizeof(power_letter) - 1UL);
  decimal_point = ".";
  decimal_pointlen = (size_t )1;
  grouping = "";
  thousands_sep = "";
  tmp___0 = localeconv();
  l = (struct lconv  const  *)tmp___0;
  tmp___1 = strlen((char const   *)l->decimal_point);
  pointlen = tmp___1;
  if (0UL < pointlen) {
    if (pointlen <= 16UL) {
      decimal_point = (char const   *)l->decimal_point;
      decimal_pointlen = pointlen;
    }
  }
  grouping = (char const   *)l->grouping;
  tmp___2 = strlen((char const   *)l->thousands_sep);
  if (tmp___2 <= 16UL) {
    thousands_sep = (char const   *)l->thousands_sep;
  }
  psuffix = (buf___1 + (((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL)) - 3;
  p = psuffix;
  if (to_block_size <= from_block_size) {
    if (from_block_size % to_block_size == 0UL) {
      multiplier = from_block_size / to_block_size;
      amt = n * multiplier;
      if (amt / multiplier == n) {
        tenths = 0;
        rounding = 0;
        goto use_integer_arithmetic;
      }
    }
  } else
  if (from_block_size != 0UL) {
    if (to_block_size % from_block_size == 0UL) {
      divisor = to_block_size / from_block_size;
      r10 = (n % divisor) * 10UL;
      r2 = (r10 % divisor) * 2UL;
      amt = n / divisor;
      tenths = (int )(r10 / divisor);
      if (r2 < divisor) {
        rounding = 0UL < r2;
      } else {
        rounding = 2 + (divisor < r2);
      }
      goto use_integer_arithmetic;
    }
  }
  dto_block_size = (long double )to_block_size;
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
  if (! (opts & 16)) {
    tmp___3 = adjust_value(inexact_style, damt);
    sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.0Lf", tmp___3);
    buflen = strlen((char const   *)buf___1);
    nonintegerlen = (size_t )0;
  } else {
    e = (long double )1;
    exponent = 0;
    while (1) {
      e *= (long double )base;
      exponent ++;
      if (e * (long double )base <= damt) {
        if (! (exponent < exponent_max)) {
          break;
        }
      } else {
        break;
      }
    }
    damt /= e;
    tmp___4 = adjust_value(inexact_style, damt);
    sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.1Lf", tmp___4);
    buflen = strlen((char const   *)buf___1);
    nonintegerlen = decimal_pointlen + 1UL;
    if ((1UL + nonintegerlen) + (size_t )(! (opts & 32)) < buflen) {
      tmp___5 = adjust_value(inexact_style, damt * (long double )10);
      sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.0Lf",
              tmp___5 / (long double )10);
      buflen = strlen((char const   *)buf___1);
      nonintegerlen = (size_t )0;
    } else
    if (opts & 8) {
      if ((int )*(buf___1 + (buflen - 1UL)) == 48) {
        tmp___5 = adjust_value(inexact_style, damt * (long double )10);
        sprintf((char * __restrict  )buf___1, (char const   * __restrict  )"%.0Lf",
                tmp___5 / (long double )10);
        buflen = strlen((char const   *)buf___1);
        nonintegerlen = (size_t )0;
      }
    }
  }
  p = psuffix - buflen;
  memmove((void *)p, (void const   *)buf___1, buflen);
  integerlim = (char const   *)((p + buflen) - nonintegerlen);
  goto do_grouping;
  use_integer_arithmetic: 
  if (opts & 16) {
    exponent = 0;
    if ((uintmax_t )base <= amt) {
      while (1) {
        r10___0 = (unsigned int )((amt % (unsigned long )base) * 10UL + (unsigned long )tenths);
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
        amt /= (uintmax_t )base;
        tenths = (int )(r10___0 / base);
        if (r2___0 < base) {
          rounding = r2___0 + (unsigned int )rounding != 0U;
        } else {
          rounding = 2 + (base < r2___0 + (unsigned int )rounding);
        }
        exponent ++;
        if ((uintmax_t )base <= amt) {
          if (! (exponent < exponent_max)) {
            break;
          }
        } else {
          break;
        }
      }
      if (amt < 10UL) {
        if (inexact_style == 1) {
          tmp___7 = 2 < rounding + (tenths & 1);
        } else {
          if (inexact_style == 0) {
            if (0 < rounding) {
              tmp___6 = 1;
            } else {
              tmp___6 = 0;
            }
          } else {
            tmp___6 = 0;
          }
          tmp___7 = tmp___6;
        }
        if (tmp___7) {
          tenths ++;
          rounding = 0;
          if (tenths == 10) {
            amt ++;
            tenths = 0;
          }
        }
        if (amt < 10UL) {
          if (tenths) {
            goto _L;
          } else
          if (! (opts & 8)) {
            _L: 
            p --;
            *p = (char )(48 + tenths);
            p -= decimal_pointlen;
            memcpy((void * __restrict  )p, (void const   * __restrict  )decimal_point,
                   decimal_pointlen);
            rounding = 0;
            tenths = rounding;
          }
        }
      }
    }
  }
  if (inexact_style == 1) {
    tmp___9 = 5 < tenths + (0UL < (unsigned long )rounding + (amt & 1UL));
  } else {
    if (inexact_style == 0) {
      if (0 < tenths + rounding) {
        tmp___8 = 1;
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
    tmp___9 = tmp___8;
  }
  if (tmp___9) {
    amt ++;
    if (opts & 16) {
      if (amt == (uintmax_t )base) {
        if (exponent < exponent_max) {
          exponent ++;
          if (! (opts & 8)) {
            p --;
            *p = (char )'0';
            p -= decimal_pointlen;
            memcpy((void * __restrict  )p, (void const   * __restrict  )decimal_point,
                   decimal_pointlen);
          }
          amt = (uintmax_t )1;
        }
      }
    }
  }
  integerlim = (char const   *)p;
  while (1) {
    digit = (int )(amt % 10UL);
    p --;
    *p = (char )(digit + 48);
    amt /= 10UL;
    if (! (amt != 0UL)) {
      break;
    }
  }
  do_grouping: 
  if (opts & 4) {
    p = group_number(p, (size_t )(integerlim - (char const   *)p), grouping, thousands_sep);
  }
  if (opts & 128) {
    if (exponent < 0) {
      exponent = 0;
      power = (uintmax_t )1;
      while (power < to_block_size) {
        exponent ++;
        if (exponent == exponent_max) {
          break;
        }
        power *= (uintmax_t )base;
      }
    }
    if (exponent | (opts & 256)) {
      if (opts & 64) {
        tmp___10 = psuffix;
        psuffix ++;
        *tmp___10 = (char )' ';
      }
    }
    if (exponent) {
      tmp___11 = psuffix;
      psuffix ++;
      if (! (opts & 32)) {
        if (exponent == 1) {
          *tmp___11 = (char )'k';
        } else {
          *tmp___11 = (char )power_letter[exponent];
        }
      } else {
        *tmp___11 = (char )power_letter[exponent];
      }
    }
    if (opts & 256) {
      if (opts & 32) {
        if (exponent) {
          tmp___12 = psuffix;
          psuffix ++;
          *tmp___12 = (char )'i';
        }
      }
      tmp___13 = psuffix;
      psuffix ++;
      *tmp___13 = (char )'B';
    }
  }
  *psuffix = (char )'\000';
  return (p);
}
}
static char const   * const  block_size_args[3]  = {      (char const   * const  )"human-readable",      (char const   * const  )"si",      (char const   * const  )0};
static int const   block_size_opts[2]  = {      (int const   )176,      (int const   )144};
static uintmax_t default_block_size(void) 
{ int tmp___0 ;
  char *tmp___1 ;

  {
  tmp___1 = getenv("POSIXLY_CORRECT");
  if (tmp___1) {
    tmp___0 = 512;
  } else {
    tmp___0 = 1024;
  }
  return ((uintmax_t )tmp___0);
}
}
static strtol_error humblock(char const   *spec , uintmax_t *block_size , int *options ) 
{ int i ;
  int opts ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  opts = 0;
  if (! spec) {
    tmp___1 = getenv("BLOCK_SIZE");
    spec = (char const   *)tmp___1;
    if (spec) {
      goto _L___0;
    } else {
      tmp___2 = getenv("BLOCKSIZE");
      spec = (char const   *)tmp___2;
      if (spec) {
        goto _L___0;
      } else {
        *block_size = default_block_size();
      }
    }
  } else {
    _L___0: 
    if ((int const   )*spec == 39) {
      opts |= 4;
      spec ++;
    }
    tmp___0 = argmatch(spec, block_size_args, (char const   *)(block_size_opts), sizeof(block_size_opts[0]));
    i = (int )tmp___0;
    if (0 <= i) {
      opts |= (int )block_size_opts[i];
      *block_size = (uintmax_t )1;
    } else {
      tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
      e = tmp;
      if ((unsigned int )e != 0U) {
        *options = 0;
        return (e);
      }
      while (1) {
        if (48 <= (int )*spec) {
          if ((int const   )*spec <= 57) {
            break;
          }
        }
        if ((unsigned long )spec == (unsigned long )ptr) {
          opts |= 128;
          if ((int )*(ptr + -1) == 66) {
            opts |= 256;
          }
          if ((int )*(ptr + -1) != 66) {
            opts |= 32;
          } else
          if ((int )*(ptr + -2) == 105) {
            opts |= 32;
          }
          break;
        }
        spec ++;
      }
    }
  }
  *options = opts;
  return ((strtol_error )0);
}
}
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) 
{ strtol_error e ;
  strtol_error tmp ;

  {
  tmp = humblock(spec, block_size, opts);
  e = tmp;
  if (*block_size == 0UL) {
    *block_size = default_block_size();
    e = (strtol_error )4;
  }
  return (e);
}
}
void i_ring_init(I_ring *ir , int default_val ) ;
int i_ring_push(I_ring *ir , int val ) ;
int i_ring_pop(I_ring *ir ) ;
_Bool i_ring_empty(I_ring const   *ir ) ;
void i_ring_init(I_ring *ir , int default_val ) 
{ int i ;

  {
  ir->ir_empty = (_Bool)1;
  ir->ir_front = 0U;
  ir->ir_back = 0U;
  i = 0;
  while (i < 4) {
    ir->ir_data[i] = default_val;
    i ++;
  }
  ir->ir_default_val = default_val;
  return;
}
}
_Bool i_ring_empty(I_ring const   *ir ) 
{ 

  {
  return ((_Bool )ir->ir_empty);
}
}
int i_ring_push(I_ring *ir , int val ) 
{ unsigned int dest_idx ;
  int old_val ;

  {
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
  old_val = ir->ir_data[dest_idx];
  ir->ir_data[dest_idx] = val;
  ir->ir_front = dest_idx;
  if (dest_idx == ir->ir_back) {
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
  ir->ir_empty = (_Bool)0;
  return (old_val);
}
}
int i_ring_pop(I_ring *ir ) 
{ int top_val ;
  _Bool tmp ;

  {
  tmp = i_ring_empty((I_ring const   *)ir);
  if (tmp) {
    abort();
  }
  top_val = ir->ir_data[ir->ir_front];
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
  if (ir->ir_front == ir->ir_back) {
    ir->ir_empty = (_Bool)1;
  } else {
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
  return (top_val);
}
}
char *getuser(uid_t uid ) ;
char *getgroup(gid_t gid ) ;
uid_t *getuidbyname(char const   *user ) ;
gid_t *getgidbyname(char const   *group ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern struct passwd *getpwnam(char const   *__name ) ;
extern struct group *getgrgid(__gid_t __gid ) ;
extern struct group *getgrnam(char const   *__name ) ;
static struct userid *user_alist  ;
static struct userid *nouser_alist  ;
static struct userid *group_alist  ;
static struct userid *nogroup_alist  ;
char *getuser(uid_t uid ) 
{ struct userid *tail ;
  struct userid *match ;
  struct passwd *pwent ;
  struct passwd *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  match = (struct userid *)((void *)0);
  tail = user_alist;
  while (tail) {
    if (tail->id.u == uid) {
      match = tail;
      break;
    }
    tail = tail->next;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    tmp = getpwuid(uid);
    pwent = tmp;
    if (pwent) {
      tmp___0 = (char const   *)pwent->pw_name;
    } else {
      tmp___0 = "";
    }
    name = tmp___0;
    tmp___1 = strlen(name);
    tmp___2 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___1) + 1UL);
    match = (struct userid *)tmp___2;
    match->id.u = uid;
    strcpy((char * __restrict  )(match->name), (char const   * __restrict  )name);
    match->next = user_alist;
    user_alist = match;
  }
  if (match->name[0]) {
    tmp___3 = match->name;
  } else {
    tmp___3 = (char *)((void *)0);
  }
  return (tmp___3);
}
}
uid_t *getuidbyname(char const   *user ) 
{ struct userid *tail ;
  struct passwd *pwent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
  tail = user_alist;
  while (tail) {
    if ((int )tail->name[0] == (int )*user) {
      if (0) {
        __s1_len = __builtin_strlen((char const   *)(tail->name));
        __s2_len = __builtin_strlen(user);
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)(user + 1)) - (size_t )((void const   *)user) == 1UL)) {
            tmp___5 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___5 = 1;
          } else {
            tmp___5 = 0;
          }
        } else {
          tmp___5 = 0;
        }
        if (tmp___5) {
          tmp___0 = __builtin_strcmp((char const   *)(tail->name), user);
          tmp___4 = tmp___0;
        } else {
          tmp___3 = __builtin_strcmp((char const   *)(tail->name), user);
          tmp___4 = tmp___3;
        }
      } else {
        tmp___3 = __builtin_strcmp((char const   *)(tail->name), user);
        tmp___4 = tmp___3;
      }
      if (! tmp___4) {
        return (& tail->id.u);
      }
    }
    tail = tail->next;
  }
  tail = nouser_alist;
  while (tail) {
    if ((int )tail->name[0] == (int )*user) {
      if (0) {
        __s1_len___0 = __builtin_strlen((char const   *)(tail->name));
        __s2_len___0 = __builtin_strlen(user);
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)(user + 1)) - (size_t )((void const   *)user) == 1UL)) {
            tmp___12 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___12 = 1;
          } else {
            tmp___12 = 0;
          }
        } else {
          tmp___12 = 0;
        }
        if (tmp___12) {
          tmp___7 = __builtin_strcmp((char const   *)(tail->name), user);
          tmp___11 = tmp___7;
        } else {
          tmp___10 = __builtin_strcmp((char const   *)(tail->name), user);
          tmp___11 = tmp___10;
        }
      } else {
        tmp___10 = __builtin_strcmp((char const   *)(tail->name), user);
        tmp___11 = tmp___10;
      }
      if (! tmp___11) {
        return ((uid_t *)((void *)0));
      }
    }
    tail = tail->next;
  }
  pwent = getpwnam(user);
  tmp___13 = strlen(user);
  tmp___14 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___13) + 1UL);
  tail = (struct userid *)tmp___14;
  strcpy((char * __restrict  )(tail->name), (char const   * __restrict  )user);
  if (pwent) {
    tail->id.u = pwent->pw_uid;
    tail->next = user_alist;
    user_alist = tail;
    return (& tail->id.u);
  }
  tail->next = nouser_alist;
  nouser_alist = tail;
  return ((uid_t *)((void *)0));
}
}
char *getgroup(gid_t gid ) 
{ struct userid *tail ;
  struct userid *match ;
  struct group *grent ;
  struct group *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  match = (struct userid *)((void *)0);
  tail = group_alist;
  while (tail) {
    if (tail->id.g == gid) {
      match = tail;
      break;
    }
    tail = tail->next;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    tmp = getgrgid(gid);
    grent = tmp;
    if (grent) {
      tmp___0 = (char const   *)grent->gr_name;
    } else {
      tmp___0 = "";
    }
    name = tmp___0;
    tmp___1 = strlen(name);
    tmp___2 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___1) + 1UL);
    match = (struct userid *)tmp___2;
    match->id.g = gid;
    strcpy((char * __restrict  )(match->name), (char const   * __restrict  )name);
    match->next = group_alist;
    group_alist = match;
  }
  if (match->name[0]) {
    tmp___3 = match->name;
  } else {
    tmp___3 = (char *)((void *)0);
  }
  return (tmp___3);
}
}
gid_t *getgidbyname(char const   *group ) 
{ struct userid *tail ;
  struct group *grent ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;

  {
  tail = group_alist;
  while (tail) {
    if ((int )tail->name[0] == (int )*group) {
      if (0) {
        __s1_len = __builtin_strlen((char const   *)(tail->name));
        __s2_len = __builtin_strlen(group);
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)(group + 1)) - (size_t )((void const   *)group) == 1UL)) {
            tmp___5 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___5 = 1;
          } else {
            tmp___5 = 0;
          }
        } else {
          tmp___5 = 0;
        }
        if (tmp___5) {
          tmp___0 = __builtin_strcmp((char const   *)(tail->name), group);
          tmp___4 = tmp___0;
        } else {
          tmp___3 = __builtin_strcmp((char const   *)(tail->name), group);
          tmp___4 = tmp___3;
        }
      } else {
        tmp___3 = __builtin_strcmp((char const   *)(tail->name), group);
        tmp___4 = tmp___3;
      }
      if (! tmp___4) {
        return (& tail->id.g);
      }
    }
    tail = tail->next;
  }
  tail = nogroup_alist;
  while (tail) {
    if ((int )tail->name[0] == (int )*group) {
      if (0) {
        __s1_len___0 = __builtin_strlen((char const   *)(tail->name));
        __s2_len___0 = __builtin_strlen(group);
        if (! ((size_t )((void const   *)(tail->name + 1)) - (size_t )((void const   *)(tail->name)) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)(group + 1)) - (size_t )((void const   *)group) == 1UL)) {
            tmp___12 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___12 = 1;
          } else {
            tmp___12 = 0;
          }
        } else {
          tmp___12 = 0;
        }
        if (tmp___12) {
          tmp___7 = __builtin_strcmp((char const   *)(tail->name), group);
          tmp___11 = tmp___7;
        } else {
          tmp___10 = __builtin_strcmp((char const   *)(tail->name), group);
          tmp___11 = tmp___10;
        }
      } else {
        tmp___10 = __builtin_strcmp((char const   *)(tail->name), group);
        tmp___11 = tmp___10;
      }
      if (! tmp___11) {
        return ((gid_t *)((void *)0));
      }
    }
    tail = tail->next;
  }
  grent = getgrnam(group);
  tmp___13 = strlen(group);
  tmp___14 = xmalloc(((size_t )((unsigned int )(& ((struct userid *)0)->name)) + tmp___13) + 1UL);
  tail = (struct userid *)tmp___14;
  strcpy((char * __restrict  )(tail->name), (char const   * __restrict  )group);
  if (grent) {
    tail->id.g = grent->gr_gid;
    tail->next = group_alist;
    group_alist = tail;
    return (& tail->id.g);
  }
  tail->next = nogroup_alist;
  nogroup_alist = tail;
  return ((gid_t *)((void *)0));
}
}
void ino_map_free(struct ino_map *map )  __attribute__((__nonnull__(1))) ;
static size_t ino_hash(void const   *x , size_t table_size ) 
{ struct ino_map_ent  const  *p ;
  ino_t ino ;
  size_t h ;
  unsigned int i ;
  unsigned int n_words ;

  {
  p = (struct ino_map_ent  const  *)x;
  ino = (ino_t )p->ino;
  h = ino;
  n_words = (unsigned int )(sizeof(ino) / sizeof(h) + (unsigned long )(sizeof(ino) % sizeof(h) != 0UL));
  i = 1U;
  while (i < n_words) {
    h ^= ino >> (8UL * sizeof(h)) * (unsigned long )i;
    i ++;
  }
  return (h % table_size);
}
}
static _Bool ino_compare(void const   *x , void const   *y ) 
{ struct ino_map_ent  const  *a ;
  struct ino_map_ent  const  *b ;

  {
  a = (struct ino_map_ent  const  *)x;
  b = (struct ino_map_ent  const  *)y;
  return ((_Bool )(a->ino == b->ino));
}
}
struct ino_map *ino_map_alloc(size_t next_mapped_ino ) 
{ struct ino_map *im ;
  void *tmp ;

  {
  tmp = malloc(sizeof(*im));
  im = (struct ino_map *)tmp;
  if (im) {
    im->map = hash_initialize((size_t )1021, (Hash_tuning const   *)((void *)0), & ino_hash,
                              & ino_compare, & free);
    if (! im->map) {
      free((void *)im);
      return ((struct ino_map *)((void *)0));
    }
    im->next_mapped_ino = next_mapped_ino;
    im->probe = (struct ino_map_ent *)((void *)0);
  }
  return (im);
}
}
void ino_map_free(struct ino_map *map )  __attribute__((__nonnull__(1))) ;
void ino_map_free(struct ino_map *map ) 
{ 

  {
  hash_free(map->map);
  free((void *)map->probe);
  free((void *)map);
  return;
}
}
size_t ino_map_insert(struct ino_map *im , ino_t ino )  __attribute__((__nonnull__(1))) ;
size_t ino_map_insert(struct ino_map *im , ino_t ino ) 
{ struct ino_map_ent *ent ;
  struct ino_map_ent *probe ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  probe = im->probe;
  if (probe) {
    if (probe->ino == ino) {
      return (probe->mapped_ino);
    }
  } else {
    tmp = malloc(sizeof(*probe));
    probe = (struct ino_map_ent *)tmp;
    im->probe = probe;
    if (! probe) {
      return ((size_t )-1);
    }
  }
  probe->ino = ino;
  tmp___0 = hash_insert(im->map, (void const   *)probe);
  ent = (struct ino_map_ent *)tmp___0;
  if (! ent) {
    return ((size_t )-1);
  }
  if ((unsigned long )ent != (unsigned long )probe) {
    probe->mapped_ino = ent->mapped_ino;
  } else {
    im->probe = (struct ino_map_ent *)((void *)0);
    tmp___1 = im->next_mapped_ino;
    (im->next_mapped_ino) ++;
    probe->mapped_ino = tmp___1;
  }
  return (probe->mapped_ino);
}
}
char * __attribute__((__warn_unused_result__)) imaxtostr(intmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) imaxtostr(intmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) imaxtostr(intmax_t i , char *buf___1 ) 
{ char *p ;

  {
  p = buf___1 + (((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
  *p = (char)0;
  if (i < 0L) {
    while (1) {
      p --;
      *p = (char )(48L - i % 10L);
      i /= 10L;
      if (! (i != 0L)) {
        break;
      }
    }
    p --;
    *p = (char )'-';
  } else {
    while (1) {
      p --;
      *p = (char )(48L + i % 10L);
      i /= 10L;
      if (! (i != 0L)) {
        break;
      }
    }
  }
  return (p);
}
}
char * __attribute__((__warn_unused_result__)) inttostr(int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) inttostr(int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) inttostr(int i , char *buf___1 ) 
{ char *p ;

  {
  p = buf___1 + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
  *p = (char)0;
  if (i < 0) {
    while (1) {
      p --;
      *p = (char )(48 - i % 10);
      i /= 10;
      if (! (i != 0)) {
        break;
      }
    }
    p --;
    *p = (char )'-';
  } else {
    while (1) {
      p --;
      *p = (char )(48 + i % 10);
      i /= 10;
      if (! (i != 0)) {
        break;
      }
    }
  }
  return (p);
}
}
char * __attribute__((__warn_unused_result__)) offtostr(off_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) offtostr(off_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) offtostr(off_t i , char *buf___1 ) 
{ char *p ;

  {
  p = buf___1 + (((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
  *p = (char)0;
  if (i < 0L) {
    while (1) {
      p --;
      *p = (char )(48L - i % 10L);
      i /= 10L;
      if (! (i != 0L)) {
        break;
      }
    }
    p --;
    *p = (char )'-';
  } else {
    while (1) {
      p --;
      *p = (char )(48L + i % 10L);
      i /= 10L;
      if (! (i != 0L)) {
        break;
      }
    }
  }
  return (p);
}
}
char * __attribute__((__warn_unused_result__)) uinttostr(unsigned int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) uinttostr(unsigned int i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) uinttostr(unsigned int i , char *buf___1 ) 
{ char *p ;

  {
  p = buf___1 + ((sizeof(unsigned int ) * 8UL) * 146UL + 484UL) / 485UL;
  *p = (char)0;
  if (i < 0U) {
    while (1) {
      p --;
      *p = (char )(48U - i % 10U);
      i /= 10U;
      if (! (i != 0U)) {
        break;
      }
    }
    p --;
    *p = (char )'-';
  } else {
    while (1) {
      p --;
      *p = (char )(48U + i % 10U);
      i /= 10U;
      if (! (i != 0U)) {
        break;
      }
    }
  }
  return (p);
}
}
char * __attribute__((__warn_unused_result__)) umaxtostr(uintmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) umaxtostr(uintmax_t i , char *buf___1 )  __attribute__((__warn_unused_result__)) ;
char * __attribute__((__warn_unused_result__)) umaxtostr(uintmax_t i , char *buf___1 ) 
{ char *p ;

  {
  p = buf___1 + ((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL;
  *p = (char)0;
  if (i < 0UL) {
    while (1) {
      p --;
      *p = (char )(48UL - i % 10UL);
      i /= 10UL;
      if (! (i != 0UL)) {
        break;
      }
    }
    p --;
    *p = (char )'-';
  } else {
    while (1) {
      p --;
      *p = (char )(48UL + i % 10UL);
      i /= 10UL;
      if (! (i != 0UL)) {
        break;
      }
    }
  }
  return (p);
}
}
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x ) ;
extern  __attribute__((__nothrow__)) long double strtold(char const   * __restrict  __nptr ,
                                                         char ** __restrict  __endptr )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
int ldtoastr(char *buf___1 , size_t bufsize___0 , int flags , int width , long double x ) 
{ char format[sizeof("%-+ 0*.*Lg")] ;
  long double abs_x ;
  long double tmp ;
  int prec ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int n ;
  int __attribute__((__artificial__))  tmp___5 ;
  long double tmp___6 ;

  {
  if (x < (long double )0) {
    tmp = - x;
  } else {
    tmp = x;
  }
  abs_x = tmp;
  p = format;
  tmp___0 = p;
  p ++;
  *tmp___0 = (char )'%';
  *p = (char )'-';
  p += (flags & 1) != 0;
  *p = (char )'+';
  p += (flags & 2) != 0;
  *p = (char )' ';
  p += (flags & 4) != 0;
  *p = (char )'0';
  p += (flags & 8) != 0;
  tmp___1 = p;
  p ++;
  *tmp___1 = (char )'*';
  tmp___2 = p;
  p ++;
  *tmp___2 = (char )'.';
  tmp___3 = p;
  p ++;
  *tmp___3 = (char )'*';
  *p = (char )'L';
  p ++;
  tmp___4 = p;
  p ++;
  if (flags & 16) {
    *tmp___4 = (char )'G';
  } else {
    *tmp___4 = (char )'g';
  }
  *p = (char )'\000';
  if (abs_x < 3.36210314311209350626e-4932L) {
    prec = 1;
  } else {
    prec = 18;
  }
  while (1) {
    tmp___5 = snprintf((char * __restrict  )buf___1, bufsize___0, (char const   * __restrict  )(format),
                       width, prec, x);
    n = (int )tmp___5;
    if (n < 0) {
      return (n);
    } else
    if (21 <= prec) {
      return (n);
    } else
    if ((size_t )n < bufsize___0) {
      tmp___6 = strtold((char const   * __restrict  )buf___1, (char ** __restrict  )((void *)0));
      if (tmp___6 == x) {
        return (n);
      }
    }
    prec ++;
  }
}
}
void initbuffer(struct linebuffer *linebuffer ) ;
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
void freebuffer(struct linebuffer *linebuffer ) ;
void initbuffer(struct linebuffer *linebuffer ) 
{ 

  {
  memset((void *)linebuffer, 0, sizeof(*linebuffer));
  return;
}
}
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) 
{ struct linebuffer *tmp ;

  {
  tmp = readlinebuffer_delim(linebuffer, stream, (char )'\n');
  return (tmp);
}
}
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) 
{ int c ;
  char *buffer ;
  char *p ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  size_t oldsize ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  buffer = linebuffer->buffer;
  p = linebuffer->buffer;
  end = buffer + linebuffer->size;
  tmp = feof_unlocked(stream);
  if (tmp) {
    return ((struct linebuffer *)((void *)0));
  }
  while (1) {
    c = getc_unlocked(stream);
    if (c == -1) {
      if ((unsigned long )p == (unsigned long )buffer) {
        return ((struct linebuffer *)((void *)0));
      } else {
        tmp___0 = ferror_unlocked(stream);
        if (tmp___0) {
          return ((struct linebuffer *)((void *)0));
        }
      }
      if ((int )*(p + -1) == (int )delimiter) {
        break;
      }
      c = (int )delimiter;
    }
    if ((unsigned long )p == (unsigned long )end) {
      oldsize = linebuffer->size;
      tmp___1 = x2realloc((void *)buffer, & linebuffer->size);
      buffer = (char *)tmp___1;
      p = buffer + oldsize;
      linebuffer->buffer = buffer;
      end = buffer + linebuffer->size;
    }
    tmp___2 = p;
    p ++;
    *tmp___2 = (char )c;
    if (! (c != (int )delimiter)) {
      break;
    }
  }
  linebuffer->length = (size_t )(p - buffer);
  return (linebuffer);
}
}
void freebuffer(struct linebuffer *linebuffer ) 
{ 

  {
  free((void *)linebuffer->buffer);
  return;
}
}
char const   *locale_charset(void) ;
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __attribute__((__warn_unused_result__)) ;
extern int ungetc(int __c , FILE *__stream ) ;
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
static char const   * volatile  charset_aliases  ;
static char const   *get_charset_aliases(void) 
{ char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  int __attribute__((__artificial__))  tmp___4 ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  cp = (char const   *)charset_aliases;
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    base = "charset.alias";
    tmp = getenv("CHARSETALIASDIR");
    dir = (char const   *)tmp;
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      dir = "/usr/local/lib";
    } else
    if ((int const   )*(dir + 0) == 0) {
      dir = "/usr/local/lib";
    }
    tmp___0 = strlen(dir);
    dir_len___0 = tmp___0;
    tmp___1 = strlen(base);
    base_len___0 = tmp___1;
    if (dir_len___0 > 0UL) {
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
    add_slash = tmp___2;
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
    file_name___1 = (char *)tmp___3;
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
      memcpy((void * __restrict  )file_name___1, (void const   * __restrict  )dir,
             dir_len___0);
      if (add_slash) {
        *(file_name___1 + dir_len___0) = (char )'/';
      }
      memcpy((void * __restrict  )((file_name___1 + dir_len___0) + add_slash), (void const   * __restrict  )base,
             base_len___0 + 1UL);
    }
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
      cp = "";
    } else {
      tmp___4 = open((char const   *)file_name___1, 131072);
      fd = (int )tmp___4;
      if (fd < 0) {
        cp = "";
      } else {
        fp = fdopen(fd, "r");
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          close(fd);
          cp = "";
        } else {
          res_ptr = (char *)((void *)0);
          res_size = (size_t )0;
          while (1) {
            c = getc_unlocked(fp);
            if (c == -1) {
              break;
            }
            if (c == 10) {
              goto __Cont;
            } else
            if (c == 32) {
              goto __Cont;
            } else
            if (c == 9) {
              goto __Cont;
            }
            if (c == 35) {
              while (1) {
                c = getc_unlocked(fp);
                if (c == -1) {
                  break;
                } else
                if (c == 10) {
                  break;
                }
              }
              if (c == -1) {
                break;
              }
              goto __Cont;
            }
            ungetc(c, fp);
            tmp___5 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%50s %50s",
                             buf1, buf2);
            if (tmp___5 < 2) {
              break;
            }
            l1 = strlen((char const   *)(buf1));
            l2 = strlen((char const   *)(buf2));
            old_res_ptr = res_ptr;
            if (res_size == 0UL) {
              res_size = ((l1 + 1UL) + l2) + 1UL;
              tmp___6 = malloc(res_size + 1UL);
              res_ptr = (char *)tmp___6;
            } else {
              res_size += ((l1 + 1UL) + l2) + 1UL;
              tmp___7 = realloc((void *)res_ptr, res_size + 1UL);
              res_ptr = (char *)tmp___7;
            }
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              res_size = (size_t )0;
              free((void *)old_res_ptr);
              break;
            }
            strcpy((char * __restrict  )(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   * __restrict  )(buf1));
            strcpy((char * __restrict  )((res_ptr + res_size) - (l2 + 1UL)), (char const   * __restrict  )(buf2));
            __Cont: ;
          }
          rpl_fclose(fp);
          if (res_size == 0UL) {
            cp = "";
          } else {
            *(res_ptr + res_size) = (char )'\000';
            cp = (char const   *)res_ptr;
          }
        }
      }
      free((void *)file_name___1);
    }
    charset_aliases = (char const   * volatile  )cp;
  }
  return (cp);
}
}
char const   *locale_charset(void) 
{ char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = nl_langinfo(14);
  codeset = (char const   *)tmp;
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
    codeset = "";
  }
  aliases = get_charset_aliases();
  while ((int const   )*aliases != 0) {
    if (0) {
      __s1_len = __builtin_strlen(codeset);
      __s2_len = __builtin_strlen(aliases);
      if (! ((size_t )((void const   *)(codeset + 1)) - (size_t )((void const   *)codeset) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)(aliases + 1)) - (size_t )((void const   *)aliases) == 1UL)) {
          tmp___9 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      if (tmp___9) {
        tmp___4 = __builtin_strcmp(codeset, aliases);
        tmp___8 = tmp___4;
      } else {
        tmp___7 = __builtin_strcmp(codeset, aliases);
        tmp___8 = tmp___7;
      }
    } else {
      tmp___7 = __builtin_strcmp(codeset, aliases);
      tmp___8 = tmp___7;
    }
    if (tmp___8 == 0) {
      tmp___2 = strlen(aliases);
      codeset = (aliases + tmp___2) + 1;
      break;
    } else
    if ((int const   )*(aliases + 0) == 42) {
      if ((int const   )*(aliases + 1) == 0) {
        tmp___2 = strlen(aliases);
        codeset = (aliases + tmp___2) + 1;
        break;
      }
    }
    tmp___0 = strlen(aliases);
    aliases += tmp___0 + 1UL;
    tmp___1 = strlen(aliases);
    aliases += tmp___1 + 1UL;
  }
  if ((int const   )*(codeset + 0) == 0) {
    codeset = "ASCII";
  }
  return (codeset);
}
}
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 

  {
  return (__thread1 == __thread2);
}
}
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) 
{ pthread_mutexattr_t attributes ;
  int err ;

  {
  err = pthread_mutexattr_init(& attributes);
  if (err != 0) {
    return (err);
  }
  err = pthread_mutexattr_settype(& attributes, 1);
  if (err != 0) {
    pthread_mutexattr_destroy(& attributes);
    return (err);
  }
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
  if (err != 0) {
    pthread_mutexattr_destroy(& attributes);
    return (err);
  }
  err = pthread_mutexattr_destroy(& attributes);
  if (err != 0) {
    return (err);
  }
  return (0);
}
}
static int const   fresh_once  =    (pthread_once_t const   )0;
int glthread_once_singlethreaded(pthread_once_t *once_control ) 
{ char *firstbyte ;

  {
  firstbyte = (char *)once_control;
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
    return (1);
  } else {
    return (0);
  }
}
}
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
int rpl_optind ;
int rpl_opterr ;
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options ,
                                                  struct rpl_option  const  *long_options___1 ,
                                                  int *opt_index )  __attribute__((__nonnull__(2,3))) ;
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
static struct rpl_option  const  long_options[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) 
{ int c ;
  int saved_opterr ;
  va_list authors ;

  {
  saved_opterr = rpl_opterr;
  rpl_opterr = 0;
  if (argc == 2) {
    c = rpl_getopt_long(argc, argv, "+", long_options, (int *)((void *)0));
    if (c != -1) {
      switch (c) {
      case 104: 
      (*usage_func)(0);
      case 118: 
      __builtin_va_start(authors, usage_func);
      version_etc_va(stdout, command_name, package, version, authors);
      exit(0);
      default: 
      break;
      }
    }
  }
  rpl_opterr = saved_opterr;
  rpl_optind = 0;
  return;
}
}
void *mmalloca(size_t n ) ;
void freea(void *p ) ;
static void *mmalloca_results[257]  ;
void *mmalloca(size_t n ) 
{ size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
  if (nplus >= n) {
    tmp = malloc(nplus);
    p = (char *)tmp;
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
      *((int *)p + -1) = 336984906;
      slot = (unsigned long )p % 257UL;
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
      mmalloca_results[slot] = (void *)p;
      return ((void *)p);
    }
  }
  return ((void *)0);
}
}
void freea(void *p ) 
{ size_t slot ;
  void **chain ;
  char *p_begin ;

  {
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    if (*((int *)p + -1) == 336984906) {
      slot = (unsigned long )p % 257UL;
      chain = & mmalloca_results[slot];
      while ((unsigned long )*chain != (unsigned long )((void *)0)) {
        if ((unsigned long )*chain == (unsigned long )p) {
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
          *chain = ((struct header *)p_begin)->next;
          free((void *)p_begin);
          return;
        }
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
    }
  }
  return;
}
}
unsigned int const   is_basic_table[8]  = 
  {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646, 
        (unsigned int const   )0U,      (unsigned int const   )0U,      (unsigned int const   )0U,      (unsigned int const   )0U};
size_t mbsalign(char const   *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags ) ;
char *ambsalign(char const   *src , size_t *width , mbs_align_t align , int flags ) ;
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
extern  __attribute__((__nothrow__)) int wcswidth(wchar_t const   *__s , size_t __n ) ;
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
static _Bool wc_ensure_printable(wchar_t *wchars ) 
{ _Bool replaced ;
  wchar_t *wc ;
  int tmp ;

  {
  replaced = (_Bool)0;
  wc = wchars;
  while (*wc) {
    tmp = iswprint((wint_t )*wc);
    if (! tmp) {
      *wc = 65533;
      replaced = (_Bool)1;
    }
    wc ++;
  }
  return (replaced);
}
}
static size_t wc_truncate(wchar_t *wc , size_t width ) 
{ size_t cells ;
  int next_cells ;

  {
  cells = (size_t )0;
  next_cells = 0;
  while (*wc) {
    next_cells = wcwidth(*wc);
    if (next_cells == -1) {
      *wc = 65533;
      next_cells = 1;
    }
    if (cells + (size_t )next_cells > width) {
      break;
    }
    cells += (size_t )next_cells;
    wc ++;
  }
  *wc = 0;
  return (cells);
}
}
static char *mbs_align_pad(char *dest , char const   *dest_end , size_t n_spaces ) 
{ char *tmp ;
  size_t tmp___0 ;

  {
  while (1) {
    tmp___0 = n_spaces;
    n_spaces --;
    if (tmp___0) {
      if (! ((unsigned long )dest < (unsigned long )dest_end)) {
        break;
      }
    } else {
      break;
    }
    tmp = dest;
    dest ++;
    *tmp = (char )' ';
  }
  *dest = (char )'\000';
  return (dest);
}
}
size_t mbsalign(char const   *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags ) 
{ size_t ret ;
  size_t src_size ;
  size_t tmp ;
  char *newstr ;
  wchar_t *str_wc ;
  char const   *str_to_print ;
  size_t n_cols ;
  size_t n_used_bytes ;
  size_t n_spaces ;
  _Bool conversion ;
  _Bool wc_enabled ;
  size_t src_chars ;
  size_t __attribute__((__artificial__))  tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t __attribute__((__artificial__))  tmp___3 ;
  size_t tmp___4 ;
  size_t __attribute__((__artificial__))  tmp___5 ;
  void *tmp___6 ;
  size_t __attribute__((__artificial__))  tmp___7 ;
  size_t start_spaces ;
  size_t end_spaces ;
  size_t space_left ;
  char *dest_end ;
  size_t tmp___8 ;
  void __attribute__((__artificial__))  *tmp___9 ;

  {
  ret = 0xffffffffffffffffUL;
  tmp = strlen(src);
  src_size = tmp + 1UL;
  newstr = (char *)((void *)0);
  str_wc = (wchar_t *)((void *)0);
  str_to_print = src;
  n_cols = src_size - 1UL;
  n_used_bytes = n_cols;
  n_spaces = (size_t )0;
  conversion = (_Bool)0;
  wc_enabled = (_Bool)0;
  tmp___4 = __ctype_get_mb_cur_max();
  if (tmp___4 > 1UL) {
    tmp___0 = mbstowcs((wchar_t * __restrict  )((void *)0), (char const   * __restrict  )src,
                       (size_t )0);
    src_chars = (size_t )tmp___0;
    if (src_chars == 0xffffffffffffffffUL) {
      if (flags & 1) {
        goto mbsalign_unibyte;
      } else {
        goto mbsalign_cleanup;
      }
    }
    src_chars ++;
    tmp___1 = malloc(src_chars * sizeof(wchar_t ));
    str_wc = (wchar_t *)tmp___1;
    if ((unsigned long )str_wc == (unsigned long )((void *)0)) {
      if (flags & 1) {
        goto mbsalign_unibyte;
      } else {
        goto mbsalign_cleanup;
      }
    }
    tmp___3 = mbstowcs((wchar_t * __restrict  )str_wc, (char const   * __restrict  )src,
                       src_chars);
    if (tmp___3 != (size_t __attribute__((__artificial__))  )0) {
      *(str_wc + (src_chars - 1UL)) = 0;
      wc_enabled = (_Bool)1;
      conversion = wc_ensure_printable(str_wc);
      tmp___2 = wcswidth((wchar_t const   *)str_wc, src_chars);
      n_cols = (size_t )tmp___2;
    }
  }
  if (wc_enabled) {
    if (conversion) {
      goto _L;
    } else
    if (n_cols > *width) {
      _L: 
      if (conversion) {
        tmp___5 = wcstombs((char * __restrict  )((void *)0), (wchar_t const   * __restrict  )str_wc,
                           (size_t )0);
        src_size = (size_t )(tmp___5 + (size_t __attribute__((__artificial__))  )1);
      }
      tmp___6 = malloc(src_size);
      newstr = (char *)tmp___6;
      if ((unsigned long )newstr == (unsigned long )((void *)0)) {
        if (flags & 1) {
          goto mbsalign_unibyte;
        } else {
          goto mbsalign_cleanup;
        }
      }
      str_to_print = (char const   *)newstr;
      n_cols = wc_truncate(str_wc, *width);
      tmp___7 = wcstombs((char * __restrict  )newstr, (wchar_t const   * __restrict  )str_wc,
                         src_size);
      n_used_bytes = (size_t )tmp___7;
    }
  }
  mbsalign_unibyte: 
  if (n_cols > *width) {
    n_cols = *width;
    n_used_bytes = n_cols;
  }
  if (*width > n_cols) {
    n_spaces = *width - n_cols;
  }
  *width = n_cols;
  ret = n_used_bytes + n_spaces;
  if (dest_size != 0UL) {
    dest_end = (dest + dest_size) - 1;
    switch ((int )align) {
    case 0: 
    start_spaces = (size_t )0;
    end_spaces = n_spaces;
    break;
    case 1: 
    start_spaces = n_spaces;
    end_spaces = (size_t )0;
    break;
    default: 
    start_spaces = n_spaces / 2UL + n_spaces % 2UL;
    end_spaces = n_spaces / 2UL;
    break;
    }
    dest = mbs_align_pad(dest, (char const   *)dest_end, start_spaces);
    space_left = (size_t )(dest_end - dest);
    if (n_used_bytes < space_left) {
      tmp___8 = n_used_bytes;
    } else {
      tmp___8 = space_left;
    }
    tmp___9 = mempcpy((void * __restrict  )dest, (void const   * __restrict  )str_to_print,
                      tmp___8);
    dest = (char *)tmp___9;
    mbs_align_pad(dest, (char const   *)dest_end, end_spaces);
  }
  mbsalign_cleanup: 
  free((void *)str_wc);
  free((void *)newstr);
  return (ret);
}
}
char *ambsalign(char const   *src , size_t *width , mbs_align_t align , int flags ) 
{ size_t orig_width ;
  size_t size ;
  size_t req ;
  char *buf___1 ;
  char *nbuf ;
  void *tmp ;

  {
  orig_width = *width;
  size = *width;
  req = size;
  buf___1 = (char *)((void *)0);
  while (req >= size) {
    size = req + 1UL;
    tmp = realloc((void *)buf___1, size);
    nbuf = (char *)tmp;
    if ((unsigned long )nbuf == (unsigned long )((void *)0)) {
      free((void *)buf___1);
      buf___1 = (char *)((void *)0);
      break;
    }
    buf___1 = nbuf;
    *width = orig_width;
    req = mbsalign(src, buf___1, size, width, align, flags);
    if (req == 0xffffffffffffffffUL) {
      free((void *)buf___1);
      buf___1 = (char *)((void *)0);
      break;
    }
  }
  return (buf___1);
}
}
int mbscasecmp(char const   *s1 , char const   *s2 )  __attribute__((__nonnull__(1,2))) ;
int mbscasecmp(char const   *s1 , char const   *s2 ) 
{ mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __res ;
  __int32_t const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  int __res___0 ;
  __int32_t const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  size_t tmp___27 ;

  {
  if ((unsigned long )s1 == (unsigned long )s2) {
    return (0);
  }
  tmp___27 = __ctype_get_mb_cur_max();
  if (tmp___27 > 1UL) {
    iter1.cur.ptr = s1;
    iter1.in_shift = (_Bool)0;
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
    iter1.next_done = (_Bool)0;
    iter2.cur.ptr = s2;
    iter2.in_shift = (_Bool)0;
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
    iter2.next_done = (_Bool)0;
    while (1) {
      mbuiter_multi_next(& iter1);
      if (iter1.cur.wc_valid) {
        if (iter1.cur.wc == 0) {
          tmp___13 = 0;
        } else {
          tmp___13 = 1;
        }
      } else {
        tmp___13 = 1;
      }
      if (tmp___13) {
        mbuiter_multi_next(& iter2);
        if (iter2.cur.wc_valid) {
          if (iter2.cur.wc == 0) {
            tmp___14 = 0;
          } else {
            tmp___14 = 1;
          }
        } else {
          tmp___14 = 1;
        }
        if (! tmp___14) {
          break;
        }
      } else {
        break;
      }
      if (iter1.cur.wc_valid) {
        if (iter2.cur.wc_valid) {
          tmp = towlower((wint_t )iter1.cur.wc);
          tmp___0 = towlower((wint_t )iter2.cur.wc);
          tmp___1 = (int )tmp - (int )tmp___0;
        } else {
          tmp___1 = -1;
        }
        tmp___12 = tmp___1;
      } else {
        if (iter2.cur.wc_valid) {
          tmp___11 = 1;
        } else {
          if (iter1.cur.bytes == iter2.cur.bytes) {
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
            tmp___10 = tmp___2;
          } else {
            if (iter1.cur.bytes < iter2.cur.bytes) {
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              if (tmp___5 > 0) {
                tmp___4 = 1;
              } else {
                tmp___4 = -1;
              }
              tmp___9 = tmp___4;
            } else {
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              if (tmp___8 >= 0) {
                tmp___7 = 1;
              } else {
                tmp___7 = -1;
              }
              tmp___9 = tmp___7;
            }
            tmp___10 = tmp___9;
          }
          tmp___11 = tmp___10;
        }
        tmp___12 = tmp___11;
      }
      cmp = tmp___12;
      if (cmp != 0) {
        return (cmp);
      }
      iter1.cur.ptr += iter1.cur.bytes;
      iter1.next_done = (_Bool)0;
      iter2.cur.ptr += iter2.cur.bytes;
      iter2.next_done = (_Bool)0;
    }
    mbuiter_multi_next(& iter1);
    if (iter1.cur.wc_valid) {
      if (iter1.cur.wc == 0) {
        tmp___15 = 0;
      } else {
        tmp___15 = 1;
      }
    } else {
      tmp___15 = 1;
    }
    if (tmp___15) {
      return (1);
    }
    mbuiter_multi_next(& iter2);
    if (iter2.cur.wc_valid) {
      if (iter2.cur.wc == 0) {
        tmp___16 = 0;
      } else {
        tmp___16 = 1;
      }
    } else {
      tmp___16 = 1;
    }
    if (tmp___16) {
      return (-1);
    }
    return (0);
  } else {
    p1 = (unsigned char const   *)s1;
    p2 = (unsigned char const   *)s2;
    while (1) {
      tmp___20 = __ctype_b_loc();
      if ((int const   )*(*tmp___20 + (int )*p1) & 256) {
        if (sizeof(*p1) > 1UL) {
          __res = tolower((int )*p1);
        } else {
          tmp___19 = __ctype_tolower_loc();
          __res = (int )*(*tmp___19 + (int )*p1);
        }
        c1 = (unsigned char )__res;
      } else {
        c1 = (unsigned char )*p1;
      }
      tmp___24 = __ctype_b_loc();
      if ((int const   )*(*tmp___24 + (int )*p2) & 256) {
        if (sizeof(*p2) > 1UL) {
          __res___0 = tolower((int )*p2);
        } else {
          tmp___23 = __ctype_tolower_loc();
          __res___0 = (int )*(*tmp___23 + (int )*p2);
        }
        c2 = (unsigned char )__res___0;
      } else {
        c2 = (unsigned char )*p2;
      }
      if ((int )c1 == 0) {
        break;
      }
      p1 ++;
      p2 ++;
      if (! ((int )c1 == (int )c2)) {
        break;
      }
    }
    return ((int )c1 - (int )c2);
  }
}
}
size_t mbslen(char const   *string )  __attribute__((__nonnull__(1))) ;
size_t mbslen(char const   *string )  __attribute__((__nonnull__(1))) ;
size_t mbslen(char const   *string ) 
{ size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp___1 = __ctype_get_mb_cur_max();
  if (tmp___1 > 1UL) {
    count = (size_t )0;
    iter.cur.ptr = string;
    iter.in_shift = (_Bool)0;
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
    iter.next_done = (_Bool)0;
    while (1) {
      mbuiter_multi_next(& iter);
      if (iter.cur.wc_valid) {
        if (iter.cur.wc == 0) {
          tmp = 0;
        } else {
          tmp = 1;
        }
      } else {
        tmp = 1;
      }
      if (! tmp) {
        break;
      }
      count ++;
      iter.cur.ptr += iter.cur.bytes;
      iter.next_done = (_Bool)0;
    }
    return (count);
  } else {
    tmp___0 = strlen(string);
    return (tmp___0);
  }
}
}
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen )  __attribute__((__pure__,
__nonnull__(1))) ;
char *mbsstr(char const   *haystack , char const   *needle )  __attribute__((__nonnull__(1,2))) ;
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ _Bool tmp ;

  {
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    memcpy((void * __restrict  )(& new_mbc->buf[0]), (void const   * __restrict  )(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
  } else {
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
  new_mbc->bytes = (size_t )old_mbc->bytes;
  tmp = (_Bool )old_mbc->wc_valid;
  new_mbc->wc_valid = tmp;
  if (tmp) {
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
  return;
}
}
static _Bool knuth_morris_pratt(unsigned char const   *haystack , unsigned char const   *needle ,
                                size_t needle_len , unsigned char const   **resultp ) 
{ size_t m ;
  size_t *table___1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  unsigned char const   *rhaystack ;
  unsigned char const   *phaystack ;

  {
  m = needle_len;
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    tmp___4 = -1;
  } else {
    tmp___4 = -2;
  }
  if (m > (size_t )tmp___4 / sizeof(size_t )) {
    tmp___3 = (void *)0;
  } else {
    if (m * sizeof(size_t ) < 4016UL) {
      tmp___0 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
      tmp___2 = (void *)((char *)tmp___0 + 16);
    } else {
      tmp___1 = mmalloca(m * sizeof(size_t ));
      tmp___2 = tmp___1;
    }
    tmp___3 = tmp___2;
  }
  table___1 = (size_t *)tmp___3;
  if ((unsigned long )table___1 == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  *(table___1 + 1) = (size_t )1;
  j = (size_t )0;
  i = (size_t )2;
  while (i < m) {
    b = (unsigned char )*(needle + (i - 1UL));
    while (1) {
      if ((int )b == (int )*(needle + j)) {
        j ++;
        *(table___1 + i) = i - j;
        break;
      }
      if (j == 0UL) {
        *(table___1 + i) = i;
        break;
      }
      j -= *(table___1 + j);
    }
    i ++;
  }
  *resultp = (unsigned char const   *)((void *)0);
  j___0 = (size_t )0;
  rhaystack = haystack;
  phaystack = haystack;
  while ((int const   )*phaystack != 0) {
    if ((int const   )*(needle + j___0) == (int const   )*phaystack) {
      j___0 ++;
      phaystack ++;
      if (j___0 == m) {
        *resultp = rhaystack;
        break;
      }
    } else
    if (j___0 > 0UL) {
      rhaystack += *(table___1 + j___0);
      j___0 -= *(table___1 + j___0);
    } else {
      rhaystack ++;
      phaystack ++;
    }
  }
  freea((void *)table___1);
  return ((_Bool)1);
}
}
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table___1 ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  tmp = mbslen(needle);
  m = tmp;
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    tmp___5 = -1;
  } else {
    tmp___5 = -2;
  }
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
    tmp___4 = (void *)0;
  } else {
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
      tmp___3 = (void *)((char *)tmp___1 + 16);
    } else {
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
      tmp___3 = tmp___2;
    }
    tmp___4 = tmp___3;
  }
  memory = (char *)tmp___4;
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  needle_mbchars = (mbchar_t *)memory;
  table___1 = (size_t *)(memory + m * sizeof(mbchar_t ));
  j = (size_t )0;
  iter.cur.ptr = needle;
  iter.in_shift = (_Bool)0;
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
  iter.next_done = (_Bool)0;
  while (1) {
    mbuiter_multi_next(& iter);
    if (iter.cur.wc_valid) {
      if (iter.cur.wc == 0) {
        tmp___6 = 0;
      } else {
        tmp___6 = 1;
      }
    } else {
      tmp___6 = 1;
    }
    if (! tmp___6) {
      break;
    }
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
    iter.cur.ptr += iter.cur.bytes;
    iter.next_done = (_Bool)0;
    j ++;
  }
  *(table___1 + 1) = (size_t )1;
  j___0 = (size_t )0;
  i = (size_t )2;
  while (i < m) {
    b = needle_mbchars + (i - 1UL);
    while (1) {
      if (b->wc_valid) {
        if ((needle_mbchars + j___0)->wc_valid) {
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
          if (tmp___7 == 0) {
            tmp___8 = 1;
          } else {
            tmp___8 = 0;
          }
        } else {
          tmp___8 = 0;
        }
        tmp___9 = tmp___8;
      }
      if (tmp___9) {
        j___0 ++;
        *(table___1 + i) = i - j___0;
        break;
      }
      if (j___0 == 0UL) {
        *(table___1 + i) = i;
        break;
      }
      j___0 -= *(table___1 + j___0);
    }
    i ++;
  }
  *resultp = (char const   *)((void *)0);
  j___1 = (size_t )0;
  rhaystack.cur.ptr = haystack;
  rhaystack.in_shift = (_Bool)0;
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
  rhaystack.next_done = (_Bool)0;
  phaystack.cur.ptr = haystack;
  phaystack.in_shift = (_Bool)0;
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
  phaystack.next_done = (_Bool)0;
  while (1) {
    mbuiter_multi_next(& phaystack);
    if (phaystack.cur.wc_valid) {
      if (phaystack.cur.wc == 0) {
        tmp___15 = 0;
      } else {
        tmp___15 = 1;
      }
    } else {
      tmp___15 = 1;
    }
    if (! tmp___15) {
      break;
    }
    if ((needle_mbchars + j___1)->wc_valid) {
      if (phaystack.cur.wc_valid) {
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
        if (tmp___12 == 0) {
          tmp___13 = 1;
        } else {
          tmp___13 = 0;
        }
      } else {
        tmp___13 = 0;
      }
      tmp___14 = tmp___13;
    }
    if (tmp___14) {
      j___1 ++;
      phaystack.cur.ptr += phaystack.cur.bytes;
      phaystack.next_done = (_Bool)0;
      if (j___1 == m) {
        *resultp = rhaystack.cur.ptr;
        break;
      }
    } else
    if (j___1 > 0UL) {
      count = *(table___1 + j___1);
      j___1 -= count;
      while (count > 0UL) {
        mbuiter_multi_next(& rhaystack);
        if (rhaystack.cur.wc_valid) {
          if (rhaystack.cur.wc == 0) {
            tmp___10 = 0;
          } else {
            tmp___10 = 1;
          }
        } else {
          tmp___10 = 1;
        }
        if (! tmp___10) {
          abort();
        }
        rhaystack.cur.ptr += rhaystack.cur.bytes;
        rhaystack.next_done = (_Bool)0;
        count --;
      }
    } else {
      mbuiter_multi_next(& rhaystack);
      if (rhaystack.cur.wc_valid) {
        if (rhaystack.cur.wc == 0) {
          tmp___11 = 0;
        } else {
          tmp___11 = 1;
        }
      } else {
        tmp___11 = 1;
      }
      if (! tmp___11) {
        abort();
      }
      rhaystack.cur.ptr += rhaystack.cur.bytes;
      rhaystack.next_done = (_Bool)0;
      phaystack.cur.ptr += phaystack.cur.bytes;
      phaystack.next_done = (_Bool)0;
    }
  }
  freea((void *)memory);
  return ((_Bool)1);
}
}
char *mbsstr(char const   *haystack , char const   *needle )  __attribute__((__nonnull__(1,2))) ;
char *mbsstr(char const   *haystack , char const   *needle ) 
{ mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  unsigned char const   *result___0 ;
  _Bool success___0 ;
  size_t tmp___15 ;
  _Bool tmp___16 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___17 ;

  {
  tmp___17 = __ctype_get_mb_cur_max();
  if (tmp___17 > 1UL) {
    iter_needle.cur.ptr = needle;
    iter_needle.in_shift = (_Bool)0;
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
    iter_needle.next_done = (_Bool)0;
    mbuiter_multi_next(& iter_needle);
    if (iter_needle.cur.wc_valid) {
      if (iter_needle.cur.wc == 0) {
        tmp___12 = 0;
      } else {
        tmp___12 = 1;
      }
    } else {
      tmp___12 = 1;
    }
    if (tmp___12) {
      try_kmp = (_Bool)1;
      outer_loop_count = (size_t )0;
      comparison_count = (size_t )0;
      last_ccount = (size_t )0;
      iter_needle_last_ccount.cur.ptr = needle;
      iter_needle_last_ccount.in_shift = (_Bool)0;
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
      iter_needle_last_ccount.next_done = (_Bool)0;
      iter_haystack.cur.ptr = haystack;
      iter_haystack.in_shift = (_Bool)0;
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
      iter_haystack.next_done = (_Bool)0;
      while (1) {
        mbuiter_multi_next(& iter_haystack);
        if (iter_haystack.cur.wc_valid) {
          if (iter_haystack.cur.wc == 0) {
            tmp = 0;
          } else {
            tmp = 1;
          }
        } else {
          tmp = 1;
        }
        if (! tmp) {
          return ((char *)((void *)0));
        }
        if (try_kmp) {
          if (outer_loop_count >= 10UL) {
            if (comparison_count >= 5UL * outer_loop_count) {
              count = comparison_count - last_ccount;
              while (1) {
                if (count > 0UL) {
                  mbuiter_multi_next(& iter_needle_last_ccount);
                  if (iter_needle_last_ccount.cur.wc_valid) {
                    if (iter_needle_last_ccount.cur.wc == 0) {
                      tmp___0 = 0;
                    } else {
                      tmp___0 = 1;
                    }
                  } else {
                    tmp___0 = 1;
                  }
                  if (! tmp___0) {
                    break;
                  }
                } else {
                  break;
                }
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
                iter_needle_last_ccount.next_done = (_Bool)0;
                count --;
              }
              last_ccount = comparison_count;
              mbuiter_multi_next(& iter_needle_last_ccount);
              if (iter_needle_last_ccount.cur.wc_valid) {
                if (iter_needle_last_ccount.cur.wc == 0) {
                  tmp___2 = 0;
                } else {
                  tmp___2 = 1;
                }
              } else {
                tmp___2 = 1;
              }
              if (! tmp___2) {
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
                success = tmp___1;
                if (success) {
                  return ((char *)result);
                }
                try_kmp = (_Bool)0;
              }
            }
          }
        }
        outer_loop_count ++;
        comparison_count ++;
        if (iter_haystack.cur.wc_valid) {
          if (iter_needle.cur.wc_valid) {
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
            if (tmp___9 == 0) {
              tmp___10 = 1;
            } else {
              tmp___10 = 0;
            }
          } else {
            tmp___10 = 0;
          }
          tmp___11 = tmp___10;
        }
        if (tmp___11) {
          memcpy((void * __restrict  )(& rhaystack), (void const   * __restrict  )(& iter_haystack),
                 sizeof(mbui_iterator_t ));
          rhaystack.cur.ptr += rhaystack.cur.bytes;
          rhaystack.next_done = (_Bool)0;
          rneedle.cur.ptr = needle;
          rneedle.in_shift = (_Bool)0;
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
          rneedle.next_done = (_Bool)0;
          mbuiter_multi_next(& rneedle);
          if (rneedle.cur.wc_valid) {
            if (rneedle.cur.wc == 0) {
              tmp___3 = 0;
            } else {
              tmp___3 = 1;
            }
          } else {
            tmp___3 = 1;
          }
          if (! tmp___3) {
            abort();
          }
          rneedle.cur.ptr += rneedle.cur.bytes;
          rneedle.next_done = (_Bool)0;
          while (1) {
            mbuiter_multi_next(& rneedle);
            if (rneedle.cur.wc_valid) {
              if (rneedle.cur.wc == 0) {
                tmp___4 = 0;
              } else {
                tmp___4 = 1;
              }
            } else {
              tmp___4 = 1;
            }
            if (! tmp___4) {
              return ((char *)iter_haystack.cur.ptr);
            }
            mbuiter_multi_next(& rhaystack);
            if (rhaystack.cur.wc_valid) {
              if (rhaystack.cur.wc == 0) {
                tmp___5 = 0;
              } else {
                tmp___5 = 1;
              }
            } else {
              tmp___5 = 1;
            }
            if (! tmp___5) {
              return ((char *)((void *)0));
            }
            comparison_count ++;
            if (rhaystack.cur.wc_valid) {
              if (rneedle.cur.wc_valid) {
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
                goto _L;
              }
            } else {
              _L: 
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
                if (tmp___6 == 0) {
                  tmp___7 = 1;
                } else {
                  tmp___7 = 0;
                }
              } else {
                tmp___7 = 0;
              }
              tmp___8 = tmp___7;
            }
            if (! tmp___8) {
              break;
            }
            rhaystack.cur.ptr += rhaystack.cur.bytes;
            rhaystack.next_done = (_Bool)0;
            rneedle.cur.ptr += rneedle.cur.bytes;
            rneedle.next_done = (_Bool)0;
          }
        }
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
        iter_haystack.next_done = (_Bool)0;
      }
    } else {
      return ((char *)haystack);
    }
  } else
  if ((int const   )*needle != 0) {
    try_kmp___0 = (_Bool)1;
    outer_loop_count___0 = (size_t )0;
    comparison_count___0 = (size_t )0;
    last_ccount___0 = (size_t )0;
    needle_last_ccount = needle;
    tmp___13 = needle;
    needle ++;
    b = (char )*tmp___13;
    while (1) {
      if ((int const   )*haystack == 0) {
        return ((char *)((void *)0));
      }
      if (try_kmp___0) {
        if (outer_loop_count___0 >= 10UL) {
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
              needle_last_ccount += tmp___14;
              if ((int const   )*needle_last_ccount == 0) {
                needle_last_ccount = (char const   *)((void *)0);
              }
              last_ccount___0 = comparison_count___0;
            }
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
              tmp___15 = strlen(needle - 1);
              tmp___16 = knuth_morris_pratt((unsigned char const   *)haystack, (unsigned char const   *)(needle - 1),
                                            tmp___15, & result___0);
              success___0 = tmp___16;
              if (success___0) {
                return ((char *)result___0);
              }
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
      outer_loop_count___0 ++;
      comparison_count___0 ++;
      if ((int const   )*haystack == (int const   )b) {
        rhaystack___0 = haystack + 1;
        rneedle___0 = needle;
        while (1) {
          if ((int const   )*rneedle___0 == 0) {
            return ((char *)haystack);
          }
          if ((int const   )*rhaystack___0 == 0) {
            return ((char *)((void *)0));
          }
          comparison_count___0 ++;
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
            break;
          }
          rhaystack___0 ++;
          rneedle___0 ++;
        }
      }
      haystack ++;
    }
  } else {
    return ((char *)haystack);
  }
}
}
int gnu_mbswidth(char const   *string , int flags ) ;
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
extern  __attribute__((__nothrow__)) int iswcntrl(wint_t __wc ) ;
int gnu_mbswidth(char const   *string , int flags ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(string);
  tmp___0 = mbsnwidth(string, tmp, flags);
  return (tmp___0);
}
}
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ char const   *p ;
  char const   *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned char c ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  p = string;
  plimit = p + nbytes;
  width = 0;
  tmp___1 = __ctype_get_mb_cur_max();
  if (tmp___1 > 1UL) {
    while ((unsigned long )p < (unsigned long )plimit) {
      switch ((int )*p) {
      case 32: 
      case 33: 
      case 34: 
      case 35: 
      case 37: 
      case 38: 
      case 39: 
      case 40: 
      case 41: 
      case 42: 
      case 43: 
      case 44: 
      case 45: 
      case 46: 
      case 47: 
      case 48: 
      case 49: 
      case 50: 
      case 51: 
      case 52: 
      case 53: 
      case 54: 
      case 55: 
      case 56: 
      case 57: 
      case 58: 
      case 59: 
      case 60: 
      case 61: 
      case 62: 
      case 63: 
      case 65: 
      case 66: 
      case 67: 
      case 68: 
      case 69: 
      case 70: 
      case 71: 
      case 72: 
      case 73: 
      case 74: 
      case 75: 
      case 76: 
      case 77: 
      case 78: 
      case 79: 
      case 80: 
      case 81: 
      case 82: 
      case 83: 
      case 84: 
      case 85: 
      case 86: 
      case 87: 
      case 88: 
      case 89: 
      case 90: 
      case 91: 
      case 92: 
      case 93: 
      case 94: 
      case 95: 
      case 97: 
      case 98: 
      case 99: 
      case 100: 
      case 101: 
      case 102: 
      case 103: 
      case 104: 
      case 105: 
      case 106: 
      case 107: 
      case 108: 
      case 109: 
      case 110: 
      case 111: 
      case 112: 
      case 113: 
      case 114: 
      case 115: 
      case 116: 
      case 117: 
      case 118: 
      case 119: 
      case 120: 
      case 121: 
      case 122: 
      case 123: 
      case 124: 
      case 125: 
      case 126: 
      p ++;
      width ++;
      break;
      default: 
      memset((void *)(& mbstate), 0, sizeof(mbstate));
      while (1) {
        bytes = mbrtowc((wchar_t * __restrict  )(& wc), (char const   * __restrict  )p,
                        (size_t )(plimit - p), & mbstate);
        if (bytes == 0xffffffffffffffffUL) {
          if (! (flags & 1)) {
            p ++;
            width ++;
            break;
          } else {
            return (-1);
          }
        }
        if (bytes == 0xfffffffffffffffeUL) {
          if (! (flags & 1)) {
            p = plimit;
            width ++;
            break;
          } else {
            return (-1);
          }
        }
        if (bytes == 0UL) {
          bytes = (size_t )1;
        }
        w = wcwidth(wc);
        if (w >= 0) {
          if (w > 2147483647 - width) {
            goto overflow;
          }
          width += w;
        } else
        if (! (flags & 2)) {
          tmp = iswcntrl((wint_t )wc);
          if (! tmp) {
            if (width == 2147483647) {
              goto overflow;
            }
            width ++;
          }
        } else {
          return (-1);
        }
        p += bytes;
        tmp___0 = mbsinit((mbstate_t const   *)(& mbstate));
        if (tmp___0) {
          break;
        }
      }
      break;
      }
    }
    return (width);
  }
  while ((unsigned long )p < (unsigned long )plimit) {
    tmp___2 = p;
    p ++;
    c = (unsigned char )*tmp___2;
    tmp___4 = __ctype_b_loc();
    if ((int const   )*(*tmp___4 + (int )c) & 16384) {
      if (width == 2147483647) {
        goto overflow;
      }
      width ++;
    } else
    if (! (flags & 2)) {
      tmp___3 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___3 + (int )c) & 2)) {
        if (width == 2147483647) {
          goto overflow;
        }
        width ++;
      }
    } else {
      return (-1);
    }
  }
  return (width);
  overflow: 
  return (2147483647);
}
}
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) ;
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) 
{ size_t i ;
  char const   *s1 ;
  char const   *s2 ;
  unsigned char u1 ;
  unsigned char u2 ;
  int U1 ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int U2 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  int diff ;

  {
  s1 = (char const   *)vs1;
  s2 = (char const   *)vs2;
  i = (size_t )0;
  while (i < n) {
    u1 = (unsigned char )*(s1 + i);
    u2 = (unsigned char )*(s2 + i);
    if (sizeof(u1) > 1UL) {
      __res = toupper((int )u1);
    } else {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )u1);
    }
    U1 = __res;
    if (sizeof(u2) > 1UL) {
      __res___0 = toupper((int )u2);
    } else {
      tmp___2 = __ctype_toupper_loc();
      __res___0 = (int )*(*tmp___2 + (int )u2);
    }
    U2 = __res___0;
    diff = U1 - U2;
    if (diff) {
      return (diff);
    }
    i ++;
  }
  return (0);
}
}
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) 
{ unsigned char const   *char_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
  c1 = (unsigned char )c1_in;
  c2 = (unsigned char )c2_in;
  if ((int )c1 == (int )c2) {
    tmp = memchr(s, (int )c1, n);
    return (tmp);
  }
  char_ptr = (unsigned char const   *)s;
  while (1) {
    if (n > 0UL) {
      if (! ((size_t )char_ptr % sizeof(longword ) != 0UL)) {
        break;
      }
    } else {
      break;
    }
    if ((int const   )*char_ptr == (int const   )c1) {
      return ((void *)char_ptr);
    } else
    if ((int const   )*char_ptr == (int const   )c2) {
      return ((void *)char_ptr);
    }
    n --;
    char_ptr ++;
  }
  longword_ptr = (longword const   *)char_ptr;
  repeated_one = (longword )16843009;
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
  repeated_c1 |= repeated_c1 << 16;
  repeated_c2 |= repeated_c2 << 16;
  repeated_one |= (repeated_one << 31) << 1;
  repeated_c1 |= (repeated_c1 << 31) << 1;
  repeated_c2 |= (repeated_c2 << 31) << 1;
  if (8UL < sizeof(longword )) {
    i = (size_t )64;
    while (i < sizeof(longword ) * 8UL) {
      repeated_one |= repeated_one << i;
      repeated_c1 |= repeated_c1 << i;
      repeated_c2 |= repeated_c2 << i;
      i *= 2UL;
    }
  }
  while (n >= sizeof(longword )) {
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
      break;
    }
    longword_ptr ++;
    n -= sizeof(longword );
  }
  char_ptr = (unsigned char const   *)longword_ptr;
  while (n > 0UL) {
    if ((int const   )*char_ptr == (int const   )c1) {
      return ((void *)char_ptr);
    } else
    if ((int const   )*char_ptr == (int const   )c2) {
      return ((void *)char_ptr);
    }
    n --;
    char_ptr ++;
  }
  return ((void *)0);
}
}
int memcmp2(char const   *s1 , size_t n1 , char const   *s2 , size_t n2 ) ;
int memcmp2(char const   *s1 , size_t n1 , char const   *s2 , size_t n2 ) 
{ int cmp ;
  size_t tmp ;
  int tmp___0 ;

  {
  if (n1 <= n2) {
    tmp = n1;
  } else {
    tmp = n2;
  }
  tmp___0 = memcmp((void const   *)s1, (void const   *)s2, tmp);
  cmp = tmp___0;
  if (cmp == 0) {
    if (n1 < n2) {
      cmp = -1;
    } else
    if (n1 > n2) {
      cmp = 1;
    }
  }
  return (cmp);
}
}
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
int memcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) ;
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
__inline static int strcoll_loop(char const   *s1 , size_t s1size , char const   *s2 ,
                                 size_t s2size ) 
{ int diff ;
  size_t size1 ;
  size_t tmp ;
  size_t size2 ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  while (1) {
    tmp___1 = __errno_location();
    *tmp___1 = 0;
    diff = strcoll(s1, s2);
    if (diff) {
      tmp___3 = 1;
    } else {
      tmp___2 = __errno_location();
      if (*tmp___2) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    }
    if (tmp___3) {
      break;
    }
    tmp = strlen(s1);
    size1 = tmp + 1UL;
    tmp___0 = strlen(s2);
    size2 = tmp___0 + 1UL;
    s1 += size1;
    s2 += size2;
    s1size -= size1;
    s2size -= size2;
    if (s1size == 0UL) {
      return (- (s2size != 0UL));
    }
    if (s2size == 0UL) {
      return (1);
    }
  }
  return (diff);
}
}
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ int diff ;
  int *tmp ;
  char n1 ;
  char n2 ;
  int tmp___0 ;

  {
  if (s1len == s2len) {
    tmp___0 = memcmp((void const   *)s1, (void const   *)s2, s1len);
    if (tmp___0 == 0) {
      tmp = __errno_location();
      *tmp = 0;
      diff = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
    n1 = *(s1 + s1len);
    n2 = *(s2 + s2len);
    *(s1 + s1len) = (char )'\000';
    *(s2 + s2len) = (char )'\000';
    diff = strcoll_loop((char const   *)s1, s1len + 1UL, (char const   *)s2, s2len + 1UL);
    *(s1 + s1len) = n1;
    *(s2 + s2len) = n2;
  }
  return (diff);
}
}
int memcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) 
{ int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (s1size == s2size) {
    tmp___1 = memcmp((void const   *)s1, (void const   *)s2, s1size);
    if (tmp___1 == 0) {
      tmp = __errno_location();
      *tmp = 0;
      return (0);
    } else {
      tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
      return (tmp___0);
    }
  } else {
    tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
    return (tmp___0);
  }
}
}
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
static gid_t *realloc_groupbuf(gid_t *g , size_t num ) 
{ int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
    tmp___0 = -1;
  } else {
    tmp___0 = -2;
  }
  if ((size_t )tmp___0 / sizeof(*g) < num) {
    tmp = __errno_location();
    *tmp = 12;
    return ((gid_t *)((void *)0));
  }
  tmp___1 = realloc((void *)g, num * sizeof(*g));
  return ((gid_t *)tmp___1);
}
}
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ int max_n_groups ;
  int ng ;
  gid_t *g ;
  gid_t *h ;
  int last_n_groups ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int __attribute__((__artificial__))  tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int __attribute__((__artificial__))  tmp___5 ;
  int saved_errno___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  gid_t first ;
  gid_t *next ;
  gid_t *groups_end ;

  {
  if (username) {
    max_n_groups = 10;
    g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
    if ((unsigned long )g == (unsigned long )((void *)0)) {
      return (-1);
    }
    while (1) {
      last_n_groups = max_n_groups;
      ng = getgrouplist(username, gid, g, & max_n_groups);
      if (ng < 0) {
        if (last_n_groups == max_n_groups) {
          max_n_groups *= 2;
        }
      }
      h = realloc_groupbuf(g, (size_t )max_n_groups);
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        tmp = __errno_location();
        saved_errno = *tmp;
        free((void *)g);
        tmp___0 = __errno_location();
        *tmp___0 = saved_errno;
        return (-1);
      }
      g = h;
      if (0 <= ng) {
        *groups = g;
        return (max_n_groups);
      }
    }
  }
  if (username) {
    tmp___1 = getugroups(0, (gid_t *)((void *)0), username, gid);
    max_n_groups = tmp___1;
  } else {
    tmp___2 = getgroups(0, (__gid_t *)((void *)0));
    max_n_groups = (int )tmp___2;
  }
  if (max_n_groups < 0) {
    tmp___3 = __errno_location();
    if (*tmp___3 == 38) {
      g = realloc_groupbuf((gid_t *)((void *)0), (size_t )1);
      if (g) {
        *groups = g;
        *g = gid;
        return (gid != 4294967295U);
      }
    }
    return (-1);
  }
  if (! username) {
    if (gid != 4294967295U) {
      max_n_groups ++;
    }
  }
  g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (username) {
    tmp___4 = getugroups(max_n_groups, g, username, gid);
    ng = tmp___4;
  } else {
    tmp___5 = getgroups(max_n_groups - (gid != 4294967295U), g + (gid != 4294967295U));
    ng = (int )tmp___5;
  }
  if (ng < 0) {
    tmp___6 = __errno_location();
    saved_errno___0 = *tmp___6;
    free((void *)g);
    tmp___7 = __errno_location();
    *tmp___7 = saved_errno___0;
    return (-1);
  }
  if (! username) {
    if (gid != 4294967295U) {
      *g = gid;
      ng ++;
    }
  }
  *groups = g;
  if (1 < ng) {
    first = *g;
    groups_end = g + ng;
    next = g + 1;
    while ((unsigned long )next < (unsigned long )groups_end) {
      if (*next == first) {
        ng --;
      } else
      if (*next == *g) {
        ng --;
      } else {
        g ++;
        *g = *next;
      }
      next ++;
    }
  }
  return (ng);
}
}
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) ;
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) 
{ char *sep ;
  char *component ;
  char *p ;
  char c ;
  _Bool made_dir ;
  int make_dir_errno ;
  int savewd_chdir_options ;
  int chdir_result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  sep = (char *)((void *)0);
  component = file;
  p = file + 0;
  made_dir = (_Bool)0;
  while (1) {
    tmp___3 = p;
    p ++;
    c = *tmp___3;
    if (! c) {
      break;
    }
    if ((int )*p == 47) {
      if (! ((int )c == 47)) {
        sep = p;
      }
    } else
    if ((int )c == 47) {
      if (*p) {
        if (sep) {
          if (sep - component == 1) {
            if (! ((int )*(component + 0) == 46)) {
              goto _L___1;
            }
          } else {
            _L___1: 
            make_dir_errno = 0;
            savewd_chdir_options = 0;
            *sep = (char )'\000';
            if (sep - component == 2) {
              if ((int )*(component + 0) == 46) {
                if ((int )*(component + 1) == 46) {
                  made_dir = (_Bool)0;
                } else {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              tmp = (*make_dir)((char const   *)file, (char const   *)component, make_dir_arg);
              switch (tmp) {
              case -1: 
              tmp___0 = __errno_location();
              make_dir_errno = *tmp___0;
              break;
              case 0: 
              savewd_chdir_options |= 2;
              case 1: 
              made_dir = (_Bool)1;
              break;
              }
            }
            if (made_dir) {
              savewd_chdir_options |= 1;
            }
            chdir_result = savewd_chdir(wd, (char const   *)component, savewd_chdir_options,
                                        (int *)((void *)0));
            if (chdir_result != -1) {
              *sep = (char )'/';
            }
            if (chdir_result != 0) {
              if (make_dir_errno != 0) {
                tmp___2 = __errno_location();
                if (*tmp___2 == 2) {
                  tmp___1 = __errno_location();
                  *tmp___1 = make_dir_errno;
                }
              }
              return ((ptrdiff_t )chdir_result);
            }
          }
          component = p;
        }
      }
    }
  }
  return ((ptrdiff_t )(component - file));
}
}
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) 
{ struct stat st ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  mode_t dir_mode ;
  int *tmp___2 ;
  mode_t indeterminate ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  mode_t chmod_mode ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int e ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
  if (fd < 0) {
    tmp = stat((char const   * __restrict  )dir, (struct stat * __restrict  )(& st));
    tmp___1 = tmp;
  } else {
    tmp___0 = fstat(fd, & st);
    tmp___1 = tmp___0;
  }
  result = tmp___1;
  if (result == 0) {
    dir_mode = st.st_mode;
    if (! ((dir_mode & 61440U) == 16384U)) {
      tmp___2 = __errno_location();
      *tmp___2 = 20;
      result = -1;
    } else {
      indeterminate = (mode_t )0;
      if (owner != 4294967295U) {
        if (owner != st.st_uid) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else
      _L___0: 
      if (group != 4294967295U) {
        if (group != st.st_gid) {
          _L: 
          if (0 <= fd) {
            tmp___3 = fchown(fd, owner, group);
            result = tmp___3;
          } else {
            if (mkdir_mode != 4294967295U) {
              tmp___4 = lchown(dir, owner, group);
              tmp___6 = tmp___4;
            } else {
              tmp___5 = chown(dir, owner, group);
              tmp___6 = tmp___5;
            }
            result = tmp___6;
          }
          if (result == 0) {
            if (dir_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
              indeterminate = dir_mode & 3072U;
            }
          }
        }
      }
      if (result == 0) {
        if (((dir_mode ^ mode) | indeterminate) & mode_bits) {
          chmod_mode = mode | ((dir_mode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) & ~ mode_bits);
          if (0 <= fd) {
            tmp___7 = fchmod(fd, chmod_mode);
            result = tmp___7;
          } else {
            if (mkdir_mode != 4294967295U) {
              tmp___8 = chmod(dir, chmod_mode);
              tmp___10 = tmp___8;
            } else {
              tmp___9 = chmod(dir, chmod_mode);
              tmp___10 = tmp___9;
            }
            result = tmp___10;
          }
        }
      }
    }
  }
  if (0 <= fd) {
    if (result == 0) {
      result = close(fd);
    } else {
      tmp___11 = __errno_location();
      e = *tmp___11;
      close(fd);
      tmp___12 = __errno_location();
      *tmp___12 = e;
    }
  }
  return (result);
}
}
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
__inline static int savewd_errno(struct savewd  const  *wd ) 
{ int tmp ;

  {
  if ((unsigned int const   )wd->state == 4U) {
    tmp = (int )wd->val.errnum;
  } else {
    tmp = (int )((int const   )0);
  }
  return (tmp);
}
}
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) 
{ int mkdir_errno ;
  int tmp ;
  int tmp___0 ;
  ptrdiff_t prefix_len ;
  int savewd_chdir_options ;
  int *tmp___1 ;
  _Bool keep_owner ;
  int tmp___2 ;
  _Bool keep_special_mode_bits ;
  mode_t mkdir_mode ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int tmp___6 ;
  int open_result[2] ;
  int chdir_result ;
  int tmp___7 ;
  _Bool chdir_ok ;
  int chdir_errno ;
  int *tmp___8 ;
  int fd ;
  _Bool chdir_failed_unexpectedly ;
  int tmp___9 ;
  char const   *subdir ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;

  {
  if ((int )*(dir + 0) == 47) {
    tmp___0 = 0;
  } else {
    tmp = savewd_errno((struct savewd  const  *)wd);
    tmp___0 = tmp;
  }
  mkdir_errno = tmp___0;
  if (mkdir_errno == 0) {
    prefix_len = (ptrdiff_t )0;
    savewd_chdir_options = 4;
    if (make_ancestor) {
      prefix_len = mkancesdirs(dir, wd, make_ancestor, options);
      if (prefix_len < 0L) {
        if (prefix_len < -1L) {
          return ((_Bool)1);
        }
        tmp___1 = __errno_location();
        mkdir_errno = *tmp___1;
      }
    }
    if (0L <= prefix_len) {
      if (owner == 4294967295U) {
        if (group == 4294967295U) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      keep_owner = (_Bool )tmp___2;
      keep_special_mode_bits = (_Bool )(((mode_bits & 3072U) | (mode & 512U)) == 0U);
      mkdir_mode = mode;
      if (! keep_owner) {
        mkdir_mode &= (unsigned int )(~ ((448 >> 3) | ((448 >> 3) >> 3)));
      } else
      if (! keep_special_mode_bits) {
        mkdir_mode &= (unsigned int )(~ ((128 >> 3) | ((128 >> 3) >> 3)));
      }
      tmp___5 = mkdir((char const   *)(dir + prefix_len), mkdir_mode);
      if (tmp___5 == 0) {
        (*announce)((char const   *)dir, options);
        preserve_existing = (_Bool )((int )keep_owner & (int )keep_special_mode_bits);
        if (mode & 256U) {
          tmp___3 = 2;
        } else {
          tmp___3 = 0;
        }
        savewd_chdir_options |= 1 | tmp___3;
      } else {
        tmp___4 = __errno_location();
        mkdir_errno = *tmp___4;
        mkdir_mode = (mode_t )-1;
      }
      if (preserve_existing) {
        if (mkdir_errno == 0) {
          return ((_Bool)1);
        } else
        if (mkdir_errno != 2) {
          if (make_ancestor) {
            tmp___6 = stat((char const   * __restrict  )(dir + prefix_len), (struct stat * __restrict  )(& st));
            if (tmp___6 == 0) {
              if ((st.st_mode & 61440U) == 16384U) {
                return ((_Bool)1);
              }
            }
          }
        }
      } else {
        tmp___7 = savewd_chdir(wd, (char const   *)(dir + prefix_len), savewd_chdir_options,
                               open_result);
        chdir_result = tmp___7;
        if (chdir_result < -1) {
          return ((_Bool)1);
        } else {
          chdir_ok = (_Bool )(chdir_result == 0);
          tmp___8 = __errno_location();
          chdir_errno = *tmp___8;
          fd = open_result[0];
          if (mkdir_errno == 0) {
            if (! chdir_ok) {
              if (mode & 64U) {
                tmp___9 = 1;
              } else {
                goto _L;
              }
            } else
            _L: 
            if (fd < 0) {
              if (mode & 256U) {
                tmp___9 = 1;
              } else {
                tmp___9 = 0;
              }
            } else {
              tmp___9 = 0;
            }
          } else {
            tmp___9 = 0;
          }
          chdir_failed_unexpectedly = (_Bool )tmp___9;
          if (chdir_failed_unexpectedly) {
            if (0 <= fd) {
              close(fd);
            }
          } else {
            if (chdir_ok) {
              tmp___10 = ".";
            } else {
              tmp___10 = (char const   *)(dir + prefix_len);
            }
            subdir = tmp___10;
            tmp___11 = dirchownmod(fd, subdir, mkdir_mode, owner, group, mode, mode_bits);
            if (tmp___11 == 0) {
              return ((_Bool)1);
            }
          }
          if (mkdir_errno == 0) {
            goto _L___0;
          } else
          if (mkdir_errno != 2) {
            if (make_ancestor) {
              tmp___18 = __errno_location();
              if (*tmp___18 != 20) {
                _L___0: 
                tmp___12 = quote((char const   *)dir);
                if (keep_owner) {
                  tmp___13 = "cannot change permissions of %s";
                } else {
                  tmp___13 = "cannot change owner and permissions of %s";
                }
                tmp___14 = dcgettext((char const   *)((void *)0), tmp___13, 5);
                if (! chdir_failed_unexpectedly) {
                  tmp___15 = __errno_location();
                  tmp___17 = *tmp___15;
                } else {
                  if (! chdir_ok) {
                    if (mode & 64U) {
                      tmp___16 = chdir_errno;
                    } else {
                      tmp___16 = open_result[1];
                    }
                  } else {
                    tmp___16 = open_result[1];
                  }
                  tmp___17 = tmp___16;
                }
                error(0, tmp___17, (char const   *)tmp___14, tmp___12);
                return ((_Bool)0);
              }
            }
          }
        }
      }
    }
  }
  tmp___19 = quote((char const   *)dir);
  tmp___20 = dcgettext((char const   *)((void *)0), "cannot create directory %s",
                       5);
  error(0, mkdir_errno, (char const   *)tmp___20, tmp___19);
  return ((_Bool)0);
}
}
struct mode_change *mode_compile(char const   *mode_string ) ;
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) ;
static mode_t octal_to_mode(unsigned int octal ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
  if (256 >> 3 == 32) {
    if (128 >> 3 == 16) {
      if (64 >> 3 == 8) {
        if ((256 >> 3) >> 3 == 4) {
          if ((128 >> 3) >> 3 == 2) {
            if ((64 >> 3) >> 3 == 1) {
              tmp___11 = octal;
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
    if (octal & 2048U) {
      tmp = 2048;
    } else {
      tmp = 0;
    }
    if (octal & 1024U) {
      tmp___0 = 1024;
    } else {
      tmp___0 = 0;
    }
    if (octal & 512U) {
      tmp___1 = 512;
    } else {
      tmp___1 = 0;
    }
    if (octal & 256U) {
      tmp___2 = 256;
    } else {
      tmp___2 = 0;
    }
    if (octal & 128U) {
      tmp___3 = 128;
    } else {
      tmp___3 = 0;
    }
    if (octal & 64U) {
      tmp___4 = 64;
    } else {
      tmp___4 = 0;
    }
    if (octal & 32U) {
      tmp___5 = 256 >> 3;
    } else {
      tmp___5 = 0;
    }
    if (octal & 16U) {
      tmp___6 = 128 >> 3;
    } else {
      tmp___6 = 0;
    }
    if (octal & 8U) {
      tmp___7 = 64 >> 3;
    } else {
      tmp___7 = 0;
    }
    if (octal & 4U) {
      tmp___8 = (256 >> 3) >> 3;
    } else {
      tmp___8 = 0;
    }
    if (octal & 2U) {
      tmp___9 = (128 >> 3) >> 3;
    } else {
      tmp___9 = 0;
    }
    if (octal & 1U) {
      tmp___10 = (64 >> 3) >> 3;
    } else {
      tmp___10 = 0;
    }
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
  return (tmp___11);
}
}
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) 
{ struct mode_change *p ;
  void *tmp ;

  {
  tmp = xmalloc(2UL * sizeof(*p));
  p = (struct mode_change *)tmp;
  p->op = (char )'=';
  p->flag = (char)1;
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
  p->value = new_mode;
  p->mentioned = mentioned;
  (p + 1)->flag = (char)0;
  return (p);
}
}
struct mode_change *mode_compile(char const   *mode_string ) 
{ struct mode_change *mc ;
  size_t used ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const   *tmp ;
  struct mode_change *tmp___0 ;
  size_t needed ;
  char const   *p ;
  int tmp___1 ;
  void *tmp___2 ;
  mode_t affected ;
  char op ;
  char const   *tmp___3 ;
  mode_t value ;
  char flag ;
  struct mode_change *change ;
  char const   *tmp___4 ;
  size_t tmp___5 ;

  {
  used = (size_t )0;
  if (48 <= (int )*mode_string) {
    if ((int const   )*mode_string < 56) {
      octal_mode = 0U;
      while (1) {
        tmp = mode_string;
        mode_string ++;
        octal_mode = (8U * octal_mode + (unsigned int )*tmp) - 48U;
        if (4095U < octal_mode) {
          return ((struct mode_change *)((void *)0));
        }
        if (48 <= (int )*mode_string) {
          if (! ((int const   )*mode_string < 56)) {
            break;
          }
        } else {
          break;
        }
      }
      if (*mode_string) {
        return ((struct mode_change *)((void *)0));
      }
      mode = octal_to_mode(octal_mode);
      mentioned = ((mode & 3072U) | 512U) | (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
      tmp___0 = make_node_op_equals(mode, mentioned);
      return (tmp___0);
    }
  }
  needed = (size_t )1;
  p = mode_string;
  while (*p) {
    if ((int const   )*p == 61) {
      tmp___1 = 1;
    } else
    if ((int const   )*p == 43) {
      tmp___1 = 1;
    } else
    if ((int const   )*p == 45) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    needed += (size_t )tmp___1;
    p ++;
  }
  tmp___2 = xnmalloc(needed, sizeof(*mc));
  mc = (struct mode_change *)tmp___2;
  while (1) {
    affected = (mode_t )0;
    while (1) {
      switch ((int )*mode_string) {
      default: 
      goto invalid;
      case 117: 
      affected |= 2496U;
      break;
      case 103: 
      affected |= (unsigned int )(1024 | (448 >> 3));
      break;
      case 111: 
      affected |= (unsigned int )(512 | ((448 >> 3) >> 3));
      break;
      case 97: 
      affected |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
      break;
      case 61: 
      case 43: 
      case 45: 
      goto no_more_affected;
      }
      mode_string ++;
    }
    no_more_affected: ;
    while (1) {
      tmp___3 = mode_string;
      mode_string ++;
      op = (char )*tmp___3;
      flag = (char)3;
      tmp___4 = mode_string;
      mode_string ++;
      switch ((int )*tmp___4) {
      case 117: 
      value = (mode_t )448;
      break;
      case 103: 
      value = (mode_t )(448 >> 3);
      break;
      case 111: 
      value = (mode_t )((448 >> 3) >> 3);
      break;
      default: 
      value = (mode_t )0;
      flag = (char)1;
      mode_string --;
      while (1) {
        switch ((int )*mode_string) {
        case 114: 
        value |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3));
        break;
        case 119: 
        value |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3));
        break;
        case 120: 
        value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
        break;
        case 88: 
        flag = (char)2;
        break;
        case 115: 
        value |= 3072U;
        break;
        case 116: 
        value |= 512U;
        break;
        default: 
        goto no_more_values;
        }
        mode_string ++;
      }
      no_more_values: ;
      }
      tmp___5 = used;
      used ++;
      change = mc + tmp___5;
      change->op = op;
      change->flag = flag;
      change->affected = affected;
      change->value = value;
      if (affected) {
        change->mentioned = affected & value;
      } else {
        change->mentioned = value;
      }
      if (! ((int const   )*mode_string == 61)) {
        if (! ((int const   )*mode_string == 43)) {
          if (! ((int const   )*mode_string == 45)) {
            break;
          }
        }
      }
    }
    if ((int const   )*mode_string != 44) {
      break;
    }
    mode_string ++;
  }
  if ((int const   )*mode_string == 0) {
    (mc + used)->flag = (char)0;
    return (mc);
  }
  invalid: 
  free((void *)mc);
  return ((struct mode_change *)((void *)0));
}
}
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ struct stat ref_stats ;
  int tmp ;
  struct mode_change *tmp___0 ;

  {
  tmp = stat((char const   * __restrict  )ref_file, (struct stat * __restrict  )(& ref_stats));
  if (tmp != 0) {
    return ((struct mode_change *)((void *)0));
  }
  tmp___0 = make_node_op_equals(ref_stats.st_mode, (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
  return (tmp___0);
}
}
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) 
{ mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  int tmp ;
  mode_t value ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  mode_t preserved ;
  mode_t tmp___4 ;

  {
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
  mode_bits = (mode_t )0;
  while ((int const   )changes->flag != 0) {
    affected = (mode_t )changes->affected;
    if (dir) {
      tmp = 3072;
    } else {
      tmp = 0;
    }
    omit_change = (mode_t )((unsigned int const   )tmp & ~ changes->mentioned);
    value = (mode_t )changes->value;
    switch ((int )changes->flag) {
    case 1: 
    break;
    case 3: 
    value &= newmode;
    if (value & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
      tmp___0 = (256 | (256 >> 3)) | ((256 >> 3) >> 3);
    } else {
      tmp___0 = 0;
    }
    if (value & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) {
      tmp___1 = (128 | (128 >> 3)) | ((128 >> 3) >> 3);
    } else {
      tmp___1 = 0;
    }
    if (value & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
      tmp___2 = (64 | (64 >> 3)) | ((64 >> 3) >> 3);
    } else {
      tmp___2 = 0;
    }
    value |= (unsigned int )((tmp___0 | tmp___1) | tmp___2);
    break;
    case 2: 
    if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) | (unsigned int )dir) {
      value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
    }
    break;
    }
    if (affected) {
      tmp___3 = affected;
    } else {
      tmp___3 = ~ umask_value;
    }
    value &= tmp___3 & ~ omit_change;
    switch ((int )changes->op) {
    case 61: 
    if (affected) {
      tmp___4 = ~ affected;
    } else {
      tmp___4 = (mode_t )0;
    }
    preserved = tmp___4 | omit_change;
    mode_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ preserved;
    newmode = (newmode & preserved) | value;
    break;
    case 43: 
    mode_bits |= value;
    newmode |= value;
    break;
    case 45: 
    mode_bits |= value;
    newmode &= ~ value;
    break;
    }
    changes ++;
  }
  if (pmode_bits) {
    *pmode_bits = mode_bits;
  }
  return (newmode);
}
}
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) ;
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) ;
static void mpsort_into_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const   *ba ;
  void const   *bb ;
  void const   ** __restrict  tmp___0 ;
  void const   ** __restrict  tmp___1 ;
  int tmp___2 ;

  {
  n1 = n / 2UL;
  n2 = n - n1;
  a = (size_t )0;
  alim = n1;
  b = n1;
  blim = n;
  mpsort_with_tmp(base + n1, n2, tmp, cmp);
  mpsort_with_tmp(base, n1, tmp, cmp);
  ba = *(base + a);
  bb = *(base + b);
  while (1) {
    tmp___2 = (*cmp)(ba, bb);
    if (tmp___2 <= 0) {
      tmp___0 = tmp;
      tmp ++;
      *tmp___0 = ba;
      a ++;
      if (a == alim) {
        a = b;
        alim = blim;
        break;
      }
      ba = *(base + a);
    } else {
      tmp___1 = tmp;
      tmp ++;
      *tmp___1 = bb;
      b ++;
      if (b == blim) {
        break;
      }
      bb = *(base + b);
    }
  }
  memcpy((void * __restrict  )tmp, (void const   * __restrict  )(base + a), (alim - a) * sizeof(*base));
  return;
}
}
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ void const   *p0 ;
  void const   *p1 ;
  int tmp___0 ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const   *bb ;
  void const   *tt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  if (n <= 2UL) {
    if (n == 2UL) {
      p0 = *(base + 0);
      p1 = *(base + 1);
      tmp___0 = (*cmp)(p0, p1);
      if (! (tmp___0 <= 0)) {
        *(base + 0) = p1;
        *(base + 1) = p0;
      }
    }
  } else {
    n1 = n / 2UL;
    n2 = n - n1;
    t = (size_t )0;
    tlim = n1;
    b = n1;
    blim = n;
    mpsort_with_tmp(base + n1, n2, tmp, cmp);
    if (n1 < 2UL) {
      *(tmp + 0) = *(base + 0);
    } else {
      mpsort_into_tmp(base, n1, tmp, cmp);
    }
    tt = *(tmp + t);
    bb = *(base + b);
    i = (size_t )0;
    while (1) {
      tmp___3 = (*cmp)(tt, bb);
      if (tmp___3 <= 0) {
        tmp___1 = i;
        i ++;
        *(base + tmp___1) = tt;
        t ++;
        if (t == tlim) {
          break;
        }
        tt = *(tmp + t);
      } else {
        tmp___2 = i;
        i ++;
        *(base + tmp___2) = bb;
        b ++;
        if (b == blim) {
          memcpy((void * __restrict  )(base + i), (void const   * __restrict  )(tmp + t),
                 (tlim - t) * sizeof(*base));
          break;
        }
        bb = *(base + b);
      }
    }
  }
  return;
}
}
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) 
{ 

  {
  mpsort_with_tmp((void const   ** __restrict  )base, n, (void const   ** __restrict  )(base + n),
                  cmp);
  return;
}
}
unsigned long num_processors(enum nproc_query query ) ;
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr ,
                                                           int __base )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t const   *__setp ) ;
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
static unsigned long num_processors_via_affinity_mask(void) 
{ cpu_set_t set ;
  unsigned long count ;
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = sched_getaffinity(0, sizeof(set), & set);
  if (tmp___0 == 0) {
    tmp = __sched_cpucount(sizeof(cpu_set_t ), (cpu_set_t const   *)(& set));
    count = (unsigned long )tmp;
    if (count > 0UL) {
      return (count);
    }
  }
  return (0UL);
}
}
unsigned long num_processors(enum nproc_query query ) 
{ char const   *envvalue ;
  char *tmp ;
  int __c ;
  int tmp___0 ;
  char *endptr ;
  unsigned long value ;
  unsigned long tmp___1 ;
  int __c___0 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int __c___1 ;
  int tmp___4 ;
  unsigned long nprocs ;
  unsigned long tmp___5 ;
  long nprocs___0 ;
  long tmp___6 ;
  long nprocs___1 ;
  long tmp___7 ;
  unsigned long nprocs_current ;
  unsigned long tmp___8 ;

  {
  if ((unsigned int )query == 2U) {
    tmp = getenv("OMP_NUM_THREADS");
    envvalue = (char const   *)tmp;
    if ((unsigned long )envvalue != (unsigned long )((void *)0)) {
      while (1) {
        if ((int const   )*envvalue != 0) {
          __c = (int )*envvalue;
          if (__c == 32) {
            tmp___0 = 1;
          } else
          if (__c == 9) {
            tmp___0 = 1;
          } else
          if (__c == 10) {
            tmp___0 = 1;
          } else
          if (__c == 11) {
            tmp___0 = 1;
          } else
          if (__c == 12) {
            tmp___0 = 1;
          } else
          if (__c == 13) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
          if (! tmp___0) {
            break;
          }
        } else {
          break;
        }
        envvalue ++;
      }
      __c___1 = (int )*envvalue;
      if (__c___1 >= 48) {
        if (__c___1 <= 57) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
      } else {
        tmp___4 = 0;
      }
      if (tmp___4) {
        endptr = (char *)((void *)0);
        tmp___1 = strtoul((char const   * __restrict  )envvalue, (char ** __restrict  )(& endptr),
                          10);
        value = tmp___1;
        if ((unsigned long )endptr != (unsigned long )((void *)0)) {
          while (1) {
            if ((int )*endptr != 0) {
              __c___0 = (int )*endptr;
              if (__c___0 == 32) {
                tmp___2 = 1;
              } else
              if (__c___0 == 9) {
                tmp___2 = 1;
              } else
              if (__c___0 == 10) {
                tmp___2 = 1;
              } else
              if (__c___0 == 11) {
                tmp___2 = 1;
              } else
              if (__c___0 == 12) {
                tmp___2 = 1;
              } else
              if (__c___0 == 13) {
                tmp___2 = 1;
              } else {
                tmp___2 = 0;
              }
              if (! tmp___2) {
                break;
              }
            } else {
              break;
            }
            endptr ++;
          }
          if ((int )*endptr == 0) {
            if (value > 0UL) {
              tmp___3 = value;
            } else {
              tmp___3 = 1UL;
            }
            return (tmp___3);
          }
        }
      }
    }
    query = (enum nproc_query )1;
  }
  if ((unsigned int )query == 1U) {
    tmp___5 = num_processors_via_affinity_mask();
    nprocs = tmp___5;
    if (nprocs > 0UL) {
      return (nprocs);
    }
    tmp___6 = sysconf(84);
    nprocs___0 = tmp___6;
    if (nprocs___0 > 0L) {
      return ((unsigned long )nprocs___0);
    }
  } else {
    tmp___7 = sysconf(83);
    nprocs___1 = tmp___7;
    if (nprocs___1 == 1L) {
      tmp___8 = num_processors_via_affinity_mask();
      nprocs_current = tmp___8;
      if (nprocs_current > 0UL) {
        nprocs___1 = (long )nprocs_current;
      }
    }
    if (nprocs___1 > 0L) {
      return ((unsigned long )nprocs___1);
    }
  }
  return (1UL);
}
}
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
void openat_save_fail(int errnum ) 
{ char *tmp ;

  {
  tmp = dcgettext((char const   *)((void *)0), "unable to record current working directory",
                  5);
  error((int )exit_failure, errnum, (char const   *)tmp);
  abort();
}
}
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
void openat_restore_fail(int errnum ) 
{ char *tmp ;

  {
  tmp = dcgettext((char const   *)((void *)0), "failed to return to initial working directory",
                  5);
  error((int )exit_failure, errnum, (char const   *)tmp);
  abort();
}
}
int openat_safer(int fd , char const   *file , int flags  , ...) ;
int openat_safer(int fd , char const   *file , int flags  , ...) 
{ mode_t mode ;
  va_list ap ;
  int __attribute__((__artificial__))  tmp ;
  int tmp___0 ;

  {
  mode = (mode_t )0;
  if (flags & 64) {
    __builtin_va_start(ap, flags);
    mode = __builtin_va_arg(ap, mode_t );
    __builtin_va_end(ap);
  }
  tmp = openat(fd, file, flags, mode);
  tmp___0 = fd_safer((int )tmp);
  return (tmp___0);
}
}
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__warn_unused_result__,
__const__)) ;
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 

  {
  if (pc->dates_seen) {
    if (! pc->year.digits) {
      if (! pc->rels_seen) {
        if (pc->times_seen) {
          pc->year = text_int;
        } else
        if (2UL < text_int.digits) {
          pc->year = text_int;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: 
  if (4UL < text_int.digits) {
    (pc->dates_seen) ++;
    pc->day = text_int.value % 100L;
    pc->month = (text_int.value / 100L) % 100L;
    pc->year.value = text_int.value / 10000L;
    pc->year.digits = text_int.digits - 4UL;
  } else {
    (pc->times_seen) ++;
    if (text_int.digits <= 2UL) {
      pc->hour = text_int.value;
      pc->minutes = 0L;
    } else {
      pc->hour = text_int.value / 100L;
      pc->minutes = text_int.value % 100L;
    }
    pc->seconds.tv_sec = (__time_t )0;
    pc->seconds.tv_nsec = 0L;
    pc->meridian = 2;
  }
  return;
}
}
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 

  {
  pc->rel.ns += (long )factor * rel.ns;
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
  pc->rel.minutes += (long )factor * rel.minutes;
  pc->rel.hour += (long )factor * rel.hour;
  pc->rel.day += (long )factor * rel.day;
  pc->rel.month += (long )factor * rel.month;
  pc->rel.year += (long )factor * rel.year;
  pc->rels_seen = (_Bool)1;
  return;
}
}
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 

  {
  pc->hour = hour;
  pc->minutes = minutes;
  pc->seconds.tv_sec = sec;
  pc->seconds.tv_nsec = nsec;
  return;
}
}
static yytype_uint8 const   yytranslate[278]  = 
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )25,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
static yytype_uint8 const   yyr1[92]  = 
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53};
static yytype_uint8 const   yyr2[92]  = 
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2};
static yytype_uint8 const   yydefact[114]  = 
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )4,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )73,      (yytype_uint8 const   )62,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )35,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )16,      (yytype_uint8 const   )8,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )13,      (yytype_uint8 const   )52,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )39,      (yytype_uint8 const   )36,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )77,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )64,      (yytype_uint8 const   )67,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )18,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )46,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25};
static yytype_int8 const   yydefgoto[26]  = 
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )35,      (yytype_int8 const   )103,      (yytype_int8 const   )104,      (yytype_int8 const   )36, 
        (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )40, 
        (yytype_int8 const   )41,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )45, 
        (yytype_int8 const   )46,      (yytype_int8 const   )93};
static yytype_int8 const   yypact[114]  = 
  {      (yytype_int8 const   )38,      (yytype_int8 const   )27,      (yytype_int8 const   )77,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )62,      (yytype_int8 const   )-93,      (yytype_int8 const   )82,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )66,      (yytype_int8 const   )3,      (yytype_int8 const   )74,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )75,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-93,      (yytype_int8 const   )93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )78,      (yytype_int8 const   )72,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )25, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )21, 
        (yytype_int8 const   )19,      (yytype_int8 const   )79,      (yytype_int8 const   )80,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )81,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )85, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-6,      (yytype_int8 const   )76, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )87,      (yytype_int8 const   )69,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )88,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )18,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )69,      (yytype_int8 const   )91};
static yytype_int8 const   yypgoto[26]  = 
  {      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-68,      (yytype_int8 const   )-27,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )60,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-92,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )43};
static yytype_uint8 const   yytable[113]  = 
  {      (yytype_uint8 const   )79,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )100,      (yytype_uint8 const   )107,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )101,      (yytype_uint8 const   )110,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )77,      (yytype_uint8 const   )59,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )92,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )106,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )111,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )88,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )1,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )79,      (yytype_uint8 const   )30,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )12,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )60,      (yytype_uint8 const   )48,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )6,      (yytype_uint8 const   )83,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )26,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )89,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88};
static yytype_int8 const   yycheck[113]  = 
  {      (yytype_int8 const   )27,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4, 
        (yytype_int8 const   )12,      (yytype_int8 const   )15,      (yytype_int8 const   )102,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )19,      (yytype_int8 const   )15,      (yytype_int8 const   )19, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )25, 
        (yytype_int8 const   )112,      (yytype_int8 const   )25,      (yytype_int8 const   )19,      (yytype_int8 const   )27, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )107, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )25,      (yytype_int8 const   )25, 
        (yytype_int8 const   )25,      (yytype_int8 const   )113,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )25,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )23,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )96,      (yytype_int8 const   )24,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )0,      (yytype_int8 const   )12,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )4,      (yytype_int8 const   )27, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )30,      (yytype_int8 const   )22, 
        (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )19,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )19,      (yytype_int8 const   )26,      (yytype_int8 const   )20, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )59,      (yytype_int8 const   )27, 
        (yytype_int8 const   )84,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )25};
static yytype_uint8 const   yystos[114]  = 
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )53,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )53,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )36,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )50};
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 

  {
  if (! yymsg) {
    yymsg = "Deleting";
  }
  switch (yytype) {
  default: 
  break;
  }
  return;
}
}
int yyparse(parser_control *pc ) ;
int yyparse(parser_control *pc ) 
{ int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;

  {
  yylen = 0;
  yytoken = 0;
  yyss = yyssa;
  yyvs = yyvsa;
  yystacksize = 20UL;
  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = -2;
  yyssp = yyss;
  yyvsp = yyvs;
  goto yysetstate;
  yynewstate: 
  yyssp ++;
  yysetstate: 
  *yyssp = (yytype_int16 )yystate;
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
    yysize = (unsigned long )((yyssp - yyss) + 1);
    if (20UL <= yystacksize) {
      goto yyexhaustedlab;
    }
    yystacksize *= 2UL;
    if (20UL < yystacksize) {
      yystacksize = 20UL;
    }
    yyss1 = yyss;
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
    yyptr = (union yyalloc *)tmp;
    if (! yyptr) {
      goto yyexhaustedlab;
    }
    while (1) {
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
      yyss = & yyptr->yyss_alloc;
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
      yyptr += yynewbytes / sizeof(*yyptr);
      break;
    }
    while (1) {
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
      yyvs = & yyptr->yyvs_alloc;
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      break;
    }
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      free((void *)yyss1);
    }
    yyssp = (yyss + yysize) - 1;
    yyvsp = (yyvs + yysize) - 1;
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
      goto yyabortlab;
    }
  }
  if (yystate == 12) {
    goto yyacceptlab;
  }
  goto yybackup;
  yybackup: 
  yyn = (int )yypact[yystate];
  if (yyn == -93) {
    goto yydefault;
  }
  if (yychar == -2) {
    yychar = yylex(& yylval, pc);
  }
  if (yychar <= 0) {
    yytoken = 0;
    yychar = yytoken;
  } else
  if ((unsigned int )yychar <= 277U) {
    yytoken = (int )yytranslate[yychar];
  } else {
    yytoken = 2;
  }
  yyn += yytoken;
  if (yyn < 0) {
    goto yydefault;
  } else
  if (112 < yyn) {
    goto yydefault;
  } else
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
    goto yydefault;
  }
  yyn = (int )yytable[yyn];
  if (yyn <= 0) {
    if (yyn == 0) {
      goto yyerrlab;
    } else
    if (yyn == -1) {
      goto yyerrlab;
    }
    yyn = - yyn;
    goto yyreduce;
  }
  if (yyerrstatus) {
    yyerrstatus --;
  }
  yychar = -2;
  yystate = yyn;
  yyvsp ++;
  *yyvsp = yylval;
  goto yynewstate;
  yydefault: 
  yyn = (int )yydefact[yystate];
  if (yyn == 0) {
    goto yyerrlab;
  }
  goto yyreduce;
  yyreduce: 
  yylen = (int )yyr2[yyn];
  yyval = *(yyvsp + (1 - yylen));
  switch (yyn) {
  case 4: 
  pc->seconds = (yyvsp + 0)->timespec;
  pc->timespec_seen = (_Bool)1;
  break;
  case 7: 
  (pc->times_seen) ++;
  (pc->dates_seen) ++;
  break;
  case 8: 
  (pc->times_seen) ++;
  break;
  case 9: 
  (pc->local_zones_seen) ++;
  break;
  case 10: 
  (pc->zones_seen) ++;
  break;
  case 11: 
  (pc->dates_seen) ++;
  break;
  case 12: 
  (pc->days_seen) ++;
  break;
  case 18: 
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
  pc->meridian = (int )(yyvsp + 0)->intval;
  break;
  case 19: 
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
  pc->meridian = (int )(yyvsp + 0)->intval;
  break;
  case 20: 
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
  pc->meridian = (int )(yyvsp + 0)->intval;
  break;
  case 22: 
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
  pc->meridian = 2;
  break;
  case 23: 
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
  pc->meridian = 2;
  break;
  case 24: 
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
  pc->meridian = 2;
  break;
  case 27: 
  (pc->zones_seen) ++;
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  break;
  case 28: 
  pc->local_isdst = (int )(yyvsp + 0)->intval;
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
  break;
  case 29: 
  pc->local_isdst = 1;
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
  break;
  case 30: 
  pc->time_zone = (yyvsp + 0)->intval;
  break;
  case 31: 
  pc->time_zone = 420L;
  break;
  case 32: 
  pc->time_zone = (yyvsp + -1)->intval;
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  break;
  case 33: 
  pc->time_zone = 420L;
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  break;
  case 34: 
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
  break;
  case 35: 
  pc->time_zone = (yyvsp + 0)->intval + 60L;
  break;
  case 36: 
  pc->time_zone = (yyvsp + -1)->intval + 60L;
  break;
  case 37: 
  pc->day_ordinal = 0L;
  pc->day_number = (int )(yyvsp + 0)->intval;
  break;
  case 38: 
  pc->day_ordinal = 0L;
  pc->day_number = (int )(yyvsp + -1)->intval;
  break;
  case 39: 
  pc->day_ordinal = (yyvsp + -1)->intval;
  pc->day_number = (int )(yyvsp + 0)->intval;
  break;
  case 40: 
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
  pc->day_number = (int )(yyvsp + 0)->intval;
  break;
  case 41: 
  pc->month = (yyvsp + -2)->textintval.value;
  pc->day = (yyvsp + 0)->textintval.value;
  break;
  case 42: 
  if (4UL <= (yyvsp + -4)->textintval.digits) {
    pc->year = (yyvsp + -4)->textintval;
    pc->month = (yyvsp + -2)->textintval.value;
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
    pc->month = (yyvsp + -4)->textintval.value;
    pc->day = (yyvsp + -2)->textintval.value;
    pc->year = (yyvsp + 0)->textintval;
  }
  break;
  case 43: 
  pc->day = (yyvsp + -2)->textintval.value;
  pc->month = (yyvsp + -1)->intval;
  pc->year.value = - (yyvsp + 0)->textintval.value;
  pc->year.digits = (yyvsp + 0)->textintval.digits;
  break;
  case 44: 
  pc->month = (yyvsp + -2)->intval;
  pc->day = - (yyvsp + -1)->textintval.value;
  pc->year.value = - (yyvsp + 0)->textintval.value;
  pc->year.digits = (yyvsp + 0)->textintval.digits;
  break;
  case 45: 
  pc->month = (yyvsp + -1)->intval;
  pc->day = (yyvsp + 0)->textintval.value;
  break;
  case 46: 
  pc->month = (yyvsp + -3)->intval;
  pc->day = (yyvsp + -2)->textintval.value;
  pc->year = (yyvsp + 0)->textintval;
  break;
  case 47: 
  pc->day = (yyvsp + -1)->textintval.value;
  pc->month = (yyvsp + 0)->intval;
  break;
  case 48: 
  pc->day = (yyvsp + -2)->textintval.value;
  pc->month = (yyvsp + -1)->intval;
  pc->year = (yyvsp + 0)->textintval;
  break;
  case 50: 
  pc->year = (yyvsp + -2)->textintval;
  pc->month = - (yyvsp + -1)->textintval.value;
  pc->day = - (yyvsp + 0)->textintval.value;
  break;
  case 51: 
  apply_relative_time(pc, (yyvsp + -1)->rel, -1);
  break;
  case 52: 
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  break;
  case 53: 
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  break;
  case 54: 
  __constr_expr_0.year = 0L;
  __constr_expr_0.month = 0L;
  __constr_expr_0.day = 0L;
  __constr_expr_0.hour = 0L;
  __constr_expr_0.minutes = 0L;
  __constr_expr_0.seconds = (long_time_t )0;
  __constr_expr_0.ns = 0L;
  yyval.rel = __constr_expr_0;
  yyval.rel.year = (yyvsp + -1)->intval;
  break;
  case 55: 
  __constr_expr_1.year = 0L;
  __constr_expr_1.month = 0L;
  __constr_expr_1.day = 0L;
  __constr_expr_1.hour = 0L;
  __constr_expr_1.minutes = 0L;
  __constr_expr_1.seconds = (long_time_t )0;
  __constr_expr_1.ns = 0L;
  yyval.rel = __constr_expr_1;
  yyval.rel.year = (yyvsp + -1)->textintval.value;
  break;
  case 56: 
  __constr_expr_2.year = 0L;
  __constr_expr_2.month = 0L;
  __constr_expr_2.day = 0L;
  __constr_expr_2.hour = 0L;
  __constr_expr_2.minutes = 0L;
  __constr_expr_2.seconds = (long_time_t )0;
  __constr_expr_2.ns = 0L;
  yyval.rel = __constr_expr_2;
  yyval.rel.year = 1L;
  break;
  case 57: 
  __constr_expr_3.year = 0L;
  __constr_expr_3.month = 0L;
  __constr_expr_3.day = 0L;
  __constr_expr_3.hour = 0L;
  __constr_expr_3.minutes = 0L;
  __constr_expr_3.seconds = (long_time_t )0;
  __constr_expr_3.ns = 0L;
  yyval.rel = __constr_expr_3;
  yyval.rel.month = (yyvsp + -1)->intval;
  break;
  case 58: 
  __constr_expr_4.year = 0L;
  __constr_expr_4.month = 0L;
  __constr_expr_4.day = 0L;
  __constr_expr_4.hour = 0L;
  __constr_expr_4.minutes = 0L;
  __constr_expr_4.seconds = (long_time_t )0;
  __constr_expr_4.ns = 0L;
  yyval.rel = __constr_expr_4;
  yyval.rel.month = (yyvsp + -1)->textintval.value;
  break;
  case 59: 
  __constr_expr_5.year = 0L;
  __constr_expr_5.month = 0L;
  __constr_expr_5.day = 0L;
  __constr_expr_5.hour = 0L;
  __constr_expr_5.minutes = 0L;
  __constr_expr_5.seconds = (long_time_t )0;
  __constr_expr_5.ns = 0L;
  yyval.rel = __constr_expr_5;
  yyval.rel.month = 1L;
  break;
  case 60: 
  __constr_expr_6.year = 0L;
  __constr_expr_6.month = 0L;
  __constr_expr_6.day = 0L;
  __constr_expr_6.hour = 0L;
  __constr_expr_6.minutes = 0L;
  __constr_expr_6.seconds = (long_time_t )0;
  __constr_expr_6.ns = 0L;
  yyval.rel = __constr_expr_6;
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
  break;
  case 61: 
  __constr_expr_7.year = 0L;
  __constr_expr_7.month = 0L;
  __constr_expr_7.day = 0L;
  __constr_expr_7.hour = 0L;
  __constr_expr_7.minutes = 0L;
  __constr_expr_7.seconds = (long_time_t )0;
  __constr_expr_7.ns = 0L;
  yyval.rel = __constr_expr_7;
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
  break;
  case 62: 
  __constr_expr_8.year = 0L;
  __constr_expr_8.month = 0L;
  __constr_expr_8.day = 0L;
  __constr_expr_8.hour = 0L;
  __constr_expr_8.minutes = 0L;
  __constr_expr_8.seconds = (long_time_t )0;
  __constr_expr_8.ns = 0L;
  yyval.rel = __constr_expr_8;
  yyval.rel.day = (yyvsp + 0)->intval;
  break;
  case 63: 
  __constr_expr_9.year = 0L;
  __constr_expr_9.month = 0L;
  __constr_expr_9.day = 0L;
  __constr_expr_9.hour = 0L;
  __constr_expr_9.minutes = 0L;
  __constr_expr_9.seconds = (long_time_t )0;
  __constr_expr_9.ns = 0L;
  yyval.rel = __constr_expr_9;
  yyval.rel.hour = (yyvsp + -1)->intval;
  break;
  case 64: 
  __constr_expr_10.year = 0L;
  __constr_expr_10.month = 0L;
  __constr_expr_10.day = 0L;
  __constr_expr_10.hour = 0L;
  __constr_expr_10.minutes = 0L;
  __constr_expr_10.seconds = (long_time_t )0;
  __constr_expr_10.ns = 0L;
  yyval.rel = __constr_expr_10;
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
  break;
  case 65: 
  __constr_expr_11.year = 0L;
  __constr_expr_11.month = 0L;
  __constr_expr_11.day = 0L;
  __constr_expr_11.hour = 0L;
  __constr_expr_11.minutes = 0L;
  __constr_expr_11.seconds = (long_time_t )0;
  __constr_expr_11.ns = 0L;
  yyval.rel = __constr_expr_11;
  yyval.rel.hour = 1L;
  break;
  case 66: 
  __constr_expr_12.year = 0L;
  __constr_expr_12.month = 0L;
  __constr_expr_12.day = 0L;
  __constr_expr_12.hour = 0L;
  __constr_expr_12.minutes = 0L;
  __constr_expr_12.seconds = (long_time_t )0;
  __constr_expr_12.ns = 0L;
  yyval.rel = __constr_expr_12;
  yyval.rel.minutes = (yyvsp + -1)->intval;
  break;
  case 67: 
  __constr_expr_13.year = 0L;
  __constr_expr_13.month = 0L;
  __constr_expr_13.day = 0L;
  __constr_expr_13.hour = 0L;
  __constr_expr_13.minutes = 0L;
  __constr_expr_13.seconds = (long_time_t )0;
  __constr_expr_13.ns = 0L;
  yyval.rel = __constr_expr_13;
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
  break;
  case 68: 
  __constr_expr_14.year = 0L;
  __constr_expr_14.month = 0L;
  __constr_expr_14.day = 0L;
  __constr_expr_14.hour = 0L;
  __constr_expr_14.minutes = 0L;
  __constr_expr_14.seconds = (long_time_t )0;
  __constr_expr_14.ns = 0L;
  yyval.rel = __constr_expr_14;
  yyval.rel.minutes = 1L;
  break;
  case 69: 
  __constr_expr_15.year = 0L;
  __constr_expr_15.month = 0L;
  __constr_expr_15.day = 0L;
  __constr_expr_15.hour = 0L;
  __constr_expr_15.minutes = 0L;
  __constr_expr_15.seconds = (long_time_t )0;
  __constr_expr_15.ns = 0L;
  yyval.rel = __constr_expr_15;
  yyval.rel.seconds = (yyvsp + -1)->intval;
  break;
  case 70: 
  __constr_expr_16.year = 0L;
  __constr_expr_16.month = 0L;
  __constr_expr_16.day = 0L;
  __constr_expr_16.hour = 0L;
  __constr_expr_16.minutes = 0L;
  __constr_expr_16.seconds = (long_time_t )0;
  __constr_expr_16.ns = 0L;
  yyval.rel = __constr_expr_16;
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
  break;
  case 71: 
  __constr_expr_17.year = 0L;
  __constr_expr_17.month = 0L;
  __constr_expr_17.day = 0L;
  __constr_expr_17.hour = 0L;
  __constr_expr_17.minutes = 0L;
  __constr_expr_17.seconds = (long_time_t )0;
  __constr_expr_17.ns = 0L;
  yyval.rel = __constr_expr_17;
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
  break;
  case 72: 
  __constr_expr_18.year = 0L;
  __constr_expr_18.month = 0L;
  __constr_expr_18.day = 0L;
  __constr_expr_18.hour = 0L;
  __constr_expr_18.minutes = 0L;
  __constr_expr_18.seconds = (long_time_t )0;
  __constr_expr_18.ns = 0L;
  yyval.rel = __constr_expr_18;
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
  break;
  case 73: 
  __constr_expr_19.year = 0L;
  __constr_expr_19.month = 0L;
  __constr_expr_19.day = 0L;
  __constr_expr_19.hour = 0L;
  __constr_expr_19.minutes = 0L;
  __constr_expr_19.seconds = (long_time_t )0;
  __constr_expr_19.ns = 0L;
  yyval.rel = __constr_expr_19;
  yyval.rel.seconds = (long_time_t )1;
  break;
  case 75: 
  __constr_expr_20.year = 0L;
  __constr_expr_20.month = 0L;
  __constr_expr_20.day = 0L;
  __constr_expr_20.hour = 0L;
  __constr_expr_20.minutes = 0L;
  __constr_expr_20.seconds = (long_time_t )0;
  __constr_expr_20.ns = 0L;
  yyval.rel = __constr_expr_20;
  yyval.rel.year = (yyvsp + -1)->textintval.value;
  break;
  case 76: 
  __constr_expr_21.year = 0L;
  __constr_expr_21.month = 0L;
  __constr_expr_21.day = 0L;
  __constr_expr_21.hour = 0L;
  __constr_expr_21.minutes = 0L;
  __constr_expr_21.seconds = (long_time_t )0;
  __constr_expr_21.ns = 0L;
  yyval.rel = __constr_expr_21;
  yyval.rel.month = (yyvsp + -1)->textintval.value;
  break;
  case 77: 
  __constr_expr_22.year = 0L;
  __constr_expr_22.month = 0L;
  __constr_expr_22.day = 0L;
  __constr_expr_22.hour = 0L;
  __constr_expr_22.minutes = 0L;
  __constr_expr_22.seconds = (long_time_t )0;
  __constr_expr_22.ns = 0L;
  yyval.rel = __constr_expr_22;
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
  break;
  case 78: 
  __constr_expr_23.year = 0L;
  __constr_expr_23.month = 0L;
  __constr_expr_23.day = 0L;
  __constr_expr_23.hour = 0L;
  __constr_expr_23.minutes = 0L;
  __constr_expr_23.seconds = (long_time_t )0;
  __constr_expr_23.ns = 0L;
  yyval.rel = __constr_expr_23;
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
  break;
  case 79: 
  __constr_expr_24.year = 0L;
  __constr_expr_24.month = 0L;
  __constr_expr_24.day = 0L;
  __constr_expr_24.hour = 0L;
  __constr_expr_24.minutes = 0L;
  __constr_expr_24.seconds = (long_time_t )0;
  __constr_expr_24.ns = 0L;
  yyval.rel = __constr_expr_24;
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
  break;
  case 80: 
  __constr_expr_25.year = 0L;
  __constr_expr_25.month = 0L;
  __constr_expr_25.day = 0L;
  __constr_expr_25.hour = 0L;
  __constr_expr_25.minutes = 0L;
  __constr_expr_25.seconds = (long_time_t )0;
  __constr_expr_25.ns = 0L;
  yyval.rel = __constr_expr_25;
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
  break;
  case 81: 
  __constr_expr_26.year = 0L;
  __constr_expr_26.month = 0L;
  __constr_expr_26.day = 0L;
  __constr_expr_26.hour = 0L;
  __constr_expr_26.minutes = 0L;
  __constr_expr_26.seconds = (long_time_t )0;
  __constr_expr_26.ns = 0L;
  yyval.rel = __constr_expr_26;
  yyval.rel.day = (yyvsp + 0)->intval;
  break;
  case 85: 
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
  yyval.timespec.tv_nsec = 0L;
  break;
  case 87: 
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
  yyval.timespec.tv_nsec = 0L;
  break;
  case 88: 
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  break;
  case 89: 
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  break;
  case 90: 
  yyval.intval = -1L;
  break;
  case 91: 
  yyval.intval = (yyvsp + 0)->textintval.value;
  break;
  default: 
  break;
  }
  yyvsp -= yylen;
  yyssp -= yylen;
  yylen = 0;
  yyvsp ++;
  *yyvsp = yyval;
  yyn = (int )yyr1[yyn];
  yystate = (int )((int const   )yypgoto[yyn - 28] + (int const   )*yyssp);
  if (0 <= yystate) {
    if (yystate <= 112) {
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
        yystate = (int )yytable[yystate];
      } else {
        yystate = (int )yydefgoto[yyn - 28];
      }
    } else {
      yystate = (int )yydefgoto[yyn - 28];
    }
  } else {
    yystate = (int )yydefgoto[yyn - 28];
  }
  goto yynewstate;
  yyerrlab: 
  if (! yyerrstatus) {
    yynerrs ++;
    yyerror((parser_control const   *)pc, "syntax error");
  }
  if (yyerrstatus == 3) {
    if (yychar <= 0) {
      if (yychar == 0) {
        goto yyabortlab;
      }
    } else {
      yydestruct("Error: discarding", yytoken, & yylval, pc);
      yychar = -2;
    }
  }
  goto yyerrlab1;
  yyvsp -= yylen;
  yyssp -= yylen;
  yylen = 0;
  yystate = (int )*yyssp;
  goto yyerrlab1;
  yyerrlab1: 
  yyerrstatus = 3;
  while (1) {
    yyn = (int )yypact[yystate];
    if (yyn != -93) {
      yyn ++;
      if (0 <= yyn) {
        if (yyn <= 112) {
          if ((int const   )yycheck[yyn] == 1) {
            yyn = (int )yytable[yyn];
            if (0 < yyn) {
              break;
            }
          }
        }
      }
    }
    if ((unsigned long )yyssp == (unsigned long )yyss) {
      goto yyabortlab;
    }
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
    yyvsp --;
    yyssp --;
    yystate = (int )*yyssp;
  }
  yyvsp ++;
  *yyvsp = yylval;
  yystate = yyn;
  goto yynewstate;
  yyacceptlab: 
  yyresult = 0;
  goto yyreturn;
  yyabortlab: 
  yyresult = 1;
  goto yyreturn;
  yyexhaustedlab: 
  yyerror((parser_control const   *)pc, "memory exhausted");
  yyresult = 2;
  yyreturn: 
  if (yychar != -2) {
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
  }
  yyvsp -= yylen;
  yyssp -= yylen;
  while ((unsigned long )yyssp != (unsigned long )yyss) {
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
    yyvsp --;
    yyssp --;
  }
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    free((void *)yyss);
  }
  return (yyresult);
}
}
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
static table const   dst_table[1]  = {      {"DST", 259, 0}};
static table const   month_and_day_table[25]  = 
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
static table const   time_units_table[11]  = 
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
static table const   relative_time_table[20]  = 
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
static table const   time_zone_table[48]  = 
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
static table const   military_table[26]  = 
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 'T', 0}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
  if (s.digits <= 2UL) {
    if (mm < 0L) {
      s.value *= 100L;
    }
  }
  if (mm < 0L) {
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
    if (s.negative) {
      tmp = - mm;
    } else {
      tmp = mm;
    }
    n_minutes = s.value * 60L + tmp;
  }
  tmp___0 = abs((int )n_minutes);
  if (1440 < tmp___0) {
    (pc->zones_seen) ++;
  }
  return (n_minutes);
}
}
static int to_hour(long hours , int meridian ) 
{ long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  switch (meridian) {
  default: 
  if (0L <= hours) {
    if (hours < 24L) {
      tmp = hours;
    } else {
      tmp = -1L;
    }
  } else {
    tmp = -1L;
  }
  return ((int )tmp);
  case 0: 
  if (0L < hours) {
    if (hours < 12L) {
      tmp___1 = hours;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (hours == 12L) {
      tmp___0 = 0;
    } else {
      tmp___0 = -1;
    }
    tmp___1 = (long )tmp___0;
  }
  return ((int )tmp___1);
  case 1: 
  if (0L < hours) {
    if (hours < 12L) {
      tmp___3 = hours + 12L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (hours == 12L) {
      tmp___2 = 12;
    } else {
      tmp___2 = -1;
    }
    tmp___3 = (long )tmp___2;
  }
  return ((int )tmp___3);
  }
}
}
static long to_year(textint textyear ) 
{ long year___0 ;
  int tmp ;

  {
  year___0 = textyear.value;
  if (year___0 < 0L) {
    year___0 = - year___0;
  } else
  if (textyear.digits == 2UL) {
    if (year___0 < 69L) {
      tmp = 2000;
    } else {
      tmp = 1900;
    }
    year___0 += (long )tmp;
  }
  return (year___0);
}
}
static table const   *lookup_zone(parser_control const   *pc , char const   *name ) 
{ table const   *tp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  tp = universal_time_zone_table;
  while (tp->name) {
    if (0) {
      __s1_len = __builtin_strlen(name);
      __s2_len = __builtin_strlen((char const   *)tp->name);
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
          tmp___5 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
      } else {
        tmp___5 = 0;
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp(name, (char const   *)tp->name);
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp(name, (char const   *)tp->name);
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp(name, (char const   *)tp->name);
      tmp___4 = tmp___3;
    }
    if (tmp___4 == 0) {
      return (tp);
    }
    tp ++;
  }
  tp = (table const   *)(pc->local_time_zone_table);
  while (tp->name) {
    if (0) {
      __s1_len___0 = __builtin_strlen(name);
      __s2_len___0 = __builtin_strlen((char const   *)tp->name);
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1UL)) {
        goto _L___2;
      } else
      if (__s1_len___0 >= 4UL) {
        _L___2: 
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
          tmp___12 = 1;
        } else
        if (__s2_len___0 >= 4UL) {
          tmp___12 = 1;
        } else {
          tmp___12 = 0;
        }
      } else {
        tmp___12 = 0;
      }
      if (tmp___12) {
        tmp___7 = __builtin_strcmp(name, (char const   *)tp->name);
        tmp___11 = tmp___7;
      } else {
        tmp___10 = __builtin_strcmp(name, (char const   *)tp->name);
        tmp___11 = tmp___10;
      }
    } else {
      tmp___10 = __builtin_strcmp(name, (char const   *)tp->name);
      tmp___11 = tmp___10;
    }
    if (tmp___11 == 0) {
      return (tp);
    }
    tp ++;
  }
  tp = time_zone_table;
  while (tp->name) {
    if (0) {
      __s1_len___1 = __builtin_strlen(name);
      __s2_len___1 = __builtin_strlen((char const   *)tp->name);
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1UL)) {
        goto _L___4;
      } else
      if (__s1_len___1 >= 4UL) {
        _L___4: 
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
          tmp___19 = 1;
        } else
        if (__s2_len___1 >= 4UL) {
          tmp___19 = 1;
        } else {
          tmp___19 = 0;
        }
      } else {
        tmp___19 = 0;
      }
      if (tmp___19) {
        tmp___14 = __builtin_strcmp(name, (char const   *)tp->name);
        tmp___18 = tmp___14;
      } else {
        tmp___17 = __builtin_strcmp(name, (char const   *)tp->name);
        tmp___18 = tmp___17;
      }
    } else {
      tmp___17 = __builtin_strcmp(name, (char const   *)tp->name);
      tmp___18 = tmp___17;
    }
    if (tmp___18 == 0) {
      return (tp);
    }
    tp ++;
  }
  return ((table const   *)((void *)0));
}
}
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int __c ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___30 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___37 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char tmp___57 ;

  {
  p = word;
  while (*p) {
    ch = (unsigned char )*p;
    __c = (int )ch;
    if (__c >= 97) {
      if (__c <= 122) {
        tmp = (__c - 97) + 65;
      } else {
        tmp = __c;
      }
    } else {
      tmp = __c;
    }
    *p = (char )tmp;
    p ++;
  }
  tp = meridian_table;
  while (tp->name) {
    if (0) {
      __s1_len = __builtin_strlen((char const   *)word);
      __s2_len = __builtin_strlen((char const   *)tp->name);
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
          tmp___6 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___6 = 1;
        } else {
          tmp___6 = 0;
        }
      } else {
        tmp___6 = 0;
      }
      if (tmp___6) {
        tmp___1 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___5 = tmp___1;
      } else {
        tmp___4 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___5 = tmp___4;
      }
    } else {
      tmp___4 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
      tmp___5 = tmp___4;
    }
    if (tmp___5 == 0) {
      return (tp);
    }
    tp ++;
  }
  wordlen = strlen((char const   *)word);
  if (wordlen == 3UL) {
    tmp___7 = 1;
  } else
  if (wordlen == 4UL) {
    if ((int )*(word + 3) == 46) {
      tmp___7 = 1;
    } else {
      tmp___7 = 0;
    }
  } else {
    tmp___7 = 0;
  }
  abbrev = (_Bool )tmp___7;
  tp = month_and_day_table;
  while (tp->name) {
    if (abbrev) {
      if (0) {
        if (0) {
          __s1_len___0 = __builtin_strlen((char const   *)word);
          __s2_len___0 = __builtin_strlen((char const   *)tp->name);
          if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
            goto _L___2;
          } else
          if (__s1_len___0 >= 4UL) {
            _L___2: 
            if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
              tmp___16 = 1;
            } else
            if (__s2_len___0 >= 4UL) {
              tmp___16 = 1;
            } else {
              tmp___16 = 0;
            }
          } else {
            tmp___16 = 0;
          }
          if (tmp___16) {
            tmp___11 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
            tmp___15 = tmp___11;
          } else {
            tmp___14 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
            tmp___15 = tmp___14;
          }
        } else {
          tmp___14 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
          tmp___15 = tmp___14;
        }
        tmp___18 = tmp___15;
      } else {
        tmp___17 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
        tmp___18 = tmp___17;
      }
      tmp___28 = tmp___18;
    } else {
      if (0) {
        __s1_len___1 = __builtin_strlen((char const   *)word);
        __s2_len___1 = __builtin_strlen((char const   *)tp->name);
        if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
          goto _L___4;
        } else
        if (__s1_len___1 >= 4UL) {
          _L___4: 
          if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
            tmp___27 = 1;
          } else
          if (__s2_len___1 >= 4UL) {
            tmp___27 = 1;
          } else {
            tmp___27 = 0;
          }
        } else {
          tmp___27 = 0;
        }
        if (tmp___27) {
          tmp___22 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
          tmp___26 = tmp___22;
        } else {
          tmp___25 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
          tmp___26 = tmp___25;
        }
      } else {
        tmp___25 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___26 = tmp___25;
      }
      tmp___28 = tmp___26;
    }
    if (tmp___28 == 0) {
      return (tp);
    }
    tp ++;
  }
  tp = lookup_zone(pc, (char const   *)word);
  if (tp) {
    return (tp);
  }
  if (0) {
    __s1_len___2 = __builtin_strlen((char const   *)word);
    __s2_len___2 = __builtin_strlen((char const   *)dst_table[0].name);
    if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
      goto _L___6;
    } else
    if (__s1_len___2 >= 4UL) {
      _L___6: 
      if (! ((size_t )((void const   *)(dst_table[0].name + 1)) - (size_t )((void const   *)dst_table[0].name) == 1UL)) {
        tmp___35 = 1;
      } else
      if (__s2_len___2 >= 4UL) {
        tmp___35 = 1;
      } else {
        tmp___35 = 0;
      }
    } else {
      tmp___35 = 0;
    }
    if (tmp___35) {
      tmp___30 = __builtin_strcmp((char const   *)word, (char const   *)dst_table[0].name);
      tmp___34 = tmp___30;
    } else {
      tmp___33 = __builtin_strcmp((char const   *)word, (char const   *)dst_table[0].name);
      tmp___34 = tmp___33;
    }
  } else {
    tmp___33 = __builtin_strcmp((char const   *)word, (char const   *)dst_table[0].name);
    tmp___34 = tmp___33;
  }
  if (tmp___34 == 0) {
    return (dst_table);
  }
  tp = time_units_table;
  while (tp->name) {
    if (0) {
      __s1_len___3 = __builtin_strlen((char const   *)word);
      __s2_len___3 = __builtin_strlen((char const   *)tp->name);
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
        goto _L___8;
      } else
      if (__s1_len___3 >= 4UL) {
        _L___8: 
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
          tmp___42 = 1;
        } else
        if (__s2_len___3 >= 4UL) {
          tmp___42 = 1;
        } else {
          tmp___42 = 0;
        }
      } else {
        tmp___42 = 0;
      }
      if (tmp___42) {
        tmp___37 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___41 = tmp___37;
      } else {
        tmp___40 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___41 = tmp___40;
      }
    } else {
      tmp___40 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
      tmp___41 = tmp___40;
    }
    if (tmp___41 == 0) {
      return (tp);
    }
    tp ++;
  }
  if ((int )*(word + (wordlen - 1UL)) == 83) {
    *(word + (wordlen - 1UL)) = (char )'\000';
    tp = time_units_table;
    while (tp->name) {
      if (0) {
        __s1_len___4 = __builtin_strlen((char const   *)word);
        __s2_len___4 = __builtin_strlen((char const   *)tp->name);
        if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
          goto _L___10;
        } else
        if (__s1_len___4 >= 4UL) {
          _L___10: 
          if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
            tmp___49 = 1;
          } else
          if (__s2_len___4 >= 4UL) {
            tmp___49 = 1;
          } else {
            tmp___49 = 0;
          }
        } else {
          tmp___49 = 0;
        }
        if (tmp___49) {
          tmp___44 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
          tmp___48 = tmp___44;
        } else {
          tmp___47 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
          tmp___48 = tmp___47;
        }
      } else {
        tmp___47 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___48 = tmp___47;
      }
      if (tmp___48 == 0) {
        return (tp);
      }
      tp ++;
    }
    *(word + (wordlen - 1UL)) = (char )'S';
  }
  tp = relative_time_table;
  while (tp->name) {
    if (0) {
      __s1_len___5 = __builtin_strlen((char const   *)word);
      __s2_len___5 = __builtin_strlen((char const   *)tp->name);
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
        goto _L___12;
      } else
      if (__s1_len___5 >= 4UL) {
        _L___12: 
        if (! ((size_t )((void const   *)(tp->name + 1)) - (size_t )((void const   *)tp->name) == 1UL)) {
          tmp___56 = 1;
        } else
        if (__s2_len___5 >= 4UL) {
          tmp___56 = 1;
        } else {
          tmp___56 = 0;
        }
      } else {
        tmp___56 = 0;
      }
      if (tmp___56) {
        tmp___51 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___55 = tmp___51;
      } else {
        tmp___54 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
        tmp___55 = tmp___54;
      }
    } else {
      tmp___54 = __builtin_strcmp((char const   *)word, (char const   *)tp->name);
      tmp___55 = tmp___54;
    }
    if (tmp___55 == 0) {
      return (tp);
    }
    tp ++;
  }
  if (wordlen == 1UL) {
    tp = military_table;
    while (tp->name) {
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
        return (tp);
      }
      tp ++;
    }
  }
  period_found = (_Bool)0;
  q = word;
  p = q;
  while (1) {
    tmp___57 = *q;
    *p = tmp___57;
    if (! tmp___57) {
      break;
    }
    if ((int )*q == 46) {
      period_found = (_Bool)1;
    } else {
      p ++;
    }
    q ++;
  }
  if (period_found) {
    tp = lookup_zone(pc, (char const   *)word);
    if (tp) {
      return (tp);
    }
  }
  return ((table const   *)((void *)0));
}
}
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ unsigned char c ;
  size_t count ;
  int __c ;
  int tmp ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  int __c___0 ;
  int tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  int __c___1 ;
  int tmp___6 ;
  int __c___2 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  while (1) {
    while (1) {
      c = (unsigned char )*(pc->input);
      __c = (int )c;
      if (__c == 32) {
        tmp = 1;
      } else
      if (__c == 9) {
        tmp = 1;
      } else
      if (__c == 10) {
        tmp = 1;
      } else
      if (__c == 11) {
        tmp = 1;
      } else
      if (__c == 12) {
        tmp = 1;
      } else
      if (__c == 13) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      if (! tmp) {
        break;
      }
      (pc->input) ++;
    }
    if ((unsigned int )c - 48U <= 9U) {
      goto _L___2;
    } else
    if ((int )c == 45) {
      goto _L___2;
    } else
    if ((int )c == 43) {
      _L___2: 
      if ((int )c == 45) {
        goto _L;
      } else
      if ((int )c == 43) {
        _L: 
        if ((int )c == 45) {
          sign = -1;
        } else {
          sign = 1;
        }
        while (1) {
          (pc->input) ++;
          c = (unsigned char )*(pc->input);
          __c___0 = (int )c;
          if (__c___0 == 32) {
            tmp___0 = 1;
          } else
          if (__c___0 == 9) {
            tmp___0 = 1;
          } else
          if (__c___0 == 10) {
            tmp___0 = 1;
          } else
          if (__c___0 == 11) {
            tmp___0 = 1;
          } else
          if (__c___0 == 12) {
            tmp___0 = 1;
          } else
          if (__c___0 == 13) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
          if (! tmp___0) {
            break;
          }
          continue;
        }
        if (! ((unsigned int )c - 48U <= 9U)) {
          goto __Cont;
        }
      } else {
        sign = 0;
      }
      p = pc->input;
      value = 0UL;
      while (1) {
        value1 = value + (unsigned long )((int )c - 48);
        if (value1 < value) {
          return ('?');
        }
        value = value1;
        p ++;
        c = (unsigned char )*p;
        if (! ((unsigned int )c - 48U <= 9U)) {
          break;
        }
        if (1844674407370955161UL < value) {
          return ('?');
        }
        value *= 10UL;
      }
      if ((int )c == 46) {
        goto _L___1;
      } else
      if ((int )c == 44) {
        _L___1: 
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
          if (sign < 0) {
            s = (time_t )(- value);
            if (0L < s) {
              return ('?');
            }
            value1___0 = (unsigned long )(- s);
          } else {
            s = (time_t )value;
            if (s < 0L) {
              return ('?');
            }
            value1___0 = (unsigned long )s;
          }
          if (value != value1___0) {
            return ('?');
          }
          p ++;
          tmp___1 = p;
          p ++;
          ns = (int )((int const   )*tmp___1 - 48);
          digits = 2;
          while (digits <= 9) {
            ns *= 10;
            if ((unsigned int )*p - 48U <= 9U) {
              tmp___2 = p;
              p ++;
              ns += (int )((int const   )*tmp___2 - 48);
            }
            digits ++;
          }
          if (sign < 0) {
            while ((unsigned int )*p - 48U <= 9U) {
              if ((int const   )*p != 48) {
                ns ++;
                break;
              }
              p ++;
            }
          }
          while ((unsigned int )*p - 48U <= 9U) {
            p ++;
          }
          if (sign < 0) {
            if (ns) {
              s --;
              if (! (s < 0L)) {
                return ('?');
              }
              ns = 1000000000 - ns;
            }
          }
          lvalp->timespec.tv_sec = s;
          lvalp->timespec.tv_nsec = (long )ns;
          pc->input = p;
          if (sign) {
            tmp___3 = 276;
          } else {
            tmp___3 = 277;
          }
          return (tmp___3);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        lvalp->textintval.negative = (_Bool )(sign < 0);
        if (sign < 0) {
          lvalp->textintval.value = (long )(- value);
          if (0L < lvalp->textintval.value) {
            return ('?');
          }
        } else {
          lvalp->textintval.value = (long )value;
          if (lvalp->textintval.value < 0L) {
            return ('?');
          }
        }
        lvalp->textintval.digits = (size_t )(p - pc->input);
        pc->input = p;
        if (sign) {
          tmp___4 = 274;
        } else {
          tmp___4 = 275;
        }
        return (tmp___4);
      }
    }
    __c___2 = (int )c;
    if ((__c___2 & -33) >= 65) {
      if ((__c___2 & -33) <= 90) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    if (tmp___7) {
      p___0 = buff;
      while (1) {
        if ((unsigned long )(p___0 - buff) < sizeof(buff) - 1UL) {
          tmp___5 = p___0;
          p___0 ++;
          *tmp___5 = (char )c;
        }
        (pc->input) ++;
        c = (unsigned char )*(pc->input);
        __c___1 = (int )c;
        if ((__c___1 & -33) >= 65) {
          if ((__c___1 & -33) <= 90) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (! tmp___6) {
          if (! ((int )c == 46)) {
            break;
          }
        }
      }
      *p___0 = (char )'\000';
      tp = lookup_word((parser_control const   *)pc, buff);
      if (! tp) {
        return ('?');
      }
      lvalp->intval = (long )tp->value;
      return ((int )tp->type);
    }
    if ((int )c != 40) {
      tmp___8 = pc->input;
      (pc->input) ++;
      return ((int )*tmp___8);
    }
    count = (size_t )0;
    while (1) {
      tmp___9 = pc->input;
      (pc->input) ++;
      c = (unsigned char )*tmp___9;
      if ((int )c == 0) {
        return ((int )c);
      }
      if ((int )c == 40) {
        count ++;
      } else
      if ((int )c == 41) {
        count --;
      }
      if (! (count != 0UL)) {
        break;
      }
    }
    __Cont: ;
  }
}
}
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 

  {
  return (0);
}
}
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ struct tm *tmp ;

  {
  if (t == -1L) {
    tmp = localtime((time_t const   *)(& t));
    tm1 = (struct tm  const  *)tmp;
    if (! tm1) {
      return ((_Bool)0);
    }
  }
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
static char *get_tz(char *tzbuf ) 
{ char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void __attribute__((__artificial__))  *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = getenv("TZ");
  tz = tmp;
  if (tz) {
    tmp___0 = strlen((char const   *)tz);
    tzsize = tmp___0 + 1UL;
    if (tzsize <= 100UL) {
      tmp___1 = memcpy((void * __restrict  )tzbuf, (void const   * __restrict  )tz,
                       tzsize);
      tz = (char *)tmp___1;
    } else {
      tmp___2 = xmemdup((void const   *)tz, tzsize);
      tz = (char *)tmp___2;
    }
  }
  return (tz);
}
}
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  int __c ;
  int tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  relative_time __constr_expr_0 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___18 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  long tmp___27 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___28 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  int tmp___32 ;
  int year___0 ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  tz_was_altered = (_Bool)0;
  tz0 = (char *)((void *)0);
  ok = (_Bool)1;
  if (! now) {
    gettime(& gettime_buffer);
    now = (struct timespec  const  *)(& gettime_buffer);
  }
  Start = (time_t )now->tv_sec;
  Start_ns = (long )now->tv_nsec;
  tmp___0 = localtime(& now->tv_sec);
  tmp = (struct tm  const  *)tmp___0;
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    c = (unsigned char )*p;
    __c = (int )c;
    if (__c == 32) {
      tmp___1 = 1;
    } else
    if (__c == 9) {
      tmp___1 = 1;
    } else
    if (__c == 10) {
      tmp___1 = 1;
    } else
    if (__c == 11) {
      tmp___1 = 1;
    } else
    if (__c == 12) {
      tmp___1 = 1;
    } else
    if (__c == 13) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
    if (! tmp___1) {
      break;
    }
    p ++;
  }
  if (0) {
    if (0) {
      __s1_len = __builtin_strlen(p);
      __s2_len = __builtin_strlen("TZ=\"");
      if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)("TZ=\"" + 1)) - (size_t )((void const   *)"TZ=\"") == 1UL)) {
          tmp___13 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___13 = 1;
        } else {
          tmp___13 = 0;
        }
      } else {
        tmp___13 = 0;
      }
      if (tmp___13) {
        tmp___8 = __builtin_strcmp(p, "TZ=\"");
        tmp___12 = tmp___8;
      } else {
        tmp___11 = __builtin_strcmp(p, "TZ=\"");
        tmp___12 = tmp___11;
      }
    } else {
      tmp___11 = __builtin_strcmp(p, "TZ=\"");
      tmp___12 = tmp___11;
    }
    tmp___15 = tmp___12;
  } else {
    tmp___14 = strncmp(p, "TZ=\"", (size_t )4);
    tmp___15 = tmp___14;
  }
  if (tmp___15 == 0) {
    tzbase = p + 4;
    tzsize = (size_t )1;
    s = tzbase;
    while (*s) {
      if ((int const   )*s == 92) {
        s ++;
        if (! ((int const   )*s == 92)) {
          if (! ((int const   )*s == 34)) {
            break;
          }
        }
      } else
      if ((int const   )*s == 34) {
        large_tz = (_Bool )(100UL < tzsize);
        free((void *)tz0);
        tz0 = get_tz(tz0buf);
        if (large_tz) {
          tmp___2 = xmalloc(tzsize);
          tz1 = (char *)tmp___2;
        } else {
          tz1 = tz1buf;
        }
        z = tz1;
        s = tzbase;
        while ((int const   )*s != 34) {
          tmp___3 = z;
          z ++;
          s += (int const   )*s == 92;
          *tmp___3 = (char )*s;
          s ++;
        }
        *z = (char )'\000';
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
        setenv_ok = (_Bool )(tmp___4 == 0);
        if (large_tz) {
          free((void *)tz1);
        }
        if (! setenv_ok) {
          goto fail;
        }
        tz_was_altered = (_Bool)1;
        p = s + 1;
      }
      s ++;
      tzsize ++;
    }
  }
  if ((int const   )*p == 0) {
    p = "0";
  }
  pc.input = p;
  pc.year.value = (long )tmp->tm_year;
  pc.year.value += 1900L;
  pc.year.digits = (size_t )0;
  pc.month = (long )(tmp->tm_mon + 1);
  pc.day = (long )tmp->tm_mday;
  pc.hour = (long )tmp->tm_hour;
  pc.minutes = (long )tmp->tm_min;
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
  pc.seconds.tv_nsec = Start_ns;
  tm.tm_isdst = (int )tmp->tm_isdst;
  pc.meridian = 2;
  __constr_expr_0.year = 0L;
  __constr_expr_0.month = 0L;
  __constr_expr_0.day = 0L;
  __constr_expr_0.hour = 0L;
  __constr_expr_0.minutes = 0L;
  __constr_expr_0.seconds = (long_time_t )0;
  __constr_expr_0.ns = 0L;
  pc.rel = __constr_expr_0;
  pc.timespec_seen = (_Bool)0;
  pc.rels_seen = (_Bool)0;
  pc.dates_seen = (size_t )0;
  pc.days_seen = (size_t )0;
  pc.times_seen = (size_t )0;
  pc.local_zones_seen = (size_t )0;
  pc.dsts_seen = (size_t )0;
  pc.zones_seen = (size_t )0;
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
  pc.local_time_zone_table[0].type = 269;
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
  quarter = 1;
  while (quarter <= 3) {
    probe = Start + (time_t )(quarter * 7776000);
    tmp___18 = localtime((time_t const   *)(& probe));
    probe_tm = (struct tm  const  *)tmp___18;
    if (probe_tm) {
      if (probe_tm->tm_zone) {
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
          pc.local_time_zone_table[1].type = 269;
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
          break;
        }
      }
    }
    quarter ++;
  }
  if (pc.local_time_zone_table[0].name) {
    if (pc.local_time_zone_table[1].name) {
      if (0) {
        __s1_len___0 = __builtin_strlen(pc.local_time_zone_table[0].name);
        __s2_len___0 = __builtin_strlen(pc.local_time_zone_table[1].name);
        if (! ((size_t )((void const   *)(pc.local_time_zone_table[0].name + 1)) - (size_t )((void const   *)pc.local_time_zone_table[0].name) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)(pc.local_time_zone_table[1].name + 1)) - (size_t )((void const   *)pc.local_time_zone_table[1].name) == 1UL)) {
            tmp___25 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___25 = 1;
          } else {
            tmp___25 = 0;
          }
        } else {
          tmp___25 = 0;
        }
        if (tmp___25) {
          tmp___20 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
          tmp___24 = tmp___20;
        } else {
          tmp___23 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
          tmp___24 = tmp___23;
        }
      } else {
        tmp___23 = __builtin_strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
        tmp___24 = tmp___23;
      }
      if (! tmp___24) {
        pc.local_time_zone_table[0].value = -1;
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  tmp___26 = yyparse(& pc);
  if (tmp___26 != 0) {
    goto fail;
  }
  if (pc.timespec_seen) {
    *result = pc.seconds;
  } else {
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
      goto fail;
    }
    tmp___27 = to_year(pc.year);
    tm.tm_year = (int )(tmp___27 - 1900L);
    tm.tm_mon = (int )(pc.month - 1L);
    tm.tm_mday = (int )pc.day;
    if (pc.times_seen) {
      goto _L___3;
    } else
    if (pc.rels_seen) {
      if (! pc.dates_seen) {
        if (! pc.days_seen) {
          _L___3: 
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
          if (tm.tm_hour < 0) {
            goto fail;
          }
          tm.tm_min = (int )pc.minutes;
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
          tm.tm_sec = 0;
          tm.tm_min = tm.tm_sec;
          tm.tm_hour = tm.tm_min;
          pc.seconds.tv_nsec = 0L;
        }
      } else {
        tm.tm_sec = 0;
        tm.tm_min = tm.tm_sec;
        tm.tm_hour = tm.tm_min;
        pc.seconds.tv_nsec = 0L;
      }
    } else {
      tm.tm_sec = 0;
      tm.tm_min = tm.tm_sec;
      tm.tm_hour = tm.tm_min;
      pc.seconds.tv_nsec = 0L;
    }
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
      tm.tm_isdst = -1;
    }
    if (pc.local_zones_seen) {
      tm.tm_isdst = pc.local_isdst;
    }
    tm0 = tm;
    Start = mktime(& tm);
    tmp___31 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
    if (! tmp___31) {
      if (! pc.zones_seen) {
        goto fail;
      } else {
        time_zone = pc.time_zone;
        if (time_zone < 0L) {
          tmp___28 = - time_zone;
        } else {
          tmp___28 = time_zone;
        }
        abs_time_zone = tmp___28;
        abs_time_zone_hour = abs_time_zone / 60L;
        abs_time_zone_min = (int )(abs_time_zone % 60L);
        if (! tz_was_altered) {
          tz0 = get_tz(tz0buf);
        }
        sprintf((char * __restrict  )(tz1buf___0), (char const   * __restrict  )"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
        tmp___29 = setenv("TZ", (char const   *)(tz1buf___0), 1);
        if (tmp___29 != 0) {
          goto fail;
        }
        tz_was_altered = (_Bool)1;
        tm = tm0;
        Start = mktime(& tm);
        tmp___30 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
        if (! tmp___30) {
          goto fail;
        }
      }
    }
    if (pc.days_seen) {
      if (! pc.dates_seen) {
        if (0L < pc.day_ordinal) {
          if (tm.tm_wday != pc.day_number) {
            tmp___32 = 1;
          } else {
            tmp___32 = 0;
          }
        } else {
          tmp___32 = 0;
        }
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___32)));
        tm.tm_isdst = -1;
        Start = mktime(& tm);
        if (Start == -1L) {
          goto fail;
        }
      }
    }
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
      year___0 = (int )((long )tm.tm_year + pc.rel.year);
      month = (int )((long )tm.tm_mon + pc.rel.month);
      day = (int )((long )tm.tm_mday + pc.rel.day);
      if ((((year___0 < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
        goto fail;
      }
      tm.tm_year = year___0;
      tm.tm_mon = month;
      tm.tm_mday = day;
      tm.tm_hour = tm0.tm_hour;
      tm.tm_min = tm0.tm_min;
      tm.tm_sec = tm0.tm_sec;
      tm.tm_isdst = tm0.tm_isdst;
      Start = mktime(& tm);
      if (Start == -1L) {
        goto fail;
      }
    }
    if (pc.zones_seen) {
      delta = pc.time_zone * 60L;
      delta -= tm.tm_gmtoff;
      t1 = Start - delta;
      if ((Start < t1) != (delta < 0L)) {
        goto fail;
      }
      Start = t1;
    }
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
    t0 = Start;
    d1 = 3600L * pc.rel.hour;
    t1___0 = t0 + d1;
    d2 = 60L * pc.rel.minutes;
    t2 = t1___0 + d2;
    d3 = pc.rel.seconds;
    t3 = t2 + d3;
    d4 = (sum_ns - normalized_ns) / 1000000000L;
    t4 = t3 + d4;
    t5 = t4;
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
      goto fail;
    }
    result->tv_sec = t5;
    result->tv_nsec = normalized_ns;
  }
  goto done;
  fail: 
  ok = (_Bool)0;
  done: 
  if (tz_was_altered) {
    if (tz0) {
      tmp___33 = setenv("TZ", (char const   *)tz0, 1);
      tmp___35 = tmp___33;
    } else {
      tmp___34 = unsetenv("TZ");
      tmp___35 = tmp___34;
    }
    ok = (_Bool )((int )ok & (tmp___35 == 0));
  }
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
    free((void *)tz0);
  }
  return (ok);
}
}
double physmem_total(void) ;
double physmem_available(void) ;
double physmem_total(void) 
{ double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;

  {
  tmp = sysconf(85);
  pages = (double )tmp;
  tmp___0 = sysconf(30);
  pagesize = (double )tmp___0;
  if ((double )0 <= pages) {
    if ((double )0 <= pagesize) {
      return (pages * pagesize);
    }
  }
  return ((double )67108864);
}
}
double physmem_available(void) 
{ double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;
  double tmp___1 ;

  {
  tmp = sysconf(86);
  pages = (double )tmp;
  tmp___0 = sysconf(30);
  pagesize = (double )tmp___0;
  if ((double )0 <= pages) {
    if ((double )0 <= pagesize) {
      return (pages * pagesize);
    }
  }
  tmp___1 = physmem_total();
  return (tmp___1 / (double )4);
}
}
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) ;
static int year(struct tm *tm , int const   *digit_pair , size_t n , unsigned int syntax_bits ) 
{ time_t now ;
  struct tm *tmp ;

  {
  switch ((int )n) {
  case 1: 
  tm->tm_year = (int )*digit_pair;
  if (*(digit_pair + 0) <= 68) {
    if (syntax_bits & 16U) {
      return (1);
    }
    tm->tm_year += 100;
  }
  break;
  case 2: 
  if (! (syntax_bits & 4U)) {
    return (1);
  }
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
  break;
  case 0: 
  time(& now);
  tmp = localtime((time_t const   *)(& now));
  if (! tmp) {
    return (1);
  }
  tm->tm_year = tmp->tm_year;
  break;
  default: 
  abort();
  }
  return (0);
}
}
static int posix_time_parse(struct tm *tm , char const   *s , unsigned int syntax_bits ) 
{ char const   *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t tmp ;
  size_t len ;
  size_t tmp___2 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int seconds ;

  {
  dot = (char const   *)((void *)0);
  tmp = strlen(s);
  s_len = tmp;
  if (syntax_bits & 8U) {
    tmp___4 = __builtin_strchr((char *)s, '.');
    dot = (char const   *)tmp___4;
    if (dot) {
      tmp___2 = (size_t )(dot - s);
    } else {
      tmp___2 = s_len;
    }
  } else {
    tmp___2 = s_len;
  }
  len = tmp___2;
  if (len != 8UL) {
    if (len != 10UL) {
      if (len != 12UL) {
        return (1);
      }
    }
  }
  if (dot) {
    if (! (syntax_bits & 8U)) {
      return (1);
    }
    if (s_len - len != 3UL) {
      return (1);
    }
  }
  i = (size_t )0;
  while (i < len) {
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
      return (1);
    }
    i ++;
  }
  len /= 2UL;
  i = (size_t )0;
  while (i < len) {
    pair[i] = (10 * (int )((int const   )*(s + 2UL * i) - 48) + (int )*(s + (2UL * i + 1UL))) - 48;
    i ++;
  }
  p = pair;
  if (syntax_bits & 1U) {
    tmp___5 = year(tm, (int const   *)p, len - 4UL, syntax_bits);
    if (tmp___5) {
      return (1);
    }
    p += len - 4UL;
    len = (size_t )4;
  }
  tmp___6 = p;
  p ++;
  tm->tm_mon = *tmp___6 - 1;
  tmp___7 = p;
  p ++;
  tm->tm_mday = *tmp___7;
  tmp___8 = p;
  p ++;
  tm->tm_hour = *tmp___8;
  tmp___9 = p;
  p ++;
  tm->tm_min = *tmp___9;
  len -= 4UL;
  if (syntax_bits & 2U) {
    tmp___10 = year(tm, (int const   *)p, len, syntax_bits);
    if (tmp___10) {
      return (1);
    }
  }
  if (! dot) {
    tm->tm_sec = 0;
  } else {
    dot ++;
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U)) {
      return (1);
    } else
    if (! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
      return (1);
    }
    seconds = (10 * (int )((int const   )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
    tm->tm_sec = seconds;
  }
  return (0);
}
}
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) 
{ struct tm tm0 ;
  struct tm tm1 ;
  struct tm  const  *tm ;
  time_t t ;
  int tmp ;
  struct tm *tmp___0 ;
  time_t dummy ;
  char buf___1[16] ;
  char *b ;
  char __attribute__((__artificial__))  *tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = posix_time_parse(& tm0, s, syntax_bits);
  if (tmp) {
    return ((_Bool)0);
  }
  tm1 = tm0;
  tm1.tm_isdst = -1;
  t = mktime(& tm1);
  if (t != -1L) {
    tm = (struct tm  const  *)(& tm1);
  } else {
    tmp___0 = localtime((time_t const   *)(& t));
    tm = (struct tm  const  *)tmp___0;
    if (! tm) {
      return ((_Bool)0);
    }
  }
  if ((((((tm0.tm_year ^ (int )tm->tm_year) | (tm0.tm_mon ^ (int )tm->tm_mon)) | (tm0.tm_mday ^ (int )tm->tm_mday)) | (tm0.tm_hour ^ (int )tm->tm_hour)) | (tm0.tm_min ^ (int )tm->tm_min)) | (tm0.tm_sec ^ (int )tm->tm_sec)) {
    if (tm0.tm_sec != 60) {
      return ((_Bool)0);
    }
    tmp___1 = stpcpy((char * __restrict  )(buf___1), (char const   * __restrict  )s);
    b = (char *)tmp___1;
    strcpy((char * __restrict  )(b - 2), (char const   * __restrict  )"59");
    tmp___2 = posixtime(& dummy, (char const   *)(buf___1), syntax_bits);
    if (! tmp___2) {
      return ((_Bool)0);
    }
  }
  *p = t;
  return ((_Bool)1);
}
}
int posix2_version(void) ;
int posix2_version(void) 
{ long v ;
  char const   *s ;
  char *tmp ;
  char *e ;
  long i ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  v = 200809L;
  tmp = getenv("_POSIX2_VERSION");
  s = (char const   *)tmp;
  if (s) {
    if (*s) {
      tmp___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& e),
                       10);
      i = tmp___0;
      if (! *e) {
        v = i;
      }
    }
  }
  if (v < (-0x7FFFFFFF-1)) {
    tmp___2 = (-0x7FFFFFFF-1);
  } else {
    if (v < 2147483647L) {
      tmp___1 = v;
    } else {
      tmp___1 = 2147483647L;
    }
    tmp___2 = tmp___1;
  }
  return ((int )tmp___2);
}
}
double printf_frexp(double x , int *expptr ) ;
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
__inline extern int __signbitf(float __x ) 
{ int __m ;

  {
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
  return (__m & 8);
}
}
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
__inline extern int __signbit(double __x ) 
{ int __m ;

  {
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
  return (__m & 128);
}
}
double printf_frexp(double x , int *expptr ) 
{ int exponent ;

  {
  x = frexp(x, & exponent);
  x += x;
  exponent --;
  if (exponent < -1022) {
    x = ldexp(x, exponent - -1022);
    exponent = -1022;
  }
  *expptr = exponent;
  return (x);
}
}
long double printf_frexpl(long double x , int *expptr ) ;
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
long double printf_frexpl(long double x , int *expptr ) 
{ int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;

  {
  __asm__  volatile   ("fnstcw %0": "=m" (_cw));
  oldcw = _cw;
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
  __asm__  volatile   ("fldcw %0": : "m" (_ncw));
  x = frexpl(x, & exponent);
  x += x;
  exponent --;
  if (exponent < -16382) {
    x = ldexpl(x, exponent - -16382);
    exponent = -16382;
  }
  _ncw___0 = oldcw;
  __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
  *expptr = exponent;
  return (x);
}
}
char const   *program_name ;
void set_program_name(char const   *argv0 ) ;
extern char *program_invocation_name ;
extern char *program_invocation_short_name ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
char const   *program_name  =    (char const   *)((void *)0);
void set_program_name(char const   *argv0 ) 
{ char const   *slash ;
  char const   *base ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    fputs((char const   * __restrict  )"A NULL argv[0] was passed through an exec system call.\n",
          (FILE * __restrict  )stderr);
    abort();
  }
  tmp = strrchr(argv0, '/');
  slash = (char const   *)tmp;
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
    base = slash + 1;
  } else {
    base = argv0;
  }
  if (base - argv0 >= 7) {
    if (0) {
      if (0) {
        __s1_len___0 = __builtin_strlen(base - 7);
        __s2_len___0 = __builtin_strlen("/.libs/");
        if (! ((size_t )((void const   *)((base - 7) + 1)) - (size_t )((void const   *)(base - 7)) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)("/.libs/" + 1)) - (size_t )((void const   *)"/.libs/") == 1UL)) {
            tmp___21 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___21 = 1;
          } else {
            tmp___21 = 0;
          }
        } else {
          tmp___21 = 0;
        }
        if (tmp___21) {
          tmp___16 = __builtin_strcmp(base - 7, "/.libs/");
          tmp___20 = tmp___16;
        } else {
          tmp___19 = __builtin_strcmp(base - 7, "/.libs/");
          tmp___20 = tmp___19;
        }
      } else {
        tmp___19 = __builtin_strcmp(base - 7, "/.libs/");
        tmp___20 = tmp___19;
      }
      tmp___23 = tmp___20;
    } else {
      tmp___22 = strncmp(base - 7, "/.libs/", (size_t )7);
      tmp___23 = tmp___22;
    }
    if (tmp___23 == 0) {
      argv0 = base;
      if (0) {
        if (0) {
          __s1_len = __builtin_strlen(base);
          __s2_len = __builtin_strlen("lt-");
          if (! ((size_t )((void const   *)(base + 1)) - (size_t )((void const   *)base) == 1UL)) {
            goto _L___0;
          } else
          if (__s1_len >= 4UL) {
            _L___0: 
            if (! ((size_t )((void const   *)("lt-" + 1)) - (size_t )((void const   *)"lt-") == 1UL)) {
              tmp___8 = 1;
            } else
            if (__s2_len >= 4UL) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
          } else {
            tmp___8 = 0;
          }
          if (tmp___8) {
            tmp___3 = __builtin_strcmp(base, "lt-");
            tmp___7 = tmp___3;
          } else {
            tmp___6 = __builtin_strcmp(base, "lt-");
            tmp___7 = tmp___6;
          }
        } else {
          tmp___6 = __builtin_strcmp(base, "lt-");
          tmp___7 = tmp___6;
        }
        tmp___10 = tmp___7;
      } else {
        tmp___9 = strncmp(base, "lt-", (size_t )3);
        tmp___10 = tmp___9;
      }
      if (tmp___10 == 0) {
        argv0 = base + 3;
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
  program_name = argv0;
  program_invocation_name = (char *)argv0;
  return;
}
}
char const   *proper_name(char const   *name ) ;
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
char *trim2(char const   *s , int how ) ;
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
  tmp = trim2(sub, 2);
  tsub = tmp;
  found = (_Bool)0;
  while ((int const   )*string != 0) {
    tmp___0 = mbsstr(string, (char const   *)tsub);
    tsub_in_string = (char const   *)tmp___0;
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
      break;
    } else {
      tmp___11 = __ctype_get_mb_cur_max();
      if (tmp___11 > 1UL) {
        string_iter.cur.ptr = string;
        string_iter.in_shift = (_Bool)0;
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
        string_iter.next_done = (_Bool)0;
        word_boundary_before = (_Bool)1;
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
          while (1) {
            mbuiter_multi_next(& string_iter);
            if (string_iter.cur.wc_valid) {
              if (string_iter.cur.wc == 0) {
                tmp___1 = 0;
              } else {
                tmp___1 = 1;
              }
            } else {
              tmp___1 = 1;
            }
            if (! tmp___1) {
              abort();
            }
            last_char_before_tsub = string_iter.cur;
            string_iter.cur.ptr += string_iter.cur.bytes;
            string_iter.next_done = (_Bool)0;
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
              break;
            }
          }
          if (last_char_before_tsub.wc_valid) {
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
            if (tmp___2) {
              word_boundary_before = (_Bool)0;
            }
          }
        }
        string_iter.cur.ptr = tsub_in_string;
        string_iter.in_shift = (_Bool)0;
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
        string_iter.next_done = (_Bool)0;
        tsub_iter.cur.ptr = (char const   *)tsub;
        tsub_iter.in_shift = (_Bool)0;
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
        tsub_iter.next_done = (_Bool)0;
        while (1) {
          mbuiter_multi_next(& tsub_iter);
          if (tsub_iter.cur.wc_valid) {
            if (tsub_iter.cur.wc == 0) {
              tmp___4 = 0;
            } else {
              tmp___4 = 1;
            }
          } else {
            tmp___4 = 1;
          }
          if (! tmp___4) {
            break;
          }
          mbuiter_multi_next(& string_iter);
          if (string_iter.cur.wc_valid) {
            if (string_iter.cur.wc == 0) {
              tmp___3 = 0;
            } else {
              tmp___3 = 1;
            }
          } else {
            tmp___3 = 1;
          }
          if (! tmp___3) {
            abort();
          }
          string_iter.cur.ptr += string_iter.cur.bytes;
          string_iter.next_done = (_Bool)0;
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
          tsub_iter.next_done = (_Bool)0;
        }
        word_boundary_after = (_Bool)1;
        mbuiter_multi_next(& string_iter);
        if (string_iter.cur.wc_valid) {
          if (string_iter.cur.wc == 0) {
            tmp___6 = 0;
          } else {
            tmp___6 = 1;
          }
        } else {
          tmp___6 = 1;
        }
        if (tmp___6) {
          first_char_after_tsub = string_iter.cur;
          if (first_char_after_tsub.wc_valid) {
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
            if (tmp___5) {
              word_boundary_after = (_Bool)0;
            }
          }
        }
        if (word_boundary_before) {
          if (word_boundary_after) {
            found = (_Bool)1;
            break;
          }
        }
        string_iter.cur.ptr = tsub_in_string;
        string_iter.in_shift = (_Bool)0;
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
        string_iter.next_done = (_Bool)0;
        mbuiter_multi_next(& string_iter);
        if (string_iter.cur.wc_valid) {
          if (string_iter.cur.wc == 0) {
            tmp___7 = 0;
          } else {
            tmp___7 = 1;
          }
        } else {
          tmp___7 = 1;
        }
        if (! tmp___7) {
          break;
        }
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
        word_boundary_before___0 = (_Bool)1;
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
          tmp___8 = __ctype_b_loc();
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
            word_boundary_before___0 = (_Bool)0;
          }
        }
        tmp___9 = strlen((char const   *)tsub);
        p = tsub_in_string + tmp___9;
        word_boundary_after___0 = (_Bool)1;
        if ((int const   )*p != 0) {
          tmp___10 = __ctype_b_loc();
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
            word_boundary_after___0 = (_Bool)0;
          }
        }
        if (word_boundary_before___0) {
          if (word_boundary_after___0) {
            found = (_Bool)1;
            break;
          }
        }
        if ((int const   )*tsub_in_string == 0) {
          break;
        }
        string = tsub_in_string + 1;
      }
    }
  }
  free((void *)tsub);
  return (found);
}
}
char const   *proper_name(char const   *name ) 
{ char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  tmp = dcgettext((char const   *)((void *)0), name, 5);
  translation = (char const   *)tmp;
  if ((unsigned long )translation != (unsigned long )name) {
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
    if (tmp___7) {
      return (translation);
    } else {
      if (sizeof(char ) == 1UL) {
        tmp___0 = strlen(translation);
        tmp___1 = strlen(name);
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
        tmp___6 = tmp___2;
      } else {
        tmp___3 = strlen(translation);
        tmp___4 = strlen(name);
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
        tmp___6 = tmp___5;
      }
      result = (char *)tmp___6;
      sprintf((char * __restrict  )result, (char const   * __restrict  )"%s (%s)",
              translation, name);
      return ((char const   *)result);
    }
  } else {
    return (name);
  }
}
}
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *result ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  tmp = dcgettext((char const   *)((void *)0), name_ascii, 5);
  translation = (char const   *)tmp;
  tmp___0 = locale_charset();
  locale_code = tmp___0;
  alloc_name_converted = (char *)((void *)0);
  alloc_name_converted_translit = (char *)((void *)0);
  name_converted = (char const   *)((void *)0);
  name_converted_translit = (char const   *)((void *)0);
  tmp___7 = c_strcasecmp(locale_code, "UTF-8");
  if (tmp___7 != 0) {
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
    name_converted = (char const   *)alloc_name_converted;
    tmp___1 = strlen(locale_code);
    len = tmp___1;
    if (sizeof(char ) == 1UL) {
      tmp___2 = xmalloc((len + 10UL) + 1UL);
      tmp___4 = tmp___2;
    } else {
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
      tmp___4 = tmp___3;
    }
    locale_code_translit = (char *)tmp___4;
    memcpy((void * __restrict  )locale_code_translit, (void const   * __restrict  )locale_code,
           len);
    memcpy((void * __restrict  )(locale_code_translit + len), (void const   * __restrict  )"//TRANSLIT",
           (size_t )11);
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
    free((void *)locale_code_translit);
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
      tmp___6 = __builtin_strchr(converted_translit, '?');
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        free((void *)converted_translit);
      } else {
        alloc_name_converted_translit = converted_translit;
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
    name_converted = name_utf8;
    name_converted_translit = name_utf8;
  }
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
    name = name_converted;
  } else {
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      tmp___8 = name_converted_translit;
    } else {
      tmp___8 = name_ascii;
    }
    name = tmp___8;
  }
  if (0) {
    __s1_len = __builtin_strlen(translation);
    __s2_len = __builtin_strlen(name_ascii);
    if (! ((size_t )((void const   *)(translation + 1)) - (size_t )((void const   *)translation) == 1UL)) {
      goto _L___3;
    } else
    if (__s1_len >= 4UL) {
      _L___3: 
      if (! ((size_t )((void const   *)(name_ascii + 1)) - (size_t )((void const   *)name_ascii) == 1UL)) {
        tmp___25 = 1;
      } else
      if (__s2_len >= 4UL) {
        tmp___25 = 1;
      } else {
        tmp___25 = 0;
      }
    } else {
      tmp___25 = 0;
    }
    if (tmp___25) {
      tmp___20 = __builtin_strcmp(translation, name_ascii);
      tmp___24 = tmp___20;
    } else {
      tmp___23 = __builtin_strcmp(translation, name_ascii);
      tmp___24 = tmp___23;
    }
  } else {
    tmp___23 = __builtin_strcmp(translation, name_ascii);
    tmp___24 = tmp___23;
  }
  if (tmp___24 != 0) {
    tmp___16 = mbsstr_trimmed_wordbounded(translation, name_ascii);
    if (tmp___16) {
      goto _L;
    } else
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted);
      if (tmp___17) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else
    _L___1: 
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
      tmp___18 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
      if (tmp___18) {
        _L: 
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
          free((void *)alloc_name_converted);
        }
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
          free((void *)alloc_name_converted_translit);
        }
        return (translation);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (sizeof(char ) == 1UL) {
        tmp___9 = strlen(translation);
        tmp___10 = strlen(name);
        tmp___11 = xmalloc((((tmp___9 + 2UL) + tmp___10) + 1UL) + 1UL);
        tmp___15 = tmp___11;
      } else {
        tmp___12 = strlen(translation);
        tmp___13 = strlen(name);
        tmp___14 = xnmalloc((((tmp___12 + 2UL) + tmp___13) + 1UL) + 1UL, sizeof(char ));
        tmp___15 = tmp___14;
      }
      result = (char *)tmp___15;
      sprintf((char * __restrict  )result, (char const   * __restrict  )"%s (%s)",
              translation, name);
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
        free((void *)alloc_name_converted);
      }
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
        free((void *)alloc_name_converted_translit);
      }
      return ((char const   *)result);
    }
  } else {
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
        free((void *)alloc_name_converted);
      }
    }
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
        free((void *)alloc_name_converted_translit);
      }
    }
    return (name);
  }
}
}
char const   *quote_n(int n , char const   *name ) 
{ char *tmp ;

  {
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  return ((char const   *)tmp);
}
}
char const   *quote(char const   *name ) 
{ char const   *tmp ;

  {
  tmp = quote_n(0, name);
  return (tmp);
}
}
char const   * const  quoting_style_args[9] ;
enum quoting_style  const  quoting_style_vals[8] ;
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
int set_quoting_flags(struct quoting_options *o , int i ) ;
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
char *quotearg_n(int n , char const   *arg ) ;
char *quotearg(char const   *arg ) ;
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
char *quotearg_mem(char const   *arg , size_t argsize ) ;
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
char *quotearg_char(char const   *arg , char ch ) ;
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
void quotearg_free(void) ;
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
__inline static char *xcharalloc(size_t n ) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (sizeof(char ) == 1UL) {
    tmp = xmalloc(n);
    tmp___1 = tmp;
  } else {
    tmp___0 = xnmalloc(n, sizeof(char ));
    tmp___1 = tmp___0;
  }
  return ((char *)tmp___1);
}
}
char const   * const  quoting_style_args[9]  = 
  {      (char const   * const  )"literal",      (char const   * const  )"shell",      (char const   * const  )"shell-always",      (char const   * const  )"c", 
        (char const   * const  )"c-maybe",      (char const   * const  )"escape",      (char const   * const  )"locale",      (char const   * const  )"clocale", 
        (char const   * const  )0};
enum quoting_style  const  quoting_style_vals[8]  = 
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
static struct quoting_options default_quoting_options  ;
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  tmp = __errno_location();
  e = *tmp;
  if (o) {
    tmp___0 = o;
  } else {
    tmp___0 = & default_quoting_options;
  }
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
  p = (struct quoting_options *)tmp___1;
  tmp___2 = __errno_location();
  *tmp___2 = e;
  return (p);
}
}
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ struct quoting_options *tmp ;

  {
  if (o) {
    tmp = o;
  } else {
    tmp = & default_quoting_options;
  }
  return (tmp->style);
}
}
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ struct quoting_options *tmp ;

  {
  if (o) {
    tmp = o;
  } else {
    tmp = & default_quoting_options;
  }
  tmp->style = s;
  return;
}
}
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
  uc = (unsigned char )c;
  if (o) {
    tmp = o;
  } else {
    tmp = & default_quoting_options;
  }
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
  r = (int )((*p >> shift) & 1U);
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
  return (r);
}
}
int set_quoting_flags(struct quoting_options *o , int i ) 
{ int r ;

  {
  if (! o) {
    o = & default_quoting_options;
  }
  r = o->flags;
  o->flags = i;
  return (r);
}
}
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 

  {
  if (! o) {
    o = & default_quoting_options;
  }
  o->style = (enum quoting_style )8;
  if (! left_quote) {
    abort();
  } else
  if (! right_quote) {
    abort();
  }
  o->left_quote = left_quote;
  o->right_quote = right_quote;
  return;
}
}
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ struct quoting_options o ;

  {
  o.style = (enum quoting_style )0;
  o.flags = 0;
  o.quote_these_too[0] = 0U;
  o.quote_these_too[1] = 0U;
  o.quote_these_too[2] = 0U;
  o.quote_these_too[3] = 0U;
  o.quote_these_too[4] = 0U;
  o.quote_these_too[5] = 0U;
  o.quote_these_too[6] = 0U;
  o.quote_these_too[7] = 0U;
  o.left_quote = (char const   *)0;
  o.right_quote = (char const   *)0;
  if ((unsigned int )style == 8U) {
    abort();
  }
  o.style = style;
  return (o);
}
}
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ char const   *translation ;
  char *tmp ;

  {
  tmp = dcgettext((char const   *)((void *)0), msgid, 5);
  translation = (char const   *)tmp;
  if ((unsigned long )translation == (unsigned long )msgid) {
    if ((unsigned int )s == 7U) {
      translation = "\"";
    }
  }
  return (translation);
}
}
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  len = (size_t )0;
  quote_string = (char const   *)0;
  quote_string_len = (size_t )0;
  backslash_escapes = (_Bool)0;
  tmp = __ctype_get_mb_cur_max();
  unibyte_locale = (_Bool )(tmp == 1UL);
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  switch ((int )quoting_style) {
  case 4: 
  quoting_style = (enum quoting_style )3;
  elide_outer_quotes = (_Bool)1;
  case 3: 
  if (! elide_outer_quotes) {
    while (1) {
      if (len < buffersize) {
        *(buffer + len) = (char )'\"';
      }
      len ++;
      break;
    }
  }
  backslash_escapes = (_Bool)1;
  quote_string = "\"";
  quote_string_len = (size_t )1;
  break;
  case 5: 
  backslash_escapes = (_Bool)1;
  elide_outer_quotes = (_Bool)0;
  break;
  case 6: 
  case 7: 
  case 8: 
  if ((unsigned int )quoting_style != 8U) {
    left_quote = gettext_quote("`", quoting_style);
    right_quote = gettext_quote("\'", quoting_style);
  }
  if (! elide_outer_quotes) {
    quote_string = left_quote;
    while (*quote_string) {
      while (1) {
        if (len < buffersize) {
          *(buffer + len) = (char )*quote_string;
        }
        len ++;
        break;
      }
      quote_string ++;
    }
  }
  backslash_escapes = (_Bool)1;
  quote_string = right_quote;
  quote_string_len = strlen(quote_string);
  break;
  case 1: 
  quoting_style = (enum quoting_style )2;
  elide_outer_quotes = (_Bool)1;
  case 2: 
  if (! elide_outer_quotes) {
    while (1) {
      if (len < buffersize) {
        *(buffer + len) = (char )'\'';
      }
      len ++;
      break;
    }
  }
  quote_string = "\'";
  quote_string_len = (size_t )1;
  break;
  case 0: 
  elide_outer_quotes = (_Bool)0;
  break;
  default: 
  abort();
  }
  i = (size_t )0;
  while (1) {
    if (argsize == 0xffffffffffffffffUL) {
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
      tmp___6 = i == argsize;
    }
    if (tmp___6) {
      break;
    }
    is_right_quote = (_Bool)0;
    if (backslash_escapes) {
      if (quote_string_len) {
        if (i + quote_string_len <= argsize) {
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          if (tmp___0 == 0) {
            if (elide_outer_quotes) {
              goto force_outer_quoting_style;
            }
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
    c = (unsigned char )*(arg + i);
    switch ((int )c) {
    case 0: 
    if (backslash_escapes) {
      if (elide_outer_quotes) {
        goto force_outer_quoting_style;
      }
      while (1) {
        if (len < buffersize) {
          *(buffer + len) = (char )'\\';
        }
        len ++;
        break;
      }
      if (i + 1UL < argsize) {
        if (48 <= (int )*(arg + (i + 1UL))) {
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
            while (1) {
              if (len < buffersize) {
                *(buffer + len) = (char )'0';
              }
              len ++;
              break;
            }
            while (1) {
              if (len < buffersize) {
                *(buffer + len) = (char )'0';
              }
              len ++;
              break;
            }
          }
        }
      }
      c = (unsigned char )'0';
    } else
    if (flags & 1) {
      goto __Cont;
    }
    break;
    case 63: 
    switch ((int )quoting_style) {
    case 2: 
    if (elide_outer_quotes) {
      goto force_outer_quoting_style;
    }
    break;
    case 3: 
    if (flags & 4) {
      if (i + 2UL < argsize) {
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          switch ((int )*(arg + (i + 2UL))) {
          case 33: 
          case 39: 
          case 40: 
          case 41: 
          case 45: 
          case 47: 
          case 60: 
          case 61: 
          case 62: 
          if (elide_outer_quotes) {
            goto force_outer_quoting_style;
          }
          c = (unsigned char )*(arg + (i + 2UL));
          i += 2UL;
          while (1) {
            if (len < buffersize) {
              *(buffer + len) = (char )'?';
            }
            len ++;
            break;
          }
          while (1) {
            if (len < buffersize) {
              *(buffer + len) = (char )'\"';
            }
            len ++;
            break;
          }
          while (1) {
            if (len < buffersize) {
              *(buffer + len) = (char )'\"';
            }
            len ++;
            break;
          }
          while (1) {
            if (len < buffersize) {
              *(buffer + len) = (char )'?';
            }
            len ++;
            break;
          }
          break;
          default: 
          break;
          }
        }
      }
    }
    break;
    default: 
    break;
    }
    break;
    case 7: 
    esc = (unsigned char )'a';
    goto c_escape;
    case 8: 
    esc = (unsigned char )'b';
    goto c_escape;
    case 12: 
    esc = (unsigned char )'f';
    goto c_escape;
    case 10: 
    esc = (unsigned char )'n';
    goto c_and_shell_escape;
    case 13: 
    esc = (unsigned char )'r';
    goto c_and_shell_escape;
    case 9: 
    esc = (unsigned char )'t';
    goto c_and_shell_escape;
    case 11: 
    esc = (unsigned char )'v';
    goto c_escape;
    case 92: 
    esc = c;
    if (backslash_escapes) {
      if (elide_outer_quotes) {
        if (quote_string_len) {
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
    if ((unsigned int )quoting_style == 2U) {
      if (elide_outer_quotes) {
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
    if (backslash_escapes) {
      c = esc;
      goto store_escape;
    }
    break;
    case 123: 
    case 125: 
    if (argsize == 0xffffffffffffffffUL) {
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
      tmp___1 = argsize == 1UL;
    }
    if (! tmp___1) {
      break;
    }
    case 35: 
    case 126: 
    if (i != 0UL) {
      break;
    }
    case 32: 
    case 33: 
    case 34: 
    case 36: 
    case 38: 
    case 40: 
    case 41: 
    case 42: 
    case 59: 
    case 60: 
    case 61: 
    case 62: 
    case 91: 
    case 94: 
    case 96: 
    case 124: 
    if ((unsigned int )quoting_style == 2U) {
      if (elide_outer_quotes) {
        goto force_outer_quoting_style;
      }
    }
    break;
    case 39: 
    if ((unsigned int )quoting_style == 2U) {
      if (elide_outer_quotes) {
        goto force_outer_quoting_style;
      }
      while (1) {
        if (len < buffersize) {
          *(buffer + len) = (char )'\'';
        }
        len ++;
        break;
      }
      while (1) {
        if (len < buffersize) {
          *(buffer + len) = (char )'\\';
        }
        len ++;
        break;
      }
      while (1) {
        if (len < buffersize) {
          *(buffer + len) = (char )'\'';
        }
        len ++;
        break;
      }
    }
    break;
    case 37: 
    case 43: 
    case 44: 
    case 45: 
    case 46: 
    case 47: 
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    case 58: 
    case 65: 
    case 66: 
    case 67: 
    case 68: 
    case 69: 
    case 70: 
    case 71: 
    case 72: 
    case 73: 
    case 74: 
    case 75: 
    case 76: 
    case 77: 
    case 78: 
    case 79: 
    case 80: 
    case 81: 
    case 82: 
    case 83: 
    case 84: 
    case 85: 
    case 86: 
    case 87: 
    case 88: 
    case 89: 
    case 90: 
    case 93: 
    case 95: 
    case 97: 
    case 98: 
    case 99: 
    case 100: 
    case 101: 
    case 102: 
    case 103: 
    case 104: 
    case 105: 
    case 106: 
    case 107: 
    case 108: 
    case 109: 
    case 110: 
    case 111: 
    case 112: 
    case 113: 
    case 114: 
    case 115: 
    case 116: 
    case 117: 
    case 118: 
    case 119: 
    case 120: 
    case 121: 
    case 122: 
    break;
    default: 
    if (unibyte_locale) {
      m = (size_t )1;
      tmp___2 = __ctype_b_loc();
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
    } else {
      memset((void *)(& mbstate), 0, sizeof(mbstate));
      m = (size_t )0;
      printable = (_Bool)1;
      if (argsize == 0xffffffffffffffffUL) {
        argsize = strlen(arg);
      }
      while (1) {
        tmp___3 = mbrtowc((wchar_t * __restrict  )(& w), (char const   * __restrict  )(arg + (i + m)),
                          argsize - (i + m), & mbstate);
        bytes = tmp___3;
        if (bytes == 0UL) {
          break;
        } else
        if (bytes == 0xffffffffffffffffUL) {
          printable = (_Bool)0;
          break;
        } else
        if (bytes == 0xfffffffffffffffeUL) {
          printable = (_Bool)0;
          while (1) {
            if (i + m < argsize) {
              if (! *(arg + (i + m))) {
                break;
              }
            } else {
              break;
            }
            m ++;
          }
          break;
        } else {
          if (elide_outer_quotes) {
            if ((unsigned int )quoting_style == 2U) {
              j = (size_t )1;
              while (j < bytes) {
                switch ((int )*(arg + ((i + m) + j))) {
                case 91: 
                case 92: 
                case 94: 
                case 96: 
                case 124: 
                goto force_outer_quoting_style;
                default: 
                break;
                }
                j ++;
              }
            }
          }
          tmp___4 = iswprint((wint_t )w);
          if (! tmp___4) {
            printable = (_Bool)0;
          }
          m += bytes;
        }
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        if (tmp___5) {
          break;
        }
      }
    }
    if (1UL < m) {
      goto _L___0;
    } else
    if (backslash_escapes) {
      if (! printable) {
        _L___0: 
        ilim = i + m;
        while (1) {
          if (backslash_escapes) {
            if (! printable) {
              if (elide_outer_quotes) {
                goto force_outer_quoting_style;
              }
              while (1) {
                if (len < buffersize) {
                  *(buffer + len) = (char )'\\';
                }
                len ++;
                break;
              }
              while (1) {
                if (len < buffersize) {
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
                len ++;
                break;
              }
              while (1) {
                if (len < buffersize) {
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
                len ++;
                break;
              }
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
              goto _L;
            }
          } else
          _L: 
          if (is_right_quote) {
            while (1) {
              if (len < buffersize) {
                *(buffer + len) = (char )'\\';
              }
              len ++;
              break;
            }
            is_right_quote = (_Bool)0;
          }
          if (ilim <= i + 1UL) {
            break;
          }
          while (1) {
            if (len < buffersize) {
              *(buffer + len) = (char )c;
            }
            len ++;
            break;
          }
          i ++;
          c = (unsigned char )*(arg + i);
        }
        goto store_c;
      }
    }
    }
    if (backslash_escapes) {
      goto _L___3;
    } else
    if (elide_outer_quotes) {
      _L___3: 
      if (quote_these_too) {
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else
    _L___2: 
    if (! is_right_quote) {
      goto store_c;
    }
    store_escape: 
    if (elide_outer_quotes) {
      goto force_outer_quoting_style;
    }
    while (1) {
      if (len < buffersize) {
        *(buffer + len) = (char )'\\';
      }
      len ++;
      break;
    }
    store_c: 
    while (1) {
      if (len < buffersize) {
        *(buffer + len) = (char )c;
      }
      len ++;
      break;
    }
    __Cont: 
    i ++;
  }
  if (len == 0UL) {
    if ((unsigned int )quoting_style == 2U) {
      if (elide_outer_quotes) {
        goto force_outer_quoting_style;
      }
    }
  }
  if (quote_string) {
    if (! elide_outer_quotes) {
      while (*quote_string) {
        while (1) {
          if (len < buffersize) {
            *(buffer + len) = (char )*quote_string;
          }
          len ++;
          break;
        }
        quote_string ++;
      }
    }
  }
  if (len < buffersize) {
    *(buffer + len) = (char )'\000';
  }
  return (len);
  force_outer_quoting_style: 
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  return (tmp___7);
}
}
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
  if (o) {
    tmp = o;
  } else {
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  p = tmp;
  tmp___0 = __errno_location();
  e = *tmp___0;
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
  r = tmp___1;
  tmp___2 = __errno_location();
  *tmp___2 = e;
  return (r);
}
}
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ char *tmp ;

  {
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  return (tmp);
}
}
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf___1 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  if (o) {
    tmp = o;
  } else {
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  p = tmp;
  tmp___0 = __errno_location();
  e = *tmp___0;
  if (size) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  flags = (int )(p->flags | (int const   )tmp___1);
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
  bufsize___0 = tmp___2 + 1UL;
  tmp___3 = xcharalloc(bufsize___0);
  buf___1 = tmp___3;
  quotearg_buffer_restyled(buf___1, bufsize___0, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
  tmp___4 = __errno_location();
  *tmp___4 = e;
  if (size) {
    *size = bufsize___0 - 1UL;
  }
  return (buf___1);
}
}
static char slot0[256]  ;
static unsigned int nslots  =    1U;
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
static struct slotvec *slotvec  =    & slotvec0;
void quotearg_free(void) 
{ struct slotvec *sv ;
  unsigned int i ;

  {
  sv = slotvec;
  i = 1U;
  while (i < nslots) {
    free((void *)(sv + i)->val);
    i ++;
  }
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    free((void *)(sv + 0)->val);
    slotvec0.size = sizeof(slot0);
    slotvec0.val = slot0;
  }
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    free((void *)sv);
    slotvec = & slotvec0;
  }
  nslots = 1U;
  return;
}
}
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  tmp = __errno_location();
  e = *tmp;
  n0 = (unsigned int )n;
  sv = slotvec;
  if (n < 0) {
    abort();
  }
  if (nslots <= n0) {
    n1 = (size_t )(n0 + 1U);
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
      tmp___0 = -1;
    } else {
      tmp___0 = -2;
    }
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      xalloc_die();
    }
    if (preallocated) {
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
      tmp___1 = sv;
    }
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
    sv = (struct slotvec *)tmp___2;
    slotvec = sv;
    if (preallocated) {
      *sv = slotvec0;
    }
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
    nslots = (unsigned int )n1;
  }
  size = (sv + n)->size;
  val = (sv + n)->val;
  flags = (int )(options->flags | 1);
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
  qsize = tmp___3;
  if (size <= qsize) {
    size = qsize + 1UL;
    (sv + n)->size = size;
    if ((unsigned long )val != (unsigned long )(slot0)) {
      free((void *)val);
    }
    val = xcharalloc(size);
    (sv + n)->val = val;
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
  }
  tmp___4 = __errno_location();
  *tmp___4 = e;
  return (val);
}
}
char *quotearg_n(int n , char const   *arg ) 
{ char *tmp ;

  {
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  return (tmp);
}
}
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  return (tmp);
}
}
char *quotearg(char const   *arg ) 
{ char *tmp ;

  {
  tmp = quotearg_n(0, arg);
  return (tmp);
}
}
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
  tmp = quotearg_n_mem(0, arg, argsize);
  return (tmp);
}
}
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  tmp = quoting_options_from_style(s);
  o = tmp;
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  return (tmp___0);
}
}
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  tmp = quoting_options_from_style(s);
  o = tmp;
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  return (tmp___0);
}
}
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ char *tmp ;

  {
  tmp = quotearg_n_style(0, s, arg);
  return (tmp);
}
}
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  return (tmp);
}
}
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ struct quoting_options options ;
  char *tmp ;

  {
  options = default_quoting_options;
  set_char_quoting(& options, ch, 1);
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  return (tmp);
}
}
char *quotearg_char(char const   *arg , char ch ) 
{ char *tmp ;

  {
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  return (tmp);
}
}
char *quotearg_colon(char const   *arg ) 
{ char *tmp ;

  {
  tmp = quotearg_char(arg, (char )':');
  return (tmp);
}
}
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ char *tmp ;

  {
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  return (tmp);
}
}
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ char *tmp ;

  {
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
  return (tmp);
}
}
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ struct quoting_options o ;
  char *tmp ;

  {
  o = default_quoting_options;
  set_custom_quoting(& o, left_quote, right_quote);
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  return (tmp);
}
}
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ char *tmp ;

  {
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  return (tmp);
}
}
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ char *tmp ;

  {
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  return (tmp);
}
}
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) ;
void randread(struct randread_source *s , void *buf___1 , size_t size ) ;
int randread_free(struct randread_source *s ) ;
struct randint_source *randint_new(struct randread_source *source ) ;
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) ;
struct randread_source *randint_get_source(struct randint_source  const  *s )  __attribute__((__pure__)) ;
randint randint_genmax(struct randint_source *s , randint genmax ) ;
void randint_free(struct randint_source *s ) ;
int randint_all_free(struct randint_source *s ) ;
struct randint_source *randint_new(struct randread_source *source ) 
{ struct randint_source *s ;
  void *tmp ;
  randint tmp___0 ;

  {
  tmp = xmalloc(sizeof(*s));
  s = (struct randint_source *)tmp;
  s->source = source;
  tmp___0 = (randint )0;
  s->randmax = tmp___0;
  s->randnum = tmp___0;
  return (s);
}
}
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) 
{ struct randread_source *source ;
  struct randread_source *tmp ;
  struct randint_source *tmp___0 ;
  struct randint_source *tmp___1 ;

  {
  tmp = randread_new(name, bytes_bound);
  source = tmp;
  if (source) {
    tmp___0 = randint_new(source);
    tmp___1 = tmp___0;
  } else {
    tmp___1 = (struct randint_source *)((void *)0);
  }
  return (tmp___1);
}
}
struct randread_source *randint_get_source(struct randint_source  const  *s )  __attribute__((__pure__)) ;
struct randread_source *randint_get_source(struct randint_source  const  *s ) 
{ 

  {
  return ((struct randread_source *)s->source);
}
}
__inline static randint shift_left(randint x ) 
{ 

  {
  return (x << 8);
}
}
randint randint_genmax(struct randint_source *s , randint genmax ) 
{ struct randread_source *source ;
  randint randnum ;
  randint randmax ;
  randint choices ;
  size_t i ;
  randint rmax ;
  unsigned char buf___1[sizeof(randnum)] ;
  randint tmp ;
  randint tmp___0 ;
  randint tmp___1 ;
  randint tmp___2 ;
  randint excess_choices ;
  randint unusable_choices ;
  randint last_usable_choice ;
  randint reduced_randnum ;

  {
  source = s->source;
  randnum = s->randnum;
  randmax = s->randmax;
  choices = genmax + 1UL;
  while (1) {
    if (randmax < genmax) {
      i = (size_t )0;
      rmax = randmax;
      while (1) {
        tmp = shift_left(rmax);
        rmax = tmp + 255UL;
        i ++;
        if (! (rmax < genmax)) {
          break;
        }
      }
      randread(source, (void *)(buf___1), i);
      i = (size_t )0;
      while (1) {
        tmp___0 = shift_left(randnum);
        randnum = tmp___0 + (randint )buf___1[i];
        tmp___1 = shift_left(randmax);
        randmax = tmp___1 + 255UL;
        i ++;
        if (! (randmax < genmax)) {
          break;
        }
      }
    }
    if (randmax == genmax) {
      tmp___2 = (randint )0;
      s->randmax = tmp___2;
      s->randnum = tmp___2;
      return (randnum);
    } else {
      excess_choices = randmax - genmax;
      unusable_choices = excess_choices % choices;
      last_usable_choice = randmax - unusable_choices;
      reduced_randnum = randnum % choices;
      if (randnum <= last_usable_choice) {
        s->randnum = randnum / choices;
        s->randmax = excess_choices / choices;
        return (reduced_randnum);
      }
      randnum = reduced_randnum;
      randmax = unusable_choices - 1UL;
    }
  }
}
}
void randint_free(struct randint_source *s ) 
{ 

  {
  memset((void *)s, 0, sizeof(*s));
  free((void *)s);
  return;
}
}
int randint_all_free(struct randint_source *s ) 
{ int r ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = randread_free(s->source);
  r = tmp;
  tmp___0 = __errno_location();
  e = *tmp___0;
  randint_free(s);
  tmp___1 = __errno_location();
  *tmp___1 = e;
  return (r);
}
}
__inline static randint randint_choose(struct randint_source *s , randint choices ) 
{ randint tmp ;

  {
  tmp = randint_genmax(s, choices - 1UL);
  return (tmp);
}
}
size_t randperm_bound(size_t h , size_t n )  __attribute__((__const__)) ;
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
static size_t ceil_lg(size_t n )  __attribute__((__const__)) ;
static size_t ceil_lg(size_t n )  __attribute__((__const__)) ;
static size_t ceil_lg(size_t n ) 
{ size_t b ;

  {
  b = (size_t )0;
  n --;
  while (n != 0UL) {
    b ++;
    n /= 2UL;
  }
  return (b);
}
}
size_t randperm_bound(size_t h , size_t n )  __attribute__((__const__)) ;
size_t randperm_bound(size_t h , size_t n ) 
{ size_t lg_n ;
  size_t tmp ;
  size_t ar ;
  size_t bound ;

  {
  tmp = ceil_lg(n);
  lg_n = tmp;
  ar = lg_n * h;
  bound = ((ar + 8UL) - 1UL) / 8UL;
  return (bound);
}
}
static void swap(size_t *v , size_t i , size_t j ) 
{ size_t t ;

  {
  t = *(v + i);
  *(v + i) = *(v + j);
  *(v + j) = t;
  return;
}
}
static size_t sparse_hash_(void const   *x , size_t table_size ) 
{ struct sparse_ent_  const  *ent ;

  {
  ent = (struct sparse_ent_  const  *)x;
  return ((size_t )(ent->index % (unsigned long const   )table_size));
}
}
static _Bool sparse_cmp_(void const   *x , void const   *y ) 
{ struct sparse_ent_  const  *ent1 ;
  struct sparse_ent_  const  *ent2 ;

  {
  ent1 = (struct sparse_ent_  const  *)x;
  ent2 = (struct sparse_ent_  const  *)y;
  return ((_Bool )(ent1->index == ent2->index));
}
}
static sparse_map *sparse_new(size_t size_hint ) 
{ Hash_table *tmp ;

  {
  tmp = hash_initialize(size_hint, (Hash_tuning const   *)((void *)0), & sparse_hash_,
                        & sparse_cmp_, & free);
  return (tmp);
}
}
static void sparse_swap(sparse_map *sv , size_t *v , size_t i , size_t j ) 
{ struct sparse_ent_ *v1 ;
  struct sparse_ent_ __constr_expr_0 ;
  void *tmp ;
  struct sparse_ent_ *v2 ;
  struct sparse_ent_ __constr_expr_1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t t ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  __constr_expr_0.index = i;
  __constr_expr_0.val = (size_t )0;
  tmp = hash_delete(sv, (void const   *)(& __constr_expr_0));
  v1 = (struct sparse_ent_ *)tmp;
  __constr_expr_1.index = j;
  __constr_expr_1.val = (size_t )0;
  tmp___0 = hash_delete(sv, (void const   *)(& __constr_expr_1));
  v2 = (struct sparse_ent_ *)tmp___0;
  if (! v1) {
    tmp___1 = xmalloc(sizeof(*v1));
    v1 = (struct sparse_ent_ *)tmp___1;
    tmp___2 = i;
    v1->val = tmp___2;
    v1->index = tmp___2;
  }
  if (! v2) {
    tmp___3 = xmalloc(sizeof(*v2));
    v2 = (struct sparse_ent_ *)tmp___3;
    tmp___4 = j;
    v2->val = tmp___4;
    v2->index = tmp___4;
  }
  t = v1->val;
  v1->val = v2->val;
  v2->val = t;
  tmp___5 = hash_insert(sv, (void const   *)v1);
  if (! tmp___5) {
    xalloc_die();
  }
  tmp___6 = hash_insert(sv, (void const   *)v2);
  if (! tmp___6) {
    xalloc_die();
  }
  *(v + i) = v1->val;
  return;
}
}
static void sparse_free(sparse_map *sv ) 
{ 

  {
  hash_free(sv);
  return;
}
}
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) 
{ size_t *v ;
  void *tmp ;
  _Bool sparse ;
  int tmp___0 ;
  size_t i ;
  sparse_map *sv ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t j ;
  randint tmp___3 ;
  void *tmp___4 ;

  {
  switch ((int )h) {
  case 0: 
  v = (size_t *)((void *)0);
  break;
  case 1: 
  tmp = xmalloc(sizeof(*v));
  v = (size_t *)tmp;
  *(v + 0) = randint_choose(r, n);
  break;
  default: 
  if (n >= 131072UL) {
    if (n / h >= 32UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  sparse = (_Bool )tmp___0;
  if (sparse) {
    sv = sparse_new(h * 2UL);
    if ((unsigned long )sv == (unsigned long )((void *)0)) {
      xalloc_die();
    }
    tmp___1 = xnmalloc(h, sizeof(*v));
    v = (size_t *)tmp___1;
  } else {
    sv = (sparse_map *)((void *)0);
    tmp___2 = xnmalloc(n, sizeof(*v));
    v = (size_t *)tmp___2;
    i = (size_t )0;
    while (i < n) {
      *(v + i) = i;
      i ++;
    }
  }
  i = (size_t )0;
  while (i < h) {
    tmp___3 = randint_choose(r, n - i);
    j = i + tmp___3;
    if (sparse) {
      sparse_swap(sv, v, i, j);
    } else {
      swap(v, i, j);
    }
    i ++;
  }
  if (sparse) {
    sparse_free(sv);
  } else {
    tmp___4 = xnrealloc((void *)v, h, sizeof(*v));
    v = (size_t *)tmp___4;
  }
  break;
  }
  return (v);
}
}
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) ;
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) ;
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
void isaac_seed(struct isaac_state *s ) ;
void isaac_refill(struct isaac_state *s , isaac_word *result ) ;
static  __attribute__((__noreturn__)) void randread_error(void const   *file_name___1 ) ;
static  __attribute__((__noreturn__)) void randread_error(void const   *file_name___1 ) ;
static void randread_error(void const   *file_name___1 ) 
{ char *tmp ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  if (file_name___1) {
    tmp = quotearg_colon((char const   *)file_name___1);
    tmp___2 = __errno_location();
    if (*tmp___2 == 0) {
      tmp___1 = "%s: end of file";
    } else {
      tmp___1 = "%s: read error";
    }
    tmp___3 = dcgettext((char const   *)((void *)0), tmp___1, 5);
    tmp___4 = __errno_location();
    error((int )exit_failure, *tmp___4, (char const   *)tmp___3, tmp);
  }
  abort();
}
}
static struct randread_source *simple_new(FILE *source , void const   *handler_arg ) 
{ struct randread_source *s ;
  void *tmp ;

  {
  tmp = xmalloc(sizeof(*s));
  s = (struct randread_source *)tmp;
  s->source = source;
  s->handler = & randread_error;
  s->handler_arg = handler_arg;
  return (s);
}
}
static void get_nonce(void *buffer , size_t bufsize___0 , size_t bytes_bound ) 
{ char *buf___1 ;
  ssize_t seeded ;
  int fd ;
  int __attribute__((__artificial__))  tmp ;
  size_t tmp___0 ;
  ssize_t __attribute__((__artificial__))  tmp___1 ;
  struct timeval v ;
  size_t nbytes ;
  unsigned long tmp___2 ;
  pid_t v___0 ;
  size_t nbytes___0 ;
  unsigned long tmp___3 ;
  pid_t v___1 ;
  size_t nbytes___1 ;
  unsigned long tmp___4 ;
  uid_t v___2 ;
  size_t nbytes___2 ;
  unsigned long tmp___5 ;
  uid_t v___3 ;
  size_t nbytes___3 ;
  unsigned long tmp___6 ;
  ssize_t __attribute__((__artificial__))  tmp___7 ;

  {
  buf___1 = (char *)buffer;
  seeded = (ssize_t )0;
  tmp = open("/dev/urandom", 0);
  fd = (int )tmp;
  if (0 <= fd) {
    if (bufsize___0 < bytes_bound) {
      tmp___0 = bufsize___0;
    } else {
      tmp___0 = bytes_bound;
    }
    tmp___7 = (ssize_t __attribute__((__artificial__))  )read(fd, (void *)buf___1,
                                                              tmp___0);
    tmp___1 = tmp___7;
    seeded = (ssize_t )tmp___1;
    if (seeded < 0L) {
      seeded = (ssize_t )0;
    }
    close(fd);
  }
  if ((size_t )seeded < bufsize___0) {
    if (sizeof(v) < bufsize___0 - (size_t )seeded) {
      tmp___2 = sizeof(v);
    } else {
      tmp___2 = bufsize___0 - (size_t )seeded;
    }
    nbytes = tmp___2;
    gettimeofday((struct timeval * __restrict  )(& v), (__timezone_ptr_t )((void *)0));
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v),
           nbytes);
    seeded = (ssize_t )((size_t )seeded + nbytes);
  }
  if ((size_t )seeded < bufsize___0) {
    if (sizeof(v___0) < bufsize___0 - (size_t )seeded) {
      tmp___3 = sizeof(v___0);
    } else {
      tmp___3 = bufsize___0 - (size_t )seeded;
    }
    nbytes___0 = tmp___3;
    v___0 = getpid();
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___0),
           nbytes___0);
    seeded = (ssize_t )((size_t )seeded + nbytes___0);
  }
  if ((size_t )seeded < bufsize___0) {
    if (sizeof(v___1) < bufsize___0 - (size_t )seeded) {
      tmp___4 = sizeof(v___1);
    } else {
      tmp___4 = bufsize___0 - (size_t )seeded;
    }
    nbytes___1 = tmp___4;
    v___1 = getppid();
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___1),
           nbytes___1);
    seeded = (ssize_t )((size_t )seeded + nbytes___1);
  }
  if ((size_t )seeded < bufsize___0) {
    if (sizeof(v___2) < bufsize___0 - (size_t )seeded) {
      tmp___5 = sizeof(v___2);
    } else {
      tmp___5 = bufsize___0 - (size_t )seeded;
    }
    nbytes___2 = tmp___5;
    v___2 = getuid();
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___2),
           nbytes___2);
    seeded = (ssize_t )((size_t )seeded + nbytes___2);
  }
  if ((size_t )seeded < bufsize___0) {
    if (sizeof(v___3) < bufsize___0 - (size_t )seeded) {
      tmp___6 = sizeof(v___3);
    } else {
      tmp___6 = bufsize___0 - (size_t )seeded;
    }
    nbytes___3 = tmp___6;
    v___3 = getgid();
    memcpy((void * __restrict  )(buf___1 + seeded), (void const   * __restrict  )(& v___3),
           nbytes___3);
    seeded = (ssize_t )((size_t )seeded + nbytes___3);
  }
  return;
}
}
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) 
{ struct randread_source *tmp ;
  FILE *source ;
  struct randread_source *s ;
  unsigned long tmp___0 ;

  {
  if (bytes_bound == 0UL) {
    tmp = simple_new((FILE *)((void *)0), (void const   *)((void *)0));
    return (tmp);
  } else {
    source = (FILE *)((void *)0);
    if (name) {
      source = fopen_safer(name, "rb");
      if (! source) {
        return ((struct randread_source *)((void *)0));
      }
    }
    s = simple_new(source, (void const   *)name);
    if (source) {
      if (sizeof(s->buf.c) < bytes_bound) {
        tmp___0 = sizeof(s->buf.c);
      } else {
        tmp___0 = bytes_bound;
      }
      setvbuf((FILE * __restrict  )source, (char * __restrict  )(s->buf.c), 0, tmp___0);
    } else {
      s->buf.isaac.buffered = (size_t )0;
      get_nonce((void *)(s->buf.isaac.state.m), sizeof(s->buf.isaac.state.m), bytes_bound);
      isaac_seed(& s->buf.isaac.state);
    }
    return (s);
  }
}
}
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) 
{ 

  {
  s->handler = handler;
  return;
}
}
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) 
{ 

  {
  s->handler_arg = handler_arg;
  return;
}
}
static void readsource(struct randread_source *s , unsigned char *p , size_t size ) 
{ size_t inbytes ;
  size_t __attribute__((__artificial__))  tmp ;
  int fread_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  size_t __attribute__((__artificial__))  tmp___4 ;

  {
  while (1) {
    tmp___4 = (size_t __attribute__((__artificial__))  )fread_unlocked((void * __restrict  )p,
                                                                       sizeof(*p),
                                                                       size, (FILE * __restrict  )s->source);
    tmp = tmp___4;
    inbytes = (size_t )tmp;
    tmp___0 = __errno_location();
    fread_errno = *tmp___0;
    p += inbytes;
    size -= inbytes;
    if (size == 0UL) {
      break;
    }
    tmp___1 = __errno_location();
    tmp___3 = ferror_unlocked(s->source);
    if (tmp___3) {
      *tmp___1 = fread_errno;
    } else {
      *tmp___1 = 0;
    }
    (*(s->handler))(s->handler_arg);
  }
  return;
}
}
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size ) 
{ size_t inbytes ;
  isaac_word *wp ;

  {
  inbytes = isaac->buffered;
  while (1) {
    if (size <= inbytes) {
      memcpy((void * __restrict  )p, (void const   * __restrict  )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(isaac_word )) - inbytes),
             size);
      isaac->buffered = inbytes - size;
      return;
    }
    memcpy((void * __restrict  )p, (void const   * __restrict  )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(isaac_word )) - inbytes),
           inbytes);
    p += inbytes;
    size -= inbytes;
    wp = (isaac_word *)p;
    while ((unsigned long )(1 << 8) * sizeof(isaac_word ) <= size) {
      isaac_refill(& isaac->state, wp);
      wp += 1 << 8;
      size -= (unsigned long )(1 << 8) * sizeof(isaac_word );
      if (size == 0UL) {
        isaac->buffered = (size_t )0;
        return;
      }
    }
    p = (unsigned char *)wp;
    isaac_refill(& isaac->state, isaac->data.w);
    inbytes = (unsigned long )(1 << 8) * sizeof(isaac_word );
  }
}
}
void randread(struct randread_source *s , void *buf___1 , size_t size ) 
{ 

  {
  if (s->source) {
    readsource(s, (unsigned char *)buf___1, size);
  } else {
    readisaac(& s->buf.isaac, (unsigned char *)buf___1, size);
  }
  return;
}
}
int randread_free(struct randread_source *s ) 
{ FILE *source ;
  int tmp ;
  int tmp___0 ;

  {
  source = s->source;
  memset((void *)s, 0, sizeof(*s));
  free((void *)s);
  if (source) {
    tmp = rpl_fclose(source);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
__inline static isaac_word just(isaac_word a ) 
{ isaac_word desired_bits ;

  {
  desired_bits = ((1UL << 1) << ((1 << 6) - 1)) - 1UL;
  return (a & desired_bits);
}
}
__inline static isaac_word ind(isaac_word const   *m , isaac_word x ) 
{ isaac_word tmp ;

  {
  if (sizeof(*m) * 8UL == (unsigned long )(1 << 6)) {
    tmp = *((isaac_word *)((char *)m + (x & (unsigned long )((1 << 8) - 1) * sizeof(*m))));
  } else {
    tmp = (isaac_word )*(m + (x / (isaac_word )((1 << 6) / 8) & (unsigned long )((1 << 8) - 1)));
  }
  return (tmp);
}
}
void isaac_refill(struct isaac_state *s , isaac_word *result ) 
{ isaac_word a ;
  isaac_word b ;
  isaac_word *m ;
  isaac_word *r ;
  isaac_word x ;
  isaac_word y ;
  isaac_word tmp ;
  isaac_word tmp___0 ;
  isaac_word tmp___1 ;
  isaac_word tmp___2 ;
  isaac_word x___0 ;
  isaac_word y___0 ;
  isaac_word tmp___3 ;
  isaac_word tmp___4 ;
  isaac_word tmp___5 ;
  isaac_word tmp___6 ;
  isaac_word tmp___7 ;
  isaac_word tmp___8 ;
  isaac_word x___1 ;
  isaac_word y___1 ;
  isaac_word tmp___9 ;
  isaac_word tmp___10 ;
  isaac_word tmp___11 ;
  isaac_word tmp___12 ;
  isaac_word x___2 ;
  isaac_word y___2 ;
  isaac_word tmp___13 ;
  isaac_word tmp___14 ;
  isaac_word tmp___15 ;
  isaac_word tmp___16 ;
  isaac_word tmp___17 ;
  isaac_word tmp___18 ;
  isaac_word x___3 ;
  isaac_word y___3 ;
  isaac_word tmp___19 ;
  isaac_word tmp___20 ;
  isaac_word tmp___21 ;
  isaac_word tmp___22 ;
  isaac_word x___4 ;
  isaac_word y___4 ;
  isaac_word tmp___23 ;
  isaac_word tmp___24 ;
  isaac_word tmp___25 ;
  isaac_word tmp___26 ;
  isaac_word tmp___27 ;
  isaac_word tmp___28 ;
  isaac_word x___5 ;
  isaac_word y___5 ;
  isaac_word tmp___29 ;
  isaac_word tmp___30 ;
  isaac_word tmp___31 ;
  isaac_word tmp___32 ;
  isaac_word x___6 ;
  isaac_word y___6 ;
  isaac_word tmp___33 ;
  isaac_word tmp___34 ;
  isaac_word tmp___35 ;
  isaac_word tmp___36 ;
  isaac_word tmp___37 ;
  isaac_word tmp___38 ;

  {
  a = s->a;
  (s->c) ++;
  b = s->b + s->c;
  m = s->m;
  r = result;
  while (1) {
    if (1 << 6 == 32) {
      tmp = a;
    } else {
      tmp = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___0 = a << 13;
    } else {
      tmp___0 = ~ (a ^ (a << 21));
    }
    a = (tmp ^ tmp___0) + *(m + 128);
    x = *(m + 0);
    tmp___1 = ind((isaac_word const   *)(s->m), x);
    y = (tmp___1 + a) + b;
    *(m + 0) = y;
    tmp___2 = ind((isaac_word const   *)(s->m), y >> 8);
    b = just(tmp___2 + x);
    *(r + 0) = b;
    if (1 << 6 == 32) {
      tmp___3 = a;
    } else {
      tmp___3 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___4 = just(a);
      tmp___6 = tmp___4 >> 6;
    } else {
      tmp___5 = just(a);
      tmp___6 = a ^ (tmp___5 >> 5);
    }
    a = (tmp___3 ^ tmp___6) + *(m + 129);
    x___0 = *(m + 1);
    tmp___7 = ind((isaac_word const   *)(s->m), x___0);
    y___0 = (tmp___7 + a) + b;
    *(m + 1) = y___0;
    tmp___8 = ind((isaac_word const   *)(s->m), y___0 >> 8);
    b = just(tmp___8 + x___0);
    *(r + 1) = b;
    if (1 << 6 == 32) {
      tmp___9 = a;
    } else {
      tmp___9 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___10 = a << 2;
    } else {
      tmp___10 = a ^ (a << 12);
    }
    a = (tmp___9 ^ tmp___10) + *(m + 130);
    x___1 = *(m + 2);
    tmp___11 = ind((isaac_word const   *)(s->m), x___1);
    y___1 = (tmp___11 + a) + b;
    *(m + 2) = y___1;
    tmp___12 = ind((isaac_word const   *)(s->m), y___1 >> 8);
    b = just(tmp___12 + x___1);
    *(r + 2) = b;
    if (1 << 6 == 32) {
      tmp___13 = a;
    } else {
      tmp___13 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___14 = just(a);
      tmp___16 = tmp___14 >> 16;
    } else {
      tmp___15 = just(a);
      tmp___16 = a ^ (tmp___15 >> 33);
    }
    a = (tmp___13 ^ tmp___16) + *(m + 131);
    x___2 = *(m + 3);
    tmp___17 = ind((isaac_word const   *)(s->m), x___2);
    y___2 = (tmp___17 + a) + b;
    *(m + 3) = y___2;
    tmp___18 = ind((isaac_word const   *)(s->m), y___2 >> 8);
    b = just(tmp___18 + x___2);
    *(r + 3) = b;
    r += 4;
    m += 4;
    if (! ((unsigned long )m < (unsigned long )(s->m + 128))) {
      break;
    }
  }
  while (1) {
    if (1 << 6 == 32) {
      tmp___19 = a;
    } else {
      tmp___19 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___20 = a << 13;
    } else {
      tmp___20 = ~ (a ^ (a << 21));
    }
    a = (tmp___19 ^ tmp___20) + *(m + -128);
    x___3 = *(m + 0);
    tmp___21 = ind((isaac_word const   *)(s->m), x___3);
    y___3 = (tmp___21 + a) + b;
    *(m + 0) = y___3;
    tmp___22 = ind((isaac_word const   *)(s->m), y___3 >> 8);
    b = just(tmp___22 + x___3);
    *(r + 0) = b;
    if (1 << 6 == 32) {
      tmp___23 = a;
    } else {
      tmp___23 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___24 = just(a);
      tmp___26 = tmp___24 >> 6;
    } else {
      tmp___25 = just(a);
      tmp___26 = a ^ (tmp___25 >> 5);
    }
    a = (tmp___23 ^ tmp___26) + *(m + -127);
    x___4 = *(m + 1);
    tmp___27 = ind((isaac_word const   *)(s->m), x___4);
    y___4 = (tmp___27 + a) + b;
    *(m + 1) = y___4;
    tmp___28 = ind((isaac_word const   *)(s->m), y___4 >> 8);
    b = just(tmp___28 + x___4);
    *(r + 1) = b;
    if (1 << 6 == 32) {
      tmp___29 = a;
    } else {
      tmp___29 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___30 = a << 2;
    } else {
      tmp___30 = a ^ (a << 12);
    }
    a = (tmp___29 ^ tmp___30) + *(m + -126);
    x___5 = *(m + 2);
    tmp___31 = ind((isaac_word const   *)(s->m), x___5);
    y___5 = (tmp___31 + a) + b;
    *(m + 2) = y___5;
    tmp___32 = ind((isaac_word const   *)(s->m), y___5 >> 8);
    b = just(tmp___32 + x___5);
    *(r + 2) = b;
    if (1 << 6 == 32) {
      tmp___33 = a;
    } else {
      tmp___33 = (isaac_word )0;
    }
    if (1 << 6 == 32) {
      tmp___34 = just(a);
      tmp___36 = tmp___34 >> 16;
    } else {
      tmp___35 = just(a);
      tmp___36 = a ^ (tmp___35 >> 33);
    }
    a = (tmp___33 ^ tmp___36) + *(m + -125);
    x___6 = *(m + 3);
    tmp___37 = ind((isaac_word const   *)(s->m), x___6);
    y___6 = (tmp___37 + a) + b;
    *(m + 3) = y___6;
    tmp___38 = ind((isaac_word const   *)(s->m), y___6 >> 8);
    b = just(tmp___38 + x___6);
    *(r + 3) = b;
    r += 4;
    m += 4;
    if (! ((unsigned long )m < (unsigned long )(s->m + (1 << 8)))) {
      break;
    }
  }
  s->a = a;
  s->b = b;
  return;
}
}
void isaac_seed(struct isaac_state *s ) 
{ isaac_word a ;
  unsigned long tmp ;
  isaac_word b ;
  unsigned long tmp___0 ;
  isaac_word c ;
  unsigned long tmp___1 ;
  isaac_word d ;
  unsigned long tmp___2 ;
  isaac_word e ;
  unsigned long tmp___3 ;
  isaac_word f ;
  unsigned long tmp___4 ;
  isaac_word g ;
  unsigned long tmp___5 ;
  isaac_word h ;
  unsigned long tmp___6 ;
  int i ;
  isaac_word tmp___7 ;
  isaac_word tmp___8 ;
  isaac_word tmp___9 ;
  isaac_word tmp___10 ;
  int i___0 ;
  isaac_word tmp___11 ;
  isaac_word tmp___12 ;
  isaac_word tmp___13 ;
  isaac_word tmp___14 ;
  isaac_word tmp___15 ;
  isaac_word tmp___16 ;

  {
  if (1 << 6 == 32) {
    tmp = 325574490UL;
  } else {
    tmp = 7240739780546808700UL;
  }
  a = tmp;
  if (1 << 6 == 32) {
    tmp___0 = 2514026585UL;
  } else {
    tmp___0 = 0xb9f8b322c73ac862UL;
  }
  b = tmp___0;
  if (1 << 6 == 32) {
    tmp___1 = 3273014859UL;
  } else {
    tmp___1 = 0x8c0ea5053d4712a0UL;
  }
  c = tmp___1;
  if (1 << 6 == 32) {
    tmp___2 = 255990488UL;
  } else {
    tmp___2 = 0xb29b2e824a595524UL;
  }
  d = tmp___2;
  if (1 << 6 == 32) {
    tmp___3 = 3643427448UL;
  } else {
    tmp___3 = 0x82f053db8355e0ceUL;
  }
  e = tmp___3;
  if (1 << 6 == 32) {
    tmp___4 = 2769960009UL;
  } else {
    tmp___4 = 5259722845879046933UL;
  }
  f = tmp___4;
  if (1 << 6 == 32) {
    tmp___5 = 3304057371UL;
  } else {
    tmp___5 = 0xae985bf2cbfc89edUL;
  }
  g = tmp___5;
  if (1 << 6 == 32) {
    tmp___6 = 811634969UL;
  } else {
    tmp___6 = 0x98f5704f6c44c0abUL;
  }
  h = tmp___6;
  i = 0;
  while (i < 1 << 8) {
    a += s->m[i];
    b += s->m[i + 1];
    c += s->m[i + 2];
    d += s->m[i + 3];
    e += s->m[i + 4];
    f += s->m[i + 5];
    g += s->m[i + 6];
    h += s->m[i + 7];
    a -= e;
    tmp___7 = just(h);
    f ^= tmp___7 >> 9;
    h += a;
    b -= f;
    g ^= a << 9;
    a += b;
    c -= g;
    tmp___8 = just(b);
    h ^= tmp___8 >> 23;
    b += c;
    d -= h;
    a ^= c << 15;
    c += d;
    e -= a;
    tmp___9 = just(d);
    b ^= tmp___9 >> 14;
    d += e;
    f -= b;
    c ^= e << 20;
    e += f;
    g -= c;
    tmp___10 = just(f);
    d ^= tmp___10 >> 17;
    f += g;
    h -= d;
    e ^= g << 14;
    g += h;
    s->m[i] = a;
    s->m[i + 1] = b;
    s->m[i + 2] = c;
    s->m[i + 3] = d;
    s->m[i + 4] = e;
    s->m[i + 5] = f;
    s->m[i + 6] = g;
    s->m[i + 7] = h;
    i += 8;
  }
  i___0 = 0;
  while (i___0 < 1 << 8) {
    a += s->m[i___0];
    b += s->m[i___0 + 1];
    c += s->m[i___0 + 2];
    d += s->m[i___0 + 3];
    e += s->m[i___0 + 4];
    f += s->m[i___0 + 5];
    g += s->m[i___0 + 6];
    h += s->m[i___0 + 7];
    a -= e;
    tmp___11 = just(h);
    f ^= tmp___11 >> 9;
    h += a;
    b -= f;
    g ^= a << 9;
    a += b;
    c -= g;
    tmp___12 = just(b);
    h ^= tmp___12 >> 23;
    b += c;
    d -= h;
    a ^= c << 15;
    c += d;
    e -= a;
    tmp___13 = just(d);
    b ^= tmp___13 >> 14;
    d += e;
    f -= b;
    c ^= e << 20;
    e += f;
    g -= c;
    tmp___14 = just(f);
    d ^= tmp___14 >> 17;
    f += g;
    h -= d;
    e ^= g << 14;
    g += h;
    s->m[i___0] = a;
    s->m[i___0 + 1] = b;
    s->m[i___0 + 2] = c;
    s->m[i___0 + 3] = d;
    s->m[i___0 + 4] = e;
    s->m[i___0 + 5] = f;
    s->m[i___0 + 6] = g;
    s->m[i___0 + 7] = h;
    i___0 += 8;
  }
  tmp___16 = (isaac_word )0;
  s->c = tmp___16;
  tmp___15 = tmp___16;
  s->b = tmp___15;
  s->a = tmp___15;
  return;
}
}
extern __off_t ftello(FILE *__stream )  __attribute__((__warn_unused_result__)) ;
char *fread_file(FILE *stream , size_t *length ) ;
char *read_file(char const   *filename , size_t *length ) ;
char *read_binary_file(char const   *filename , size_t *length ) ;
char *fread_file(FILE *stream , size_t *length ) 
{ char *buf___1 ;
  size_t alloc ;
  struct stat st ;
  off_t pos ;
  __off_t tmp ;
  off_t alloc_off ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t size ;
  int save_errno ;
  size_t requested ;
  size_t count ;
  size_t __attribute__((__artificial__))  tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *smaller_buf ;
  void *tmp___7 ;
  char *new_buf ;
  int *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  size_t __attribute__((__artificial__))  tmp___11 ;

  {
  buf___1 = (char *)((void *)0);
  alloc = (size_t )8192;
  tmp___1 = fileno(stream);
  tmp___2 = fstat(tmp___1, & st);
  if (tmp___2 >= 0) {
    if ((st.st_mode & 61440U) == 32768U) {
      tmp = ftello(stream);
      pos = tmp;
      if (pos >= 0L) {
        if (pos < st.st_size) {
          alloc_off = st.st_size - pos;
          if (0xfffffffffffffffeUL < (unsigned long )alloc_off) {
            tmp___0 = __errno_location();
            *tmp___0 = 12;
            return ((char *)((void *)0));
          }
          alloc = (size_t )(alloc_off + 1L);
        }
      }
    }
  }
  tmp___3 = malloc(alloc);
  buf___1 = (char *)tmp___3;
  if (! buf___1) {
    return ((char *)((void *)0));
  }
  size = (size_t )0;
  while (1) {
    requested = alloc - size;
    tmp___11 = (size_t __attribute__((__artificial__))  )fread((void * __restrict  )(buf___1 + size),
                                                               (size_t )1, requested,
                                                               (FILE * __restrict  )stream);
    tmp___4 = tmp___11;
    count = (size_t )tmp___4;
    size += count;
    if (count != requested) {
      tmp___5 = __errno_location();
      save_errno = *tmp___5;
      tmp___6 = ferror(stream);
      if (tmp___6) {
        break;
      }
      if (size < alloc - 1UL) {
        tmp___7 = realloc((void *)buf___1, size + 1UL);
        smaller_buf = (char *)tmp___7;
        if ((unsigned long )smaller_buf != (unsigned long )((void *)0)) {
          buf___1 = smaller_buf;
        }
      }
      *(buf___1 + size) = (char )'\000';
      *length = size;
      return (buf___1);
    }
    if (alloc == 0xffffffffffffffffUL) {
      save_errno = 12;
      break;
    }
    if (alloc < 0xffffffffffffffffUL - alloc / 2UL) {
      alloc += alloc / 2UL;
    } else {
      alloc = 0xffffffffffffffffUL;
    }
    tmp___9 = realloc((void *)buf___1, alloc);
    new_buf = (char *)tmp___9;
    if (! new_buf) {
      tmp___8 = __errno_location();
      save_errno = *tmp___8;
      break;
    }
    buf___1 = new_buf;
  }
  free((void *)buf___1);
  tmp___10 = __errno_location();
  *tmp___10 = save_errno;
  return ((char *)((void *)0));
}
}
static char *internal_read_file(char const   *filename , size_t *length , char const   *mode ) 
{ FILE *stream ;
  FILE *tmp ;
  char *out ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )mode);
  stream = tmp;
  if (! stream) {
    return ((char *)((void *)0));
  }
  out = fread_file(stream, length);
  tmp___0 = __errno_location();
  save_errno = *tmp___0;
  tmp___3 = rpl_fclose(stream);
  if (tmp___3 != 0) {
    if (out) {
      tmp___1 = __errno_location();
      save_errno = *tmp___1;
      free((void *)out);
    }
    tmp___2 = __errno_location();
    *tmp___2 = save_errno;
    return ((char *)((void *)0));
  }
  return (out);
}
}
char *read_file(char const   *filename , size_t *length ) 
{ char *tmp ;

  {
  tmp = internal_read_file(filename, length, "r");
  return (tmp);
}
}
char *read_binary_file(char const   *filename , size_t *length ) 
{ char *tmp ;

  {
  tmp = internal_read_file(filename, length, "rb");
  return (tmp);
}
}
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
void init_tokenbuffer(token_buffer *tokenbuffer ) 
{ 

  {
  tokenbuffer->size = (size_t )0;
  tokenbuffer->buffer = (char *)((void *)0);
  return;
}
}
static char const   *saved_delim  =    (char const   *)((void *)0);
static char isdelim[256]  ;
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) 
{ char *p ;
  int c ;
  size_t i ;
  size_t n ;
  _Bool same_delimiters ;
  size_t j ;
  unsigned char ch ;
  void *tmp ;
  size_t tmp___0 ;

  {
  if ((unsigned long )delim == (unsigned long )((void *)0)) {
    if ((unsigned long )saved_delim == (unsigned long )((void *)0)) {
      abort();
    }
  }
  same_delimiters = (_Bool)0;
  if ((unsigned long )delim != (unsigned long )saved_delim) {
    if ((unsigned long )saved_delim != (unsigned long )((void *)0)) {
      same_delimiters = (_Bool)1;
      i = (size_t )0;
      while (i < n_delim) {
        if ((int const   )*(delim + i) != (int const   )*(saved_delim + i)) {
          same_delimiters = (_Bool)0;
          break;
        }
        i ++;
      }
    }
  }
  if (! same_delimiters) {
    saved_delim = delim;
    memset((void *)(isdelim), 0, sizeof(isdelim));
    j = (size_t )0;
    while (j < n_delim) {
      ch = (unsigned char )*(delim + j);
      isdelim[ch] = (char)1;
      j ++;
    }
  }
  c = getc_unlocked(stream);
  while (1) {
    if (c >= 0) {
      if (! isdelim[c]) {
        break;
      }
    } else {
      break;
    }
    c = getc_unlocked(stream);
  }
  p = tokenbuffer->buffer;
  n = tokenbuffer->size;
  i = (size_t )0;
  while (1) {
    if (c < 0) {
      if (i == 0UL) {
        return ((size_t )-1);
      }
    }
    if (i == n) {
      tmp = x2nrealloc((void *)p, & n, sizeof(*p));
      p = (char *)tmp;
    }
    if (c < 0) {
      *(p + i) = (char)0;
      break;
    }
    if (isdelim[c]) {
      *(p + i) = (char)0;
      break;
    }
    tmp___0 = i;
    i ++;
    *(p + tmp___0) = (char )c;
    c = getc_unlocked(stream);
  }
  tokenbuffer->buffer = p;
  tokenbuffer->size = n;
  return (i);
}
}
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) 
{ token_buffer tb ;
  token_buffer *token ;
  char **tokens ;
  size_t *lengths ;
  size_t sz ;
  size_t n_tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t token_length ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void __attribute__((__artificial__))  *tmp___6 ;

  {
  token = & tb;
  if (projected_n_tokens == 0UL) {
    projected_n_tokens = (size_t )64;
  } else {
    projected_n_tokens ++;
  }
  sz = projected_n_tokens;
  tmp = xnmalloc(sz, sizeof(*tokens));
  tokens = (char **)tmp;
  tmp___0 = xnmalloc(sz, sizeof(*lengths));
  lengths = (size_t *)tmp___0;
  n_tokens = (size_t )0;
  init_tokenbuffer(token);
  while (1) {
    tmp___2 = readtoken(stream, delim, n_delim, token);
    token_length = tmp___2;
    if (n_tokens >= sz) {
      tmp___3 = x2nrealloc((void *)tokens, & sz, sizeof(*tokens));
      tokens = (char **)tmp___3;
      tmp___4 = xnrealloc((void *)lengths, sz, sizeof(*lengths));
      lengths = (size_t *)tmp___4;
    }
    if (token_length == 0xffffffffffffffffUL) {
      *(tokens + n_tokens) = (char *)((void *)0);
      *(lengths + n_tokens) = (size_t )0;
      break;
    }
    tmp___5 = xnmalloc(token_length + 1UL, sizeof(*tmp___1));
    tmp___1 = (char *)tmp___5;
    *(lengths + n_tokens) = token_length;
    tmp___6 = memcpy((void * __restrict  )tmp___1, (void const   * __restrict  )token->buffer,
                     token_length + 1UL);
    *(tokens + n_tokens) = (char *)tmp___6;
    n_tokens ++;
  }
  free((void *)token->buffer);
  *tokens_out = tokens;
  if ((unsigned long )token_lengths != (unsigned long )((void *)0)) {
    *token_lengths = lengths;
  } else {
    free((void *)lengths);
  }
  return (n_tokens);
}
}
extern void _obstack_newchunk(struct obstack * , int  ) ;
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
extern void obstack_free(struct obstack *obstack , void *block ) ;
void readtokens0_init(struct Tokens *t ) ;
void readtokens0_free(struct Tokens *t ) ;
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
void readtokens0_init(struct Tokens *t ) 
{ 

  {
  t->n_tok = (size_t )0;
  t->tok = (char **)((void *)0);
  t->tok_len = (size_t *)((void *)0);
  _obstack_begin(& t->o_data, 0, 0, (void *(*)(long  ))(& malloc), & free);
  _obstack_begin(& t->o_tok, 0, 0, (void *(*)(long  ))(& malloc), & free);
  _obstack_begin(& t->o_tok_len, 0, 0, (void *(*)(long  ))(& malloc), & free);
  return;
}
}
void readtokens0_free(struct Tokens *t ) 
{ struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *tmp___1 ;

  {
  __o = & t->o_data;
  __obj = (void *)0;
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
      tmp = (char *)__obj;
      __o->object_base = tmp;
      __o->next_free = tmp;
    } else {
      obstack_free(__o, __obj);
    }
  } else {
    obstack_free(__o, __obj);
  }
  __o___0 = & t->o_tok;
  __obj___0 = (void *)0;
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
      tmp___0 = (char *)__obj___0;
      __o___0->object_base = tmp___0;
      __o___0->next_free = tmp___0;
    } else {
      obstack_free(__o___0, __obj___0);
    }
  } else {
    obstack_free(__o___0, __obj___0);
  }
  __o___1 = & t->o_tok_len;
  __obj___1 = (void *)0;
  if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___1->chunk)) {
    if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___1->chunk_limit)) {
      tmp___1 = (char *)__obj___1;
      __o___1->object_base = tmp___1;
      __o___1->next_free = tmp___1;
    } else {
      obstack_free(__o___1, __obj___1);
    }
  } else {
    obstack_free(__o___1, __obj___1);
  }
  return;
}
}
static void save_token(struct Tokens *t ) 
{ size_t len ;
  struct obstack  const  *__o ;
  char const   *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;

  {
  __o = (struct obstack  const  *)(& t->o_data);
  len = (size_t )((unsigned int )(__o->next_free - __o->object_base) - 1U);
  __o1 = & t->o_data;
  __value = (void *)__o1->object_base;
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
    __o1->maybe_empty_object = 1U;
  }
  if (sizeof(long ) < sizeof(void *)) {
    tmp = __o1->object_base;
  } else {
    tmp = (char *)0;
  }
  if (sizeof(long ) < sizeof(void *)) {
    tmp___0 = __o1->object_base;
  } else {
    tmp___0 = (char *)0;
  }
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + __o1->alignment_mask) & ~ __o1->alignment_mask);
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
    __o1->next_free = __o1->chunk_limit;
  }
  __o1->object_base = __o1->next_free;
  s = (char const   *)__value;
  __o___0 = & t->o_tok;
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
    _obstack_newchunk(__o___0, (int )sizeof(void *));
  }
  __o1___0 = __o___0;
  *((void const   **)__o1___0->next_free) = (void const   *)s;
  __o1___0->next_free += sizeof(void const   *);
  __o___1 = & t->o_tok_len;
  __len = (int )sizeof(len);
  if ((unsigned long )(__o___1->next_free + __len) > (unsigned long )__o___1->chunk_limit) {
    _obstack_newchunk(__o___1, __len);
  }
  memcpy((void * __restrict  )__o___1->next_free, (void const   * __restrict  )(& len),
         (size_t )__len);
  __o___1->next_free += __len;
  (t->n_tok) ++;
  return;
}
}
_Bool readtokens0(FILE *in , struct Tokens *t ) 
{ int c ;
  int tmp ;
  size_t len ;
  struct obstack  const  *__o ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  struct obstack *__o___2 ;
  struct obstack *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o1___1 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  while (1) {
    tmp = fgetc(in);
    c = tmp;
    if (c == -1) {
      __o = (struct obstack  const  *)(& t->o_data);
      len = (size_t )((unsigned int )(__o->next_free - __o->object_base));
      if (len) {
        __o___0 = & t->o_data;
        if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
          _obstack_newchunk(__o___0, 1);
        }
        tmp___0 = __o___0->next_free;
        (__o___0->next_free) ++;
        *tmp___0 = (char )'\000';
        save_token(t);
      }
      break;
    }
    __o___1 = & t->o_data;
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      _obstack_newchunk(__o___1, 1);
    }
    tmp___1 = __o___1->next_free;
    (__o___1->next_free) ++;
    *tmp___1 = (char )c;
    if (c == 0) {
      save_token(t);
    }
  }
  __o___2 = & t->o_tok;
  if ((unsigned long )(__o___2->next_free + sizeof(void *)) > (unsigned long )__o___2->chunk_limit) {
    _obstack_newchunk(__o___2, (int )sizeof(void *));
  }
  __o1 = __o___2;
  *((void const   **)__o1->next_free) = (void const   *)((void *)0);
  __o1->next_free += sizeof(void const   *);
  __o1___0 = & t->o_tok;
  __value = (void *)__o1___0->object_base;
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
    __o1___0->maybe_empty_object = 1U;
  }
  if (sizeof(long ) < sizeof(void *)) {
    tmp___2 = __o1___0->object_base;
  } else {
    tmp___2 = (char *)0;
  }
  if (sizeof(long ) < sizeof(void *)) {
    tmp___3 = __o1___0->object_base;
  } else {
    tmp___3 = (char *)0;
  }
  __o1___0->next_free = tmp___2 + (((__o1___0->next_free - tmp___3) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
    __o1___0->next_free = __o1___0->chunk_limit;
  }
  __o1___0->object_base = __o1___0->next_free;
  t->tok = (char **)__value;
  __o1___1 = & t->o_tok_len;
  __value___0 = (void *)__o1___1->object_base;
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___0) {
    __o1___1->maybe_empty_object = 1U;
  }
  if (sizeof(long ) < sizeof(void *)) {
    tmp___4 = __o1___1->object_base;
  } else {
    tmp___4 = (char *)0;
  }
  if (sizeof(long ) < sizeof(void *)) {
    tmp___5 = __o1___1->object_base;
  } else {
    tmp___5 = (char *)0;
  }
  __o1___1->next_free = tmp___4 + (((__o1___1->next_free - tmp___5) + __o1___1->alignment_mask) & ~ __o1___1->alignment_mask);
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
    __o1___1->next_free = __o1___1->chunk_limit;
  }
  __o1___1->object_base = __o1___1->next_free;
  t->tok_len = (size_t *)__value___0;
  tmp___6 = ferror(in);
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  return ((_Bool )tmp___7);
}
}
size_t safe_read(int fd , void *buf___1 , size_t count ) 
{ ssize_t result ;
  ssize_t __attribute__((__artificial__))  tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  ssize_t __attribute__((__artificial__))  tmp___2 ;

  {
  while (1) {
    tmp___2 = (ssize_t __attribute__((__artificial__))  )read(fd, buf___1, count);
    tmp = tmp___2;
    result = (ssize_t )tmp;
    if (0L <= result) {
      return ((size_t )result);
    } else {
      tmp___1 = __errno_location();
      if (*tmp___1 == 4) {
        goto __Cont;
      } else {
        tmp___0 = __errno_location();
        if (*tmp___0 == 22) {
          if (2147475456UL < count) {
            count = (size_t )2147475456;
          } else {
            return ((size_t )result);
          }
        } else {
          return ((size_t )result);
        }
      }
    }
    __Cont: ;
  }
}
}
extern ssize_t write(int __fd , void const   *__buf , size_t __n )  __attribute__((__warn_unused_result__)) ;
size_t safe_write(int fd , void const   *buf___1 , size_t count ) 
{ ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  while (1) {
    tmp = write(fd, buf___1, count);
    result = tmp;
    if (0L <= result) {
      return ((size_t )result);
    } else {
      tmp___1 = __errno_location();
      if (*tmp___1 == 4) {
        goto __Cont;
      } else {
        tmp___0 = __errno_location();
        if (*tmp___0 == 22) {
          if (2147475456UL < count) {
            count = (size_t )2147475456;
          } else {
            return ((size_t )result);
          }
        } else {
          return ((size_t )result);
        }
      }
    }
    __Cont: ;
  }
}
}
_Bool same_name(char const   *source , char const   *dest ) 
{ char const   *source_basename ;
  char *tmp ;
  char const   *dest_basename ;
  char *tmp___0 ;
  size_t source_baselen ;
  size_t tmp___1 ;
  size_t dest_baselen ;
  size_t tmp___2 ;
  _Bool identical_basenames ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool compare_dirs ;
  _Bool same ;
  struct stat source_dir_stats ;
  struct stat dest_dir_stats ;
  char *source_dirname ;
  char *dest_dirname ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = last_component(source);
  source_basename = (char const   *)tmp;
  tmp___0 = last_component(dest);
  dest_basename = (char const   *)tmp___0;
  tmp___1 = base_len(source_basename);
  source_baselen = tmp___1;
  tmp___2 = base_len(dest_basename);
  dest_baselen = tmp___2;
  if (source_baselen == dest_baselen) {
    tmp___3 = memcmp((void const   *)source_basename, (void const   *)dest_basename,
                     dest_baselen);
    if (tmp___3 == 0) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  identical_basenames = (_Bool )tmp___4;
  compare_dirs = identical_basenames;
  same = (_Bool)0;
  if (compare_dirs) {
    source_dirname = dir_name(source);
    dest_dirname = dir_name(dest);
    tmp___6 = stat((char const   * __restrict  )source_dirname, (struct stat * __restrict  )(& source_dir_stats));
    if (tmp___6) {
      tmp___5 = __errno_location();
      error(1, *tmp___5, "%s", source_dirname);
    }
    tmp___8 = stat((char const   * __restrict  )dest_dirname, (struct stat * __restrict  )(& dest_dir_stats));
    if (tmp___8) {
      tmp___7 = __errno_location();
      error(1, *tmp___7, "%s", dest_dirname);
    }
    if (source_dir_stats.st_ino == dest_dir_stats.st_ino) {
      if (source_dir_stats.st_dev == dest_dir_stats.st_dev) {
        tmp___9 = 1;
      } else {
        tmp___9 = 0;
      }
    } else {
      tmp___9 = 0;
    }
    same = (_Bool )tmp___9;
    free((void *)source_dirname);
    free((void *)dest_dirname);
  }
  return (same);
}
}
int save_cwd(struct saved_cwd *cwd ) ;
int restore_cwd(struct saved_cwd  const  *cwd ) ;
void free_cwd(struct saved_cwd *cwd ) ;
extern  __attribute__((__nothrow__)) int fchdir(int __fd )  __attribute__((__warn_unused_result__)) ;
char *rpl_getcwd(char *buf___1 , size_t size ) ;
int chdir_long(char *dir ) ;
int save_cwd(struct saved_cwd *cwd ) 
{ int tmp ;

  {
  cwd->name = (char *)((void *)0);
  cwd->desc = open_safer(".", 0);
  if (cwd->desc < 0) {
    cwd->name = rpl_getcwd((char *)((void *)0), (size_t )0);
    if (cwd->name) {
      tmp = 0;
    } else {
      tmp = -1;
    }
    return (tmp);
  }
  set_cloexec_flag(cwd->desc, (_Bool)1);
  return (0);
}
}
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (0 <= (int )cwd->desc) {
    tmp = fchdir((int )cwd->desc);
    return (tmp);
  } else {
    tmp___0 = chdir_long((char *)cwd->name);
    return (tmp___0);
  }
}
}
void free_cwd(struct saved_cwd *cwd ) 
{ 

  {
  if (cwd->desc >= 0) {
    close(cwd->desc);
  }
  free((void *)cwd->name);
  return;
}
}
char *streamsavedir(DIR *dirp ) ;
char *savedir(char const   *dir ) ;
char *fdsavedir(int fd ) ;
char *streamsavedir(DIR *dirp ) 
{ char *name_space ;
  size_t allocated ;
  size_t used ;
  int save_errno ;
  void *tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
  allocated = (size_t )512;
  used = (size_t )0;
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = xmalloc(allocated);
  name_space = (char *)tmp;
  while (1) {
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    tmp___1 = readdir(dirp);
    dp = (struct dirent  const  *)tmp___1;
    if (! dp) {
      break;
    }
    entry = (char const   *)(dp->d_name);
    if ((int const   )*(entry + 0) != 46) {
      tmp___5 = 0;
    } else {
      if ((int const   )*(entry + 1) != 46) {
        tmp___4 = 1;
      } else {
        tmp___4 = 2;
      }
      tmp___5 = tmp___4;
    }
    if ((int const   )*(entry + tmp___5) != 0) {
      tmp___2 = strlen((char const   *)(dp->d_name));
      entry_size = tmp___2 + 1UL;
      if (used + entry_size < used) {
        xalloc_die();
      }
      if (allocated <= used + entry_size) {
        while (1) {
          if (2UL * allocated < allocated) {
            xalloc_die();
          }
          allocated *= 2UL;
          if (! (allocated <= used + entry_size)) {
            break;
          }
        }
        tmp___3 = xrealloc((void *)name_space, allocated);
        name_space = (char *)tmp___3;
      }
      memcpy((void * __restrict  )(name_space + used), (void const   * __restrict  )entry,
             entry_size);
      used += entry_size;
    }
  }
  *(name_space + used) = (char )'\000';
  tmp___6 = __errno_location();
  save_errno = *tmp___6;
  if (save_errno != 0) {
    free((void *)name_space);
    tmp___7 = __errno_location();
    *tmp___7 = save_errno;
    return ((char *)((void *)0));
  }
  return (name_space);
}
}
static char *savedirstream(DIR *dirp ) 
{ char *name_space ;
  char *tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp = streamsavedir(dirp);
  name_space = tmp;
  if (dirp) {
    tmp___2 = closedir(dirp);
    if (tmp___2 != 0) {
      tmp___0 = __errno_location();
      save_errno = *tmp___0;
      free((void *)name_space);
      tmp___1 = __errno_location();
      *tmp___1 = save_errno;
      return ((char *)((void *)0));
    }
  }
  return (name_space);
}
}
char *savedir(char const   *dir ) 
{ DIR *tmp ;
  char *tmp___0 ;

  {
  tmp = opendir_safer(dir);
  tmp___0 = savedirstream(tmp);
  return (tmp___0);
}
}
char *fdsavedir(int fd ) 
{ DIR *tmp ;
  char *tmp___0 ;

  {
  tmp = fdopendir(fd);
  tmp___0 = savedirstream(tmp);
  return (tmp___0);
}
}
__inline static void savewd_init(struct savewd *wd ) 
{ 

  {
  wd->state = (enum __anonenum_state_18 )0;
  return;
}
}
int savewd_restore(struct savewd *wd , int status ) ;
void savewd_finish(struct savewd *wd ) ;
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
  if (__set->__val[__word] & __mask) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
  __set->__val[__word] |= __mask;
  return (0);
}
}
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
  __set->__val[__word] &= ~ __mask;
  return (0);
}
}
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
static _Bool savewd_save(struct savewd *wd ) 
{ int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  switch ((int )wd->state) {
  case 0: 
  tmp = open_safer(".", 0);
  fd = tmp;
  if (0 <= fd) {
    wd->state = (enum __anonenum_state_18 )1;
    wd->val.fd = fd;
    break;
  }
  tmp___1 = __errno_location();
  if (*tmp___1 != 13) {
    tmp___2 = __errno_location();
    if (*tmp___2 != 116) {
      wd->state = (enum __anonenum_state_18 )4;
      tmp___0 = __errno_location();
      wd->val.errnum = *tmp___0;
      break;
    }
  }
  wd->state = (enum __anonenum_state_18 )3;
  wd->val.child = -1;
  case 3: 
  if (wd->val.child < 0) {
    wd->val.child = fork();
    if (wd->val.child != 0) {
      if (0 < wd->val.child) {
        return ((_Bool)1);
      }
      wd->state = (enum __anonenum_state_18 )4;
      tmp___3 = __errno_location();
      wd->val.errnum = *tmp___3;
    }
  }
  break;
  case 1: 
  case 2: 
  case 4: 
  case 5: 
  break;
  default: 
  __assert_fail("0", "savewd.c", 89U, "savewd_save");
  }
  return ((_Bool)0);
}
}
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) 
{ int fd ;
  int result ;
  int tmp ;
  int __attribute__((__artificial__))  tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int e ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
  fd = -1;
  result = 0;
  if (open_result) {
    goto _L;
  } else
  if (options & 1) {
    _L: 
    if (options & 1) {
      tmp = 131072;
    } else {
      tmp = 0;
    }
    tmp___0 = open(dir, 67840 | tmp);
    fd = (int )tmp___0;
    if (open_result) {
      *(open_result + 0) = fd;
      tmp___1 = __errno_location();
      *(open_result + 1) = *tmp___1;
    }
    if (fd < 0) {
      tmp___2 = __errno_location();
      if (*tmp___2 != 13) {
        result = -1;
      } else
      if (options & 2) {
        result = -1;
      }
    }
  }
  if (result == 0) {
    if (0 <= fd) {
      if (! (options & 4)) {
        goto _L___0;
      }
    } else {
      _L___0: 
      tmp___5 = savewd_save(wd);
      if (tmp___5) {
        open_result = (int *)((void *)0);
        result = -2;
      } else {
        if (fd < 0) {
          tmp___3 = chdir(dir);
          result = tmp___3;
        } else {
          tmp___4 = fchdir(fd);
          result = tmp___4;
        }
        if (result == 0) {
          switch ((int )wd->state) {
          case 1: 
          wd->state = (enum __anonenum_state_18 )2;
          break;
          case 4: 
          case 2: 
          case 5: 
          break;
          case 3: 
          if (! (wd->val.child == 0)) {
            __assert_fail("wd->val.child == 0", "savewd.c", 145U, "savewd_chdir");
          }
          break;
          default: 
          __assert_fail("0", "savewd.c", 149U, "savewd_chdir");
          }
        }
      }
    }
  }
  if (0 <= fd) {
    if (! open_result) {
      tmp___6 = __errno_location();
      e = *tmp___6;
      close(fd);
      tmp___7 = __errno_location();
      *tmp___7 = e;
    }
  }
  return (result);
}
}
int savewd_restore(struct savewd *wd , int status ) 
{ int chdir_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  pid_t child ;
  int child_status ;
  int *tmp___2 ;
  __pid_t tmp___3 ;
  union __anonunion_50 __constr_expr_0 ;
  union __anonunion_51 __constr_expr_1 ;
  union __anonunion_52 __constr_expr_2 ;

  {
  switch ((int )wd->state) {
  case 0: 
  case 1: 
  break;
  case 2: 
  tmp___0 = fchdir(wd->val.fd);
  if (tmp___0 == 0) {
    wd->state = (enum __anonenum_state_18 )1;
    break;
  } else {
    tmp = __errno_location();
    chdir_errno = *tmp;
    close(wd->val.fd);
    wd->state = (enum __anonenum_state_18 )4;
    wd->val.errnum = chdir_errno;
  }
  case 4: 
  tmp___1 = __errno_location();
  *tmp___1 = wd->val.errnum;
  return (-1);
  case 3: 
  child = wd->val.child;
  if (child == 0) {
    _exit(status);
  }
  if (0 < child) {
    while (1) {
      tmp___3 = waitpid(child, & child_status, 0);
      if (! (tmp___3 < 0)) {
        break;
      }
      tmp___2 = __errno_location();
      if (! (*tmp___2 == 4)) {
        __assert_fail("(*__errno_location ()) == 4", "savewd.c", 206U, "savewd_restore");
      }
    }
    wd->val.child = -1;
    __constr_expr_1.__in = child_status;
    if (! ((__constr_expr_1.__i & 127) == 0)) {
      __constr_expr_0.__in = child_status;
      raise(__constr_expr_0.__i & 127);
    }
    __constr_expr_2.__in = child_status;
    return ((__constr_expr_2.__i & 65280) >> 8);
  }
  break;
  default: 
  __assert_fail("0", "savewd.c", 216U, "savewd_restore");
  }
  return (0);
}
}
void savewd_finish(struct savewd *wd ) 
{ 

  {
  switch ((int )wd->state) {
  case 0: 
  case 4: 
  break;
  case 1: 
  case 2: 
  close(wd->val.fd);
  break;
  case 3: 
  if (! (wd->val.child < 0)) {
    __assert_fail("wd->val.child < 0", "savewd.c", 237U, "savewd_finish");
  }
  break;
  default: 
  __assert_fail("0", "savewd.c", 241U, "savewd_finish");
  }
  wd->state = (enum __anonenum_state_18 )5;
  return;
}
}
__inline static _Bool savewd_delegating(struct savewd  const  *wd ) 
{ int tmp ;

  {
  if ((unsigned int const   )wd->state == 3U) {
    if (0 < (int )wd->val.child) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) 
{ int i ;
  int last_relative ;
  int exit_status___0 ;
  struct savewd wd ;
  int s ;
  int tmp ;
  _Bool tmp___0 ;
  int r ;
  int tmp___1 ;
  int s___0 ;
  int tmp___2 ;

  {
  i = 0;
  exit_status___0 = 0;
  savewd_init(& wd);
  last_relative = n_files - 1;
  while (0 <= last_relative) {
    if (! ((int )*(*(file + last_relative) + 0) == 47)) {
      break;
    }
    last_relative --;
  }
  while (i < last_relative) {
    tmp___0 = savewd_delegating((struct savewd  const  *)(& wd));
    if (! tmp___0) {
      tmp = (*act)(*(file + i), & wd, options);
      s = tmp;
      if (exit_status___0 < s) {
        exit_status___0 = s;
      }
    }
    if (! ((int )*(*(file + (i + 1)) + 0) == 47)) {
      tmp___1 = savewd_restore(& wd, exit_status___0);
      r = tmp___1;
      if (exit_status___0 < r) {
        exit_status___0 = r;
      }
    }
    i ++;
  }
  savewd_finish(& wd);
  while (i < n_files) {
    tmp___2 = (*act)(*(file + i), & wd, options);
    s___0 = tmp___2;
    if (exit_status___0 < s___0) {
      exit_status___0 = s___0;
    }
    i ++;
  }
  return (exit_status___0);
}
}
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec  const  *__tp ) ;
int settime(struct timespec  const  *ts ) ;
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval  const  *__tv ,
                                                      struct timezone  const  *__tz )  __attribute__((__nonnull__(1))) ;
int settime(struct timespec  const  *ts ) 
{ int r ;
  int tmp ;
  int *tmp___0 ;
  struct timeval tv ;
  int tmp___1 ;

  {
  tmp = clock_settime(0, ts);
  r = tmp;
  if (r == 0) {
    return (r);
  } else {
    tmp___0 = __errno_location();
    if (*tmp___0 == 1) {
      return (r);
    }
  }
  tv.tv_sec = (__time_t )ts->tv_sec;
  tv.tv_usec = (__suseconds_t )(ts->tv_nsec / 1000L);
  tmp___1 = settimeofday((struct timeval  const  *)(& tv), (struct timezone  const  *)0);
  return (tmp___1);
}
}
int gl_sockets_startup(int version  __attribute__((__unused__)) ) ;
int gl_sockets_cleanup(void) ;
int gl_sockets_startup(int version  __attribute__((__unused__)) ) 
{ 

  {
  return (0);
}
}
int gl_sockets_cleanup(void) 
{ 

  {
  return (0);
}
}
int mkstemp_safer(char *templ ) ;
extern int mkstemp(char *__template )  __attribute__((__warn_unused_result__, __nonnull__(1))) ;
int mkstemp_safer(char *templ ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = mkstemp(templ);
  tmp___0 = fd_safer(tmp);
  return (tmp___0);
}
}
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
  while (1) {
    tmp___1 = len;
    len --;
    if (! (tmp___1 > 0UL)) {
      break;
    }
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
      __res = tolower((int )((unsigned char )*(src + len)));
    } else {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
    }
    *(dest + len) = (char )__res;
  }
  return (dest);
}
}
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
  while (1) {
    tmp___1 = len;
    len --;
    if (! (tmp___1 > 0UL)) {
      break;
    }
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
      __res = toupper((int )((unsigned char )*(src + len)));
    } else {
      tmp___0 = __ctype_toupper_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
    }
    *(dest + len) = (char )__res;
  }
  return (dest);
}
}
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                                 struct tm  const  *tp , int ut , int ns ) 
{ int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  int century ;
  int tmp___13 ;
  int tmp___14 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___15 ;
  size_t _incr___3 ;
  size_t tmp___16 ;
  size_t _delta___3 ;
  int padding ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___17 ;
  size_t _incr___4 ;
  size_t tmp___18 ;
  size_t _delta___4 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___19 ;
  size_t _incr___5 ;
  size_t tmp___20 ;
  size_t _delta___5 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___21 ;
  size_t _incr___6 ;
  size_t tmp___22 ;
  size_t _delta___6 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___23 ;
  size_t _incr___7 ;
  size_t tmp___24 ;
  size_t _delta___7 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___25 ;
  size_t _incr___8 ;
  size_t tmp___26 ;
  size_t _delta___8 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___27 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___28 ;
  size_t _incr___9 ;
  size_t tmp___29 ;
  size_t _delta___9 ;
  int year___0 ;
  int tmp___30 ;
  int year_adjust ;
  int days ;
  int tmp___31 ;
  int tmp___32 ;
  int d___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int yy ;
  int tmp___35 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___36 ;
  size_t _w___10 ;
  int tmp___37 ;
  size_t _incr___10 ;
  size_t tmp___38 ;
  size_t _delta___10 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___39 ;
  size_t _incr___11 ;
  size_t tmp___40 ;
  size_t _delta___11 ;

  {
  hour12 = (int )tp->tm_hour;
  i = (size_t )0;
  p = s;
  zone = (char const   *)((void *)0);
  zone = (char const   *)tp->tm_zone;
  if (hour12 > 12) {
    hour12 -= 12;
  } else
  if (hour12 == 0) {
    hour12 = 12;
  }
  f = format;
  while ((int const   )*f != 0) {
    pad = 0;
    digits = 0;
    width = -1;
    to_lowcase = (_Bool)0;
    to_uppcase = upcase;
    change_case = (_Bool)0;
    if ((int const   )*f != 37) {
      while (1) {
        _n = (size_t )1;
        if (width < 0) {
          tmp = 0;
        } else {
          tmp = width;
        }
        _w = (size_t )tmp;
        if (_n < _w) {
          tmp___0 = _w;
        } else {
          tmp___0 = _n;
        }
        _incr = tmp___0;
        if (_incr >= maxsize - i) {
          return ((size_t )0);
        }
        if (p) {
          if (digits == 0) {
            if (_n < _w) {
              _delta = (size_t )width - _n;
              if (pad == 48) {
                memset((void *)p, '0', _delta);
                p += _delta;
              } else {
                memset((void *)p, ' ', _delta);
                p += _delta;
              }
            }
          }
          *p = (char )*f;
          p += _n;
        }
        i += _incr;
        break;
      }
      goto __Cont;
    }
    while (1) {
      f ++;
      switch ((int )*f) {
      case 95: 
      case 45: 
      case 48: 
      pad = (int )*f;
      continue;
      case 94: 
      to_uppcase = (_Bool)1;
      continue;
      case 35: 
      change_case = (_Bool)1;
      continue;
      default: 
      break;
      }
      break;
    }
    if ((unsigned int )*f - 48U <= 9U) {
      width = 0;
      while (1) {
        if (width > 214748364) {
          width = 2147483647;
        } else
        if (width == 214748364) {
          if ((int const   )*f - 48 > 7) {
            width = 2147483647;
          } else {
            width *= 10;
            width += (int )((int const   )*f - 48);
          }
        } else {
          width *= 10;
          width += (int )((int const   )*f - 48);
        }
        f ++;
        if (! ((unsigned int )*f - 48U <= 9U)) {
          break;
        }
      }
    }
    switch ((int )*f) {
    case 69: 
    case 79: 
    tmp___1 = f;
    f ++;
    modifier = (int )*tmp___1;
    break;
    default: 
    modifier = 0;
    break;
    }
    format_char = (int )*f;
    switch (format_char) {
    case 37: 
    if (modifier != 0) {
      goto bad_format;
    }
    while (1) {
      _n___0 = (size_t )1;
      if (width < 0) {
        tmp___2 = 0;
      } else {
        tmp___2 = width;
      }
      _w___0 = (size_t )tmp___2;
      if (_n___0 < _w___0) {
        tmp___3 = _w___0;
      } else {
        tmp___3 = _n___0;
      }
      _incr___0 = tmp___3;
      if (_incr___0 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___0 < _w___0) {
            _delta___0 = (size_t )width - _n___0;
            if (pad == 48) {
              memset((void *)p, '0', _delta___0);
              p += _delta___0;
            } else {
              memset((void *)p, ' ', _delta___0);
              p += _delta___0;
            }
          }
        }
        *p = (char )*f;
        p += _n___0;
      }
      i += _incr___0;
      break;
    }
    break;
    case 97: 
    if (modifier != 0) {
      goto bad_format;
    }
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    goto underlying_strftime;
    case 65: 
    if (modifier != 0) {
      goto bad_format;
    }
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    goto underlying_strftime;
    case 98: 
    case 104: 
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    if (modifier != 0) {
      goto bad_format;
    }
    goto underlying_strftime;
    case 66: 
    if (modifier != 0) {
      goto bad_format;
    }
    if (change_case) {
      to_uppcase = (_Bool)1;
      to_lowcase = (_Bool)0;
    }
    goto underlying_strftime;
    case 99: 
    if (modifier == 79) {
      goto bad_format;
    }
    goto underlying_strftime;
    subformat: 
    tmp___4 = strftime_case____0(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                                 tp, ut, ns);
    len = tmp___4;
    while (1) {
      _n___1 = len;
      if (width < 0) {
        tmp___5 = 0;
      } else {
        tmp___5 = width;
      }
      _w___1 = (size_t )tmp___5;
      if (_n___1 < _w___1) {
        tmp___6 = _w___1;
      } else {
        tmp___6 = _n___1;
      }
      _incr___1 = tmp___6;
      if (_incr___1 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___1 < _w___1) {
            _delta___1 = (size_t )width - _n___1;
            if (pad == 48) {
              memset((void *)p, '0', _delta___1);
              p += _delta___1;
            } else {
              memset((void *)p, ' ', _delta___1);
              p += _delta___1;
            }
          }
        }
        strftime_case____0(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
        p += _n___1;
      }
      i += _incr___1;
      break;
    }
    break;
    underlying_strftime: 
    u = ufmt;
    tmp___7 = u;
    u ++;
    *tmp___7 = (char )' ';
    tmp___8 = u;
    u ++;
    *tmp___8 = (char )'%';
    if (modifier != 0) {
      tmp___9 = u;
      u ++;
      *tmp___9 = (char )modifier;
    }
    tmp___10 = u;
    u ++;
    *tmp___10 = (char )format_char;
    *u = (char )'\000';
    len___0 = strftime((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )(ufmt),
                       (struct tm  const  * __restrict  )tp);
    if (len___0 != 0UL) {
      while (1) {
        _n___2 = len___0 - 1UL;
        if (width < 0) {
          tmp___11 = 0;
        } else {
          tmp___11 = width;
        }
        _w___2 = (size_t )tmp___11;
        if (_n___2 < _w___2) {
          tmp___12 = _w___2;
        } else {
          tmp___12 = _n___2;
        }
        _incr___2 = tmp___12;
        if (_incr___2 >= maxsize - i) {
          return ((size_t )0);
        }
        if (p) {
          if (digits == 0) {
            if (_n___2 < _w___2) {
              _delta___2 = (size_t )width - _n___2;
              if (pad == 48) {
                memset((void *)p, '0', _delta___2);
                p += _delta___2;
              } else {
                memset((void *)p, ' ', _delta___2);
                p += _delta___2;
              }
            }
          }
          if (to_lowcase) {
            memcpy_lowcase(p, (char const   *)(ubuf + 1), _n___2);
          } else
          if (to_uppcase) {
            memcpy_uppcase(p, (char const   *)(ubuf + 1), _n___2);
          } else {
            memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)(ubuf + 1)),
                   _n___2);
          }
          p += _n___2;
        }
        i += _incr___2;
        break;
      }
    }
    break;
    case 67: 
    if (modifier == 79) {
      goto bad_format;
    }
    if (modifier == 69) {
      goto underlying_strftime;
    }
    century = (int )(tp->tm_year / 100 + 19);
    if (tp->tm_year % 100 < 0) {
      if (0 < century) {
        tmp___13 = 1;
      } else {
        tmp___13 = 0;
      }
    } else {
      tmp___13 = 0;
    }
    century -= tmp___13;
    digits = 2;
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )century;
    goto do_signed_number;
    case 120: 
    if (modifier == 79) {
      goto bad_format;
    }
    goto underlying_strftime;
    case 68: 
    if (modifier != 0) {
      goto bad_format;
    }
    subfmt = "%m/%d/%y";
    goto subformat;
    case 100: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_mday;
    goto do_number;
    case 101: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_mday;
    goto do_number_spacepad;
    do_tz_offset: 
    always_output_a_sign = (_Bool)1;
    goto do_number_body;
    do_number_spacepad: 
    if (pad != 48) {
      if (pad != 45) {
        pad = '_';
      }
    }
    do_number: 
    negative_number = (_Bool )(number_value < 0);
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
    always_output_a_sign = (_Bool)0;
    tz_colon_mask = 0;
    do_number_body: 
    if (modifier == 79) {
      if (! negative_number) {
        goto underlying_strftime;
      }
    }
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    if (negative_number) {
      u_number_value = - u_number_value;
    }
    while (1) {
      if (tz_colon_mask & 1) {
        bufp --;
        *bufp = (char )':';
      }
      tz_colon_mask >>= 1;
      bufp --;
      *bufp = (char )(u_number_value % 10U + 48U);
      u_number_value /= 10U;
      if (! (u_number_value != 0U)) {
        if (! (tz_colon_mask != 0)) {
          break;
        }
      }
    }
    do_number_sign_and_padding: 
    if (digits < width) {
      digits = width;
    }
    if (negative_number) {
      sign_char = (char )'-';
    } else {
      if (always_output_a_sign) {
        tmp___14 = '+';
      } else {
        tmp___14 = 0;
      }
      sign_char = (char )tmp___14;
    }
    if (pad == 45) {
      if (sign_char) {
        while (1) {
          _n___3 = (size_t )1;
          if (width < 0) {
            tmp___15 = 0;
          } else {
            tmp___15 = width;
          }
          _w___3 = (size_t )tmp___15;
          if (_n___3 < _w___3) {
            tmp___16 = _w___3;
          } else {
            tmp___16 = _n___3;
          }
          _incr___3 = tmp___16;
          if (_incr___3 >= maxsize - i) {
            return ((size_t )0);
          }
          if (p) {
            if (digits == 0) {
              if (_n___3 < _w___3) {
                _delta___3 = (size_t )width - _n___3;
                if (pad == 48) {
                  memset((void *)p, '0', _delta___3);
                  p += _delta___3;
                } else {
                  memset((void *)p, ' ', _delta___3);
                  p += _delta___3;
                }
              }
            }
            *p = sign_char;
            p += _n___3;
          }
          i += _incr___3;
          break;
        }
      }
    } else {
      padding = (digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - ! (! sign_char);
      if (padding > 0) {
        if (pad == 95) {
          if ((size_t )padding >= maxsize - i) {
            return ((size_t )0);
          }
          if (p) {
            memset((void *)p, ' ', (size_t )padding);
            p += padding;
          }
          i += (size_t )padding;
          if (width > padding) {
            width -= padding;
          } else {
            width = 0;
          }
          if (sign_char) {
            while (1) {
              _n___4 = (size_t )1;
              if (width < 0) {
                tmp___17 = 0;
              } else {
                tmp___17 = width;
              }
              _w___4 = (size_t )tmp___17;
              if (_n___4 < _w___4) {
                tmp___18 = _w___4;
              } else {
                tmp___18 = _n___4;
              }
              _incr___4 = tmp___18;
              if (_incr___4 >= maxsize - i) {
                return ((size_t )0);
              }
              if (p) {
                if (digits == 0) {
                  if (_n___4 < _w___4) {
                    _delta___4 = (size_t )width - _n___4;
                    if (pad == 48) {
                      memset((void *)p, '0', _delta___4);
                      p += _delta___4;
                    } else {
                      memset((void *)p, ' ', _delta___4);
                      p += _delta___4;
                    }
                  }
                }
                *p = sign_char;
                p += _n___4;
              }
              i += _incr___4;
              break;
            }
          }
        } else {
          if ((size_t )digits >= maxsize - i) {
            return ((size_t )0);
          }
          if (sign_char) {
            while (1) {
              _n___5 = (size_t )1;
              if (width < 0) {
                tmp___19 = 0;
              } else {
                tmp___19 = width;
              }
              _w___5 = (size_t )tmp___19;
              if (_n___5 < _w___5) {
                tmp___20 = _w___5;
              } else {
                tmp___20 = _n___5;
              }
              _incr___5 = tmp___20;
              if (_incr___5 >= maxsize - i) {
                return ((size_t )0);
              }
              if (p) {
                if (digits == 0) {
                  if (_n___5 < _w___5) {
                    _delta___5 = (size_t )width - _n___5;
                    if (pad == 48) {
                      memset((void *)p, '0', _delta___5);
                      p += _delta___5;
                    } else {
                      memset((void *)p, ' ', _delta___5);
                      p += _delta___5;
                    }
                  }
                }
                *p = sign_char;
                p += _n___5;
              }
              i += _incr___5;
              break;
            }
          }
          if (p) {
            memset((void *)p, '0', (size_t )padding);
            p += padding;
          }
          i += (size_t )padding;
          width = 0;
        }
      } else
      if (sign_char) {
        while (1) {
          _n___6 = (size_t )1;
          if (width < 0) {
            tmp___21 = 0;
          } else {
            tmp___21 = width;
          }
          _w___6 = (size_t )tmp___21;
          if (_n___6 < _w___6) {
            tmp___22 = _w___6;
          } else {
            tmp___22 = _n___6;
          }
          _incr___6 = tmp___22;
          if (_incr___6 >= maxsize - i) {
            return ((size_t )0);
          }
          if (p) {
            if (digits == 0) {
              if (_n___6 < _w___6) {
                _delta___6 = (size_t )width - _n___6;
                if (pad == 48) {
                  memset((void *)p, '0', _delta___6);
                  p += _delta___6;
                } else {
                  memset((void *)p, ' ', _delta___6);
                  p += _delta___6;
                }
              }
            }
            *p = sign_char;
            p += _n___6;
          }
          i += _incr___6;
          break;
        }
      }
    }
    while (1) {
      _n___7 = (size_t )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
      if (width < 0) {
        tmp___23 = 0;
      } else {
        tmp___23 = width;
      }
      _w___7 = (size_t )tmp___23;
      if (_n___7 < _w___7) {
        tmp___24 = _w___7;
      } else {
        tmp___24 = _n___7;
      }
      _incr___7 = tmp___24;
      if (_incr___7 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___7 < _w___7) {
            _delta___7 = (size_t )width - _n___7;
            if (pad == 48) {
              memset((void *)p, '0', _delta___7);
              p += _delta___7;
            } else {
              memset((void *)p, ' ', _delta___7);
              p += _delta___7;
            }
          }
        }
        if (to_lowcase) {
          memcpy_lowcase(p, (char const   *)bufp, _n___7);
        } else
        if (to_uppcase) {
          memcpy_uppcase(p, (char const   *)bufp, _n___7);
        } else {
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)bufp),
                 _n___7);
        }
        p += _n___7;
      }
      i += _incr___7;
      break;
    }
    break;
    case 70: 
    if (modifier != 0) {
      goto bad_format;
    }
    subfmt = "%Y-%m-%d";
    goto subformat;
    case 72: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_hour;
    goto do_number;
    case 73: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = hour12;
    goto do_number;
    case 107: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_hour;
    goto do_number_spacepad;
    case 108: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = hour12;
    goto do_number_spacepad;
    case 106: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 3;
    negative_number = (_Bool )(tp->tm_yday < -1);
    u_number_value = (unsigned int )tp->tm_yday + 1U;
    goto do_signed_number;
    case 77: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_min;
    goto do_number;
    case 109: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    negative_number = (_Bool )(tp->tm_mon < -1);
    u_number_value = (unsigned int )tp->tm_mon + 1U;
    goto do_signed_number;
    case 78: 
    if (modifier == 69) {
      goto bad_format;
    }
    number_value = ns;
    if (width == -1) {
      width = 9;
    } else {
      j = width;
      while (j < 9) {
        number_value /= 10;
        j ++;
      }
    }
    digits = width;
    number_value = number_value;
    goto do_number;
    case 110: 
    while (1) {
      _n___8 = (size_t )1;
      if (width < 0) {
        tmp___25 = 0;
      } else {
        tmp___25 = width;
      }
      _w___8 = (size_t )tmp___25;
      if (_n___8 < _w___8) {
        tmp___26 = _w___8;
      } else {
        tmp___26 = _n___8;
      }
      _incr___8 = tmp___26;
      if (_incr___8 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___8 < _w___8) {
            _delta___8 = (size_t )width - _n___8;
            if (pad == 48) {
              memset((void *)p, '0', _delta___8);
              p += _delta___8;
            } else {
              memset((void *)p, ' ', _delta___8);
              p += _delta___8;
            }
          }
        }
        *p = (char )'\n';
        p += _n___8;
      }
      i += _incr___8;
      break;
    }
    break;
    case 80: 
    to_lowcase = (_Bool)1;
    format_char = 'p';
    case 112: 
    if (change_case) {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
    }
    goto underlying_strftime;
    case 82: 
    subfmt = "%H:%M";
    goto subformat;
    case 114: 
    goto underlying_strftime;
    case 83: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )tp->tm_sec;
    goto do_number;
    case 115: 
    ltm = (struct tm )*tp;
    t = mktime(& ltm);
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
    negative_number = (_Bool )(t < 0L);
    while (1) {
      d = (int )(t % 10L);
      t /= 10L;
      bufp --;
      if (negative_number) {
        tmp___27 = - d;
      } else {
        tmp___27 = d;
      }
      *bufp = (char )(tmp___27 + 48);
      if (! (t != 0L)) {
        break;
      }
    }
    digits = 1;
    always_output_a_sign = (_Bool)0;
    goto do_number_sign_and_padding;
    case 88: 
    if (modifier == 79) {
      goto bad_format;
    }
    goto underlying_strftime;
    case 84: 
    subfmt = "%H:%M:%S";
    goto subformat;
    case 116: 
    while (1) {
      _n___9 = (size_t )1;
      if (width < 0) {
        tmp___28 = 0;
      } else {
        tmp___28 = width;
      }
      _w___9 = (size_t )tmp___28;
      if (_n___9 < _w___9) {
        tmp___29 = _w___9;
      } else {
        tmp___29 = _n___9;
      }
      _incr___9 = tmp___29;
      if (_incr___9 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___9 < _w___9) {
            _delta___9 = (size_t )width - _n___9;
            if (pad == 48) {
              memset((void *)p, '0', _delta___9);
              p += _delta___9;
            } else {
              memset((void *)p, ' ', _delta___9);
              p += _delta___9;
            }
          }
        }
        *p = (char )'\t';
        p += _n___9;
      }
      i += _incr___9;
      break;
    }
    break;
    case 117: 
    digits = 1;
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
    goto do_number;
    case 85: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
    goto do_number;
    case 86: 
    case 103: 
    case 71: 
    if (modifier == 69) {
      goto bad_format;
    }
    if (tp->tm_year < 0) {
      tmp___30 = 300;
    } else {
      tmp___30 = -100;
    }
    year___0 = (int )(tp->tm_year + (int const   )tmp___30);
    year_adjust = 0;
    tmp___31 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
    days = tmp___31;
    if (days < 0) {
      year_adjust = -1;
      if ((year___0 - 1) % 4 == 0) {
        if ((year___0 - 1) % 100 != 0) {
          tmp___32 = 1;
        } else
        if ((year___0 - 1) % 400 == 0) {
          tmp___32 = 1;
        } else {
          tmp___32 = 0;
        }
      } else {
        tmp___32 = 0;
      }
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___32)), (int )tp->tm_wday);
    } else {
      if (year___0 % 4 == 0) {
        if (year___0 % 100 != 0) {
          tmp___33 = 1;
        } else
        if (year___0 % 400 == 0) {
          tmp___33 = 1;
        } else {
          tmp___33 = 0;
        }
      } else {
        tmp___33 = 0;
      }
      tmp___34 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___33)),
                               (int )tp->tm_wday);
      d___0 = tmp___34;
      if (0 <= d___0) {
        year_adjust = 1;
        days = d___0;
      }
    }
    switch ((int )*f) {
    case 103: 
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
    digits = 2;
    if (0 <= yy) {
      number_value = yy;
    } else {
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
        tmp___35 = - yy;
      } else {
        tmp___35 = yy + 100;
      }
      number_value = tmp___35;
    }
    goto do_number;
    case 71: 
    digits = 4;
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
    goto do_signed_number;
    default: 
    digits = 2;
    number_value = days / 7 + 1;
    goto do_number;
    }
    case 87: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 2;
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
    goto do_number;
    case 119: 
    if (modifier == 69) {
      goto bad_format;
    }
    digits = 1;
    number_value = (int )tp->tm_wday;
    goto do_number;
    case 89: 
    if (modifier == 69) {
      goto underlying_strftime;
    }
    if (modifier == 79) {
      goto bad_format;
    } else {
      digits = 4;
    }
    negative_number = (_Bool )(tp->tm_year < -1900);
    u_number_value = (unsigned int )tp->tm_year + 1900U;
    goto do_signed_number;
    case 121: 
    if (modifier == 69) {
      goto underlying_strftime;
    }
    yy___0 = (int )(tp->tm_year % 100);
    if (yy___0 < 0) {
      if (tp->tm_year < -1900) {
        yy___0 = - yy___0;
      } else {
        yy___0 += 100;
      }
    }
    digits = 2;
    number_value = yy___0;
    goto do_number;
    case 90: 
    if (change_case) {
      to_uppcase = (_Bool)0;
      to_lowcase = (_Bool)1;
    }
    if (! zone) {
      zone = "";
    }
    while (1) {
      tmp___36 = strlen(zone);
      _n___10 = tmp___36;
      if (width < 0) {
        tmp___37 = 0;
      } else {
        tmp___37 = width;
      }
      _w___10 = (size_t )tmp___37;
      if (_n___10 < _w___10) {
        tmp___38 = _w___10;
      } else {
        tmp___38 = _n___10;
      }
      _incr___10 = tmp___38;
      if (_incr___10 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___10 < _w___10) {
            _delta___10 = (size_t )width - _n___10;
            if (pad == 48) {
              memset((void *)p, '0', _delta___10);
              p += _delta___10;
            } else {
              memset((void *)p, ' ', _delta___10);
              p += _delta___10;
            }
          }
        }
        if (to_lowcase) {
          memcpy_lowcase(p, zone, _n___10);
        } else
        if (to_uppcase) {
          memcpy_uppcase(p, zone, _n___10);
        } else {
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)zone),
                 _n___10);
        }
        p += _n___10;
      }
      i += _incr___10;
      break;
    }
    break;
    case 58: 
    colons = (size_t )1;
    while ((int const   )*(f + colons) == 58) {
      goto __Cont___0;
      __Cont___0: 
      colons ++;
    }
    if ((int const   )*(f + colons) != 122) {
      goto bad_format;
    }
    f += colons;
    goto do_z_conversion;
    case 122: 
    colons = (size_t )0;
    do_z_conversion: 
    if (tp->tm_isdst < 0) {
      break;
    }
    diff = (int )tp->tm_gmtoff;
    hour_diff = (diff / 60) / 60;
    min_diff = (diff / 60) % 60;
    sec_diff = diff % 60;
    switch ((int )colons) {
    case 0: 
    digits = 5;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    goto do_tz_offset;
    tz_hh_mm: 
    case 1: 
    digits = 6;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 4;
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2: 
    digits = 9;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 20;
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
    goto do_tz_offset;
    case 3: 
    if (sec_diff != 0) {
      goto tz_hh_mm_ss;
    }
    if (min_diff != 0) {
      goto tz_hh_mm;
    }
    digits = 3;
    negative_number = (_Bool )(diff < 0);
    tz_colon_mask = 0;
    u_number_value = (unsigned int )hour_diff;
    goto do_tz_offset;
    default: 
    goto bad_format;
    }
    case 0: 
    f --;
    bad_format: 
    default: 
    flen = 1;
    while ((int const   )*(f + (1 - flen)) != 37) {
      goto __Cont___1;
      __Cont___1: 
      flen ++;
    }
    while (1) {
      _n___11 = (size_t )flen;
      if (width < 0) {
        tmp___39 = 0;
      } else {
        tmp___39 = width;
      }
      _w___11 = (size_t )tmp___39;
      if (_n___11 < _w___11) {
        tmp___40 = _w___11;
      } else {
        tmp___40 = _n___11;
      }
      _incr___11 = tmp___40;
      if (_incr___11 >= maxsize - i) {
        return ((size_t )0);
      }
      if (p) {
        if (digits == 0) {
          if (_n___11 < _w___11) {
            _delta___11 = (size_t )width - _n___11;
            if (pad == 48) {
              memset((void *)p, '0', _delta___11);
              p += _delta___11;
            } else {
              memset((void *)p, ' ', _delta___11);
              p += _delta___11;
            }
          }
        }
        if (to_lowcase) {
          memcpy_lowcase(p, f + (1 - flen), _n___11);
        } else
        if (to_uppcase) {
          memcpy_uppcase(p, f + (1 - flen), _n___11);
        } else {
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)(f + (1 - flen))),
                 _n___11);
        }
        p += _n___11;
      }
      i += _incr___11;
      break;
    }
    break;
    }
    __Cont: 
    f ++;
  }
  if (p) {
    if (maxsize != 0UL) {
      *p = (char )'\000';
    }
  }
  return (i);
}
}
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ size_t tmp ;

  {
  tmp = strftime_case____0((_Bool)0, s, maxsize, format, tp, ut, ns);
  return (tmp);
}
}
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
extern int iconv_close(iconv_t __cd ) ;
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_21 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
  count = (size_t )0;
  inptr = src;
  insize = srclen;
  while (insize > 0UL) {
    outptr = tmp.buf;
    outsize = (size_t )4096;
    tmp___0 = iconv(cd, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& insize),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outsize));
    res = tmp___0;
    if (res == 0xffffffffffffffffUL) {
      tmp___2 = __errno_location();
      if (! (*tmp___2 == 7)) {
        tmp___1 = __errno_location();
        if (*tmp___1 == 22) {
          break;
        } else {
          return (-1);
        }
      }
    }
    count += (size_t )(outptr - tmp.buf);
  }
  outptr___0 = tmp.buf;
  outsize___0 = (size_t )4096;
  tmp___3 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                  (char ** __restrict  )(& outptr___0), (size_t * __restrict  )(& outsize___0));
  res___0 = tmp___3;
  if (res___0 == 0xffffffffffffffffUL) {
    return (-1);
  }
  count += (size_t )(outptr___0 - tmp.buf);
  length = count;
  if (length == 0UL) {
    *lengthp = (size_t )0;
    return (0);
  }
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
    if (*lengthp >= length) {
      result = *resultp;
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp___4 = malloc(length);
    result = (char *)tmp___4;
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      tmp___5 = __errno_location();
      *tmp___5 = 12;
      return (-1);
    }
  }
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
  inptr___0 = src;
  insize___0 = srclen;
  outptr___1 = result;
  outsize___1 = length;
  while (insize___0 > 0UL) {
    tmp___6 = iconv(cd, (char ** __restrict  )((char **)(& inptr___0)), (size_t * __restrict  )(& insize___0),
                    (char ** __restrict  )(& outptr___1), (size_t * __restrict  )(& outsize___1));
    res___1 = tmp___6;
    if (res___1 == 0xffffffffffffffffUL) {
      tmp___7 = __errno_location();
      if (*tmp___7 == 22) {
        break;
      } else {
        goto fail;
      }
    }
  }
  tmp___8 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                  (char ** __restrict  )(& outptr___1), (size_t * __restrict  )(& outsize___1));
  res___2 = tmp___8;
  if (res___2 == 0xffffffffffffffffUL) {
    goto fail;
  }
  if (outsize___1 != 0UL) {
    abort();
  }
  *resultp = result;
  *lengthp = length;
  return (0);
  fail: 
  if ((unsigned long )result != (unsigned long )*resultp) {
    tmp___9 = __errno_location();
    saved_errno = *tmp___9;
    free((void *)result);
    tmp___10 = __errno_location();
    *tmp___10 = saved_errno;
  }
  return (-1);
}
}
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___0 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
  inptr = src;
  tmp = strlen(src);
  inbytes_remaining = tmp;
  result_size = inbytes_remaining;
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
    result_size *= 16UL;
  }
  result_size ++;
  tmp___0 = malloc(result_size);
  result = (char *)tmp___0;
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    tmp___1 = __errno_location();
    *tmp___1 = 12;
    return ((char *)((void *)0));
  }
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
  outptr = result;
  outbytes_remaining = result_size - 1UL;
  while (1) {
    tmp___2 = iconv(cd, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& inbytes_remaining),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytes_remaining));
    res = tmp___2;
    if (res == 0xffffffffffffffffUL) {
      tmp___7 = __errno_location();
      if (*tmp___7 == 22) {
        break;
      } else {
        tmp___6 = __errno_location();
        if (*tmp___6 == 7) {
          used = (size_t )(outptr - result);
          newsize = result_size * 2UL;
          if (! (newsize > result_size)) {
            tmp___3 = __errno_location();
            *tmp___3 = 12;
            goto failed;
          }
          tmp___4 = realloc((void *)result, newsize);
          newresult = (char *)tmp___4;
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
            tmp___5 = __errno_location();
            *tmp___5 = 12;
            goto failed;
          }
          result = newresult;
          result_size = newsize;
          outptr = result + used;
          outbytes_remaining = (result_size - 1UL) - used;
        } else {
          goto failed;
        }
      }
    } else {
      break;
    }
  }
  while (1) {
    tmp___8 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytes_remaining));
    res___0 = tmp___8;
    if (res___0 == 0xffffffffffffffffUL) {
      tmp___12 = __errno_location();
      if (*tmp___12 == 7) {
        used___0 = (size_t )(outptr - result);
        newsize___0 = result_size * 2UL;
        if (! (newsize___0 > result_size)) {
          tmp___9 = __errno_location();
          *tmp___9 = 12;
          goto failed;
        }
        tmp___10 = realloc((void *)result, newsize___0);
        newresult___0 = (char *)tmp___10;
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
          tmp___11 = __errno_location();
          *tmp___11 = 12;
          goto failed;
        }
        result = newresult___0;
        result_size = newsize___0;
        outptr = result + used___0;
        outbytes_remaining = (result_size - 1UL) - used___0;
      } else {
        goto failed;
      }
    } else {
      break;
    }
  }
  tmp___13 = outptr;
  outptr ++;
  *tmp___13 = (char )'\000';
  length = (size_t )(outptr - result);
  if (length < result_size) {
    tmp___14 = realloc((void *)result, length);
    smaller_result = (char *)tmp___14;
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
      result = smaller_result;
    }
  }
  return (result);
  failed: 
  tmp___15 = __errno_location();
  saved_errno = *tmp___15;
  free((void *)result);
  tmp___16 = __errno_location();
  *tmp___16 = saved_errno;
  return ((char *)((void *)0));
}
}
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ char *result ;
  char *tmp___4 ;
  int *tmp___5 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___6 ;
  int *tmp___7 ;
  int saved_errno___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  if ((int const   )*src == 0) {
    goto _L;
  } else {
    tmp___11 = c_strcasecmp(from_codeset, to_codeset);
    if (tmp___11 == 0) {
      _L: 
      tmp___4 = __strdup(src);
      result = tmp___4;
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        tmp___5 = __errno_location();
        *tmp___5 = 12;
      }
      return (result);
    } else {
      cd = iconv_open(to_codeset, from_codeset);
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
        return ((char *)((void *)0));
      }
      result___0 = str_cd_iconv(src, cd);
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
        tmp___6 = __errno_location();
        saved_errno = *tmp___6;
        iconv_close(cd);
        tmp___7 = __errno_location();
        *tmp___7 = saved_errno;
      } else {
        tmp___10 = iconv_close(cd);
        if (tmp___10 < 0) {
          tmp___8 = __errno_location();
          saved_errno___0 = *tmp___8;
          free((void *)result___0);
          tmp___9 = __errno_location();
          *tmp___9 = saved_errno___0;
          return ((char *)((void *)0));
        }
      }
      return (result___0);
    }
  }
}
}
size_t strnlen1(char const   *string , size_t maxlen ) 
{ char const   *end ;
  void *tmp ;

  {
  tmp = memchr((void const   *)string, '\000', maxlen);
  end = (char const   *)tmp;
  if ((unsigned long )end != (unsigned long )((void *)0)) {
    return ((size_t )((end - string) + 1));
  } else {
    return (maxlen);
  }
}
}
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) ;
__inline static _Bool __attribute__((__pure__))  check_x_suffix(char const   *s ,
                                                                size_t len ) 
{ unsigned long tmp___8 ;

  {
  tmp___8 = __builtin_strspn(s, "X");
  return ((_Bool __attribute__((__pure__))  )(len <= tmp___8));
}
}
static char const   letters[63]  = 
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) 
{ size_t len ;
  char *XXXXXX ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  struct randint_source *rand_src ;
  unsigned int attempts ;
  int *tmp___0 ;
  _Bool __attribute__((__pure__))  tmp___1 ;
  size_t i ;
  randint tmp___2 ;
  int __attribute__((__artificial__))  tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int saved_errno ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
  fd = -1;
  tmp = __errno_location();
  save_errno = *tmp;
  attempts = 238328U;
  len = strlen((char const   *)tmpl);
  if (len < x_suffix_len + (size_t )suffixlen) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (-1);
  } else {
    tmp___1 = check_x_suffix((char const   *)(tmpl + ((len - x_suffix_len) - (size_t )suffixlen)),
                             x_suffix_len);
    if (! tmp___1) {
      tmp___0 = __errno_location();
      *tmp___0 = 22;
      return (-1);
    }
  }
  XXXXXX = tmpl + ((len - x_suffix_len) - (size_t )suffixlen);
  rand_src = randint_all_new((char const   *)((void *)0), x_suffix_len);
  if (! rand_src) {
    return (-1);
  }
  count = 0U;
  while (count < attempts) {
    i = (size_t )0;
    while (i < x_suffix_len) {
      tmp___2 = randint_genmax(rand_src, sizeof(letters) - 2UL);
      *(XXXXXX + i) = (char )letters[tmp___2];
      i ++;
    }
    switch (kind) {
    case 0: 
    tmp___3 = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
    fd = (int )tmp___3;
    break;
    case 1: 
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
    break;
    case 2: 
    tmp___6 = lstat((char const   * __restrict  )tmpl, (struct stat * __restrict  )(& st));
    if (tmp___6 < 0) {
      tmp___5 = __errno_location();
      if (*tmp___5 == 2) {
        tmp___4 = __errno_location();
        *tmp___4 = save_errno;
        fd = 0;
        goto done;
      } else {
        fd = -1;
        goto done;
      }
    }
    goto __Cont;
    default: 
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "tempname.c", 296U, "gen_tempname_len");
    abort();
    }
    if (fd >= 0) {
      tmp___7 = __errno_location();
      *tmp___7 = save_errno;
      goto done;
    } else {
      tmp___8 = __errno_location();
      if (*tmp___8 != 17) {
        fd = -1;
        goto done;
      }
    }
    __Cont: 
    count ++;
  }
  randint_all_free(rand_src);
  tmp___9 = __errno_location();
  *tmp___9 = 17;
  return (-1);
  done: 
  tmp___10 = __errno_location();
  saved_errno = *tmp___10;
  randint_all_free(rand_src);
  tmp___11 = __errno_location();
  *tmp___11 = saved_errno;
  return (fd);
}
}
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ int tmp ;

  {
  tmp = gen_tempname_len(tmpl, suffixlen, flags, kind, (size_t )6);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int iswspace(wint_t __wc ) ;
__inline static void mbiter_multi_next(struct mbiter_multi *iter ) 
{ int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  if (iter->next_done) {
    return;
  }
  if (iter->in_shift) {
    goto with_shift;
  }
  tmp___1 = is_basic((char )*(iter->cur.ptr));
  if (tmp___1) {
    iter->cur.bytes = (size_t )1;
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
    iter->cur.wc_valid = (_Bool)1;
  } else {
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
    if (! tmp) {
      __assert_fail("mbsinit (&iter->state)", "mbiter.h", 134U, "mbiter_multi_next");
    }
    iter->in_shift = (_Bool)1;
    with_shift: 
    iter->cur.bytes = mbrtowc((wchar_t * __restrict  )(& iter->cur.wc), (char const   * __restrict  )iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), & iter->state);
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
      iter->cur.bytes = (size_t )1;
      iter->cur.wc_valid = (_Bool)0;
    } else
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
      iter->cur.wc_valid = (_Bool)0;
    } else {
      if (iter->cur.bytes == 0UL) {
        iter->cur.bytes = (size_t )1;
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          __assert_fail("*iter->cur.ptr == \'\\0\'", "mbiter.h", 161U, "mbiter_multi_next");
        }
        if (! (iter->cur.wc == 0)) {
          __assert_fail("iter->cur.wc == 0", "mbiter.h", 162U, "mbiter_multi_next");
        }
      }
      iter->cur.wc_valid = (_Bool)1;
      tmp___0 = mbsinit((mbstate_t const   *)(& iter->state));
      if (tmp___0) {
        iter->in_shift = (_Bool)0;
      }
    }
  }
  iter->next_done = (_Bool)1;
  return;
}
}
char *trim2(char const   *s , int how ) 
{ char *d ;
  char *tmp___4 ;
  mbi_iterator_t i ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  unsigned int state ;
  char *r ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *p ;
  unsigned short const   **tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  unsigned short const   **tmp___17 ;
  size_t tmp___18 ;

  {
  tmp___4 = __strdup(s);
  d = tmp___4;
  if (! d) {
    xalloc_die();
  }
  tmp___18 = __ctype_get_mb_cur_max();
  if (tmp___18 > 1UL) {
    if (how != 0) {
      i.cur.ptr = (char const   *)d;
      tmp___5 = strlen((char const   *)d);
      i.limit = i.cur.ptr + tmp___5;
      i.in_shift = (_Bool)0;
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
      i.next_done = (_Bool)0;
      while (1) {
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          mbiter_multi_next(& i);
          if (i.cur.wc_valid) {
            tmp___6 = iswspace((wint_t )i.cur.wc);
            if (! tmp___6) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        i.cur.ptr += i.cur.bytes;
        i.next_done = (_Bool)0;
      }
      tmp___7 = strlen(i.cur.ptr);
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___7 + 1UL);
    }
    if (how != 1) {
      state = 0U;
      i.cur.ptr = (char const   *)d;
      tmp___8 = strlen((char const   *)d);
      i.limit = i.cur.ptr + tmp___8;
      i.in_shift = (_Bool)0;
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
      i.next_done = (_Bool)0;
      while (1) {
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
          mbiter_multi_next(& i);
        } else {
          break;
        }
        if (state == 0U) {
          if (i.cur.wc_valid) {
            tmp___9 = iswspace((wint_t )i.cur.wc);
            if (tmp___9) {
              goto __Cont;
            }
          }
        }
        if (state == 0U) {
          if (i.cur.wc_valid) {
            tmp___10 = iswspace((wint_t )i.cur.wc);
            if (! tmp___10) {
              state = 1U;
              goto __Cont;
            }
          } else {
            state = 1U;
            goto __Cont;
          }
        }
        if (state == 1U) {
          if (i.cur.wc_valid) {
            tmp___11 = iswspace((wint_t )i.cur.wc);
            if (! tmp___11) {
              goto __Cont;
            }
          } else {
            goto __Cont;
          }
        }
        if (state == 1U) {
          if (i.cur.wc_valid) {
            tmp___13 = iswspace((wint_t )i.cur.wc);
            if (tmp___13) {
              state = 2U;
              r = (char *)i.cur.ptr;
            } else {
              goto _L;
            }
          } else {
            goto _L;
          }
        } else
        _L: 
        if (state == 2U) {
          if (i.cur.wc_valid) {
            tmp___12 = iswspace((wint_t )i.cur.wc);
            if (! tmp___12) {
              state = 1U;
            }
          } else {
            state = 1U;
          }
        } else {
          state = 1U;
        }
        __Cont: 
        i.cur.ptr += i.cur.bytes;
        i.next_done = (_Bool)0;
      }
      if (state == 2U) {
        *r = (char )'\000';
      }
    }
  } else {
    if (how != 0) {
      p = d;
      while (1) {
        if (*p) {
          tmp___14 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___14 + (int )((unsigned char )*p)) & 8192)) {
            break;
          }
        } else {
          break;
        }
        p ++;
      }
      tmp___15 = strlen((char const   *)p);
      memmove((void *)d, (void const   *)p, tmp___15 + 1UL);
    }
    if (how != 1) {
      tmp___16 = strlen((char const   *)d);
      p = (d + tmp___16) - 1;
      while (1) {
        if ((unsigned long )p >= (unsigned long )d) {
          tmp___17 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___17 + (int )((unsigned char )*p)) & 8192)) {
            break;
          }
        } else {
          break;
        }
        *p = (char )'\000';
        p --;
      }
    }
  }
  return (d);
}
}
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
long fwrite_success_callback(char const   *buf___1 , size_t buflen , void *callback_arg ) ;
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
__inline static int u8_uctomb(uint8_t *s , ucs4_t uc , int n ) 
{ int tmp ;

  {
  if (uc < 128U) {
    if (n > 0) {
      *(s + 0) = (uint8_t )uc;
      return (1);
    } else {
      tmp = u8_uctomb_aux(s, uc, n);
      return (tmp);
    }
  } else {
    tmp = u8_uctomb_aux(s, uc, n);
    return (tmp);
  }
}
}
static int initialized  ;
static int is_utf8  ;
static iconv_t utf8_to_local  ;
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) 
{ char inbuf[6] ;
  int count ;
  char const   *charset ;
  char const   *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  char outbuf[25] ;
  char const   *inptr ;
  size_t inbytesleft ;
  char *outptr ;
  size_t outbytesleft ;
  size_t res ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
  if (! initialized) {
    tmp = locale_charset();
    charset = tmp;
    if (0) {
      __s1_len = __builtin_strlen(charset);
      __s2_len = __builtin_strlen("UTF-8");
      if (! ((size_t )((void const   *)(charset + 1)) - (size_t )((void const   *)charset) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)("UTF-8" + 1)) - (size_t )((void const   *)"UTF-8") == 1UL)) {
          tmp___6 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___6 = 1;
        } else {
          tmp___6 = 0;
        }
      } else {
        tmp___6 = 0;
      }
      if (tmp___6) {
        tmp___1 = __builtin_strcmp(charset, "UTF-8");
        tmp___5 = tmp___1;
      } else {
        tmp___4 = __builtin_strcmp(charset, "UTF-8");
        tmp___5 = tmp___4;
      }
    } else {
      tmp___4 = __builtin_strcmp(charset, "UTF-8");
      tmp___5 = tmp___4;
    }
    if (tmp___5) {
      tmp___7 = 0;
    } else {
      tmp___7 = 1;
    }
    is_utf8 = tmp___7;
    if (! is_utf8) {
      utf8_to_local = iconv_open(charset, "UTF-8");
      if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
        utf8_to_local = iconv_open("ASCII", "UTF-8");
      }
    }
    initialized = 1;
  }
  if (! is_utf8) {
    if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
      tmp___8 = (*failure)(code, "iconv function not usable", callback_arg);
      return (tmp___8);
    }
  }
  count = u8_uctomb((unsigned char *)(inbuf), code, (int )sizeof(inbuf));
  if (count < 0) {
    tmp___9 = (*failure)(code, "character out of range", callback_arg);
    return (tmp___9);
  }
  if (! is_utf8) {
    inptr = (char const   *)(inbuf);
    inbytesleft = (size_t )count;
    outptr = outbuf;
    outbytesleft = sizeof(outbuf);
    res = iconv(utf8_to_local, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& inbytesleft),
                (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytesleft));
    if (inbytesleft > 0UL) {
      tmp___10 = (*failure)(code, (char const   *)((void *)0), callback_arg);
      return (tmp___10);
    } else
    if (res == 0xffffffffffffffffUL) {
      tmp___10 = (*failure)(code, (char const   *)((void *)0), callback_arg);
      return (tmp___10);
    }
    res = iconv(utf8_to_local, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytesleft));
    if (res == 0xffffffffffffffffUL) {
      tmp___11 = (*failure)(code, (char const   *)((void *)0), callback_arg);
      return (tmp___11);
    }
    tmp___12 = (*success)((char const   *)(outbuf), (size_t )(outptr - outbuf), callback_arg);
    return (tmp___12);
  }
  tmp___13 = (*success)((char const   *)(inbuf), (size_t )count, callback_arg);
  return (tmp___13);
}
}
long fwrite_success_callback(char const   *buf___1 , size_t buflen , void *callback_arg ) 
{ FILE *stream ;
  size_t __attribute__((__nonnull__(1,4)))  __x ;
  size_t __attribute__((__nonnull__(1,4)))  tmp ;

  {
  stream = (FILE *)callback_arg;
  tmp = rpl_fwrite((void const   *)buf___1, (size_t )1, buflen, stream);
  __x = tmp;
  return (0L);
}
}
static long exit_failure_callback(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    tmp = dcgettext((char const   *)((void *)0), "cannot convert U+%04X to local character set",
                    5);
    error(1, 0, (char const   *)tmp, code);
  } else {
    tmp___0 = dcgettext((char const   *)((void *)0), msg, 5);
    tmp___1 = dcgettext((char const   *)((void *)0), "cannot convert U+%04X to local character set: %s",
                        5);
    error(1, 0, (char const   *)tmp___1, code, tmp___0);
  }
  return (-1L);
}
}
static long fallback_failure_callback(unsigned int code , char const   *msg  __attribute__((__unused__)) ,
                                      void *callback_arg ) 
{ FILE *stream ;

  {
  stream = (FILE *)callback_arg;
  if (code < 65536U) {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\\u%04X", code);
  } else {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\\U%08X", code);
  }
  return (-1L);
}
}
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) 
{ long (*tmp)(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) ;

  {
  if (exit_on_error) {
    tmp = & exit_failure_callback;
  } else {
    tmp = & fallback_failure_callback;
  }
  unicode_to_mb(code, & fwrite_success_callback, tmp, (void *)stream);
  return;
}
}
int dup_safer(int fd ) 
{ int tmp ;

  {
  tmp = rpl_fcntl(fd, 0, 3);
  return (tmp);
}
}
int fd_safer(int fd ) 
{ int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  if (0 <= fd) {
    if (fd <= 2) {
      tmp = dup_safer(fd);
      f = tmp;
      tmp___0 = __errno_location();
      e = *tmp___0;
      close(fd);
      tmp___1 = __errno_location();
      *tmp___1 = e;
      fd = f;
    }
  }
  return (fd);
}
}
int pipe_safer(int *fd ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes )  __attribute__((__warn_unused_result__)) ;
int pipe_safer(int *fd ) 
{ int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = pipe(fd);
  if (tmp___1 == 0) {
    i = 0;
    while (i < 2) {
      *(fd + i) = fd_safer(*(fd + i));
      if (*(fd + i) < 0) {
        tmp = __errno_location();
        e = *tmp;
        close(*(fd + (1 - i)));
        tmp___0 = __errno_location();
        *tmp___0 = e;
        return (-1);
      }
      i ++;
    }
    return (0);
  }
  return (-1);
}
}
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) ;
int u8_mbtoucr(ucs4_t *puc , uint8_t const   *s , size_t n ) 
{ uint8_t c ;

  {
  c = (uint8_t )*s;
  if ((int )c < 128) {
    *puc = (ucs4_t )c;
    return (1);
  } else
  if ((int )c >= 194) {
    if ((int )c < 224) {
      if (n >= 2UL) {
        if (((int const   )*(s + 1) ^ 128) < 64) {
          *puc = ((unsigned int )((int )c & 31) << 6) | (unsigned int )((int const   )*(s + 1) ^ 128);
          return (2);
        }
      } else {
        *puc = (ucs4_t )65533;
        return (-2);
      }
    } else
    if ((int )c < 240) {
      if (n >= 2UL) {
        if (((int const   )*(s + 1) ^ 128) < 64) {
          if ((int )c >= 225) {
            goto _L___0;
          } else
          if ((int const   )*(s + 1) >= 160) {
            _L___0: 
            if ((int )c != 237) {
              goto _L;
            } else
            if ((int const   )*(s + 1) < 160) {
              _L: 
              if (n >= 3UL) {
                if (((int const   )*(s + 2) ^ 128) < 64) {
                  *puc = (((unsigned int )((int )c & 15) << 12) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 2) ^ 128);
                  return (3);
                }
              } else {
                *puc = (ucs4_t )65533;
                return (-2);
              }
            }
          }
        }
      } else {
        *puc = (ucs4_t )65533;
        return (-2);
      }
    } else
    if ((int )c < 248) {
      if (n >= 2UL) {
        if (((int const   )*(s + 1) ^ 128) < 64) {
          if ((int )c >= 241) {
            goto _L___2;
          } else
          if ((int const   )*(s + 1) >= 144) {
            _L___2: 
            if ((int )c < 244) {
              goto _L___1;
            } else
            if ((int )c == 244) {
              if ((int const   )*(s + 1) < 144) {
                _L___1: 
                if (n >= 3UL) {
                  if (((int const   )*(s + 2) ^ 128) < 64) {
                    if (n >= 4UL) {
                      if (((int const   )*(s + 3) ^ 128) < 64) {
                        *puc = ((((unsigned int )((int )c & 7) << 18) | ((unsigned int )((int const   )*(s + 1) ^ 128) << 12)) | ((unsigned int )((int const   )*(s + 2) ^ 128) << 6)) | (unsigned int )((int const   )*(s + 3) ^ 128);
                        return (4);
                      }
                    } else {
                      *puc = (ucs4_t )65533;
                      return (-2);
                    }
                  }
                } else {
                  *puc = (ucs4_t )65533;
                  return (-2);
                }
              }
            }
          }
        }
      } else {
        *puc = (ucs4_t )65533;
        return (-2);
      }
    }
  }
  *puc = (ucs4_t )65533;
  return (-1);
}
}
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ int count ;

  {
  if (uc < 128U) {
    return (-2);
  } else
  if (uc < 2048U) {
    count = 2;
  } else
  if (uc < 65536U) {
    if (uc < 55296U) {
      count = 3;
    } else
    if (uc >= 57344U) {
      count = 3;
    } else {
      return (-1);
    }
  } else
  if (uc < 1114112U) {
    count = 4;
  } else {
    return (-1);
  }
  if (n < count) {
    return (-2);
  }
  switch (count) {
  case 4: 
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
  uc >>= 6;
  uc |= 65536U;
  case 3: 
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
  uc >>= 6;
  uc |= 2048U;
  case 2: 
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
  uc >>= 6;
  uc |= 192U;
  *(s + 0) = (uint8_t )uc;
  }
  return (count);
}
}
int uc_width(ucs4_t uc , char const   *encoding ) ;
__inline static int streq9(char const   *s1 , char const   *s2 ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (0) {
    __s1_len = __builtin_strlen(s1 + 9);
    __s2_len = __builtin_strlen(s2 + 9);
    if (! ((size_t )((void const   *)((s1 + 9) + 1)) - (size_t )((void const   *)(s1 + 9)) == 1UL)) {
      goto _L___0;
    } else
    if (__s1_len >= 4UL) {
      _L___0: 
      if (! ((size_t )((void const   *)((s2 + 9) + 1)) - (size_t )((void const   *)(s2 + 9)) == 1UL)) {
        tmp___5 = 1;
      } else
      if (__s2_len >= 4UL) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 0;
    }
    if (tmp___5) {
      tmp___0 = __builtin_strcmp(s1 + 9, s2 + 9);
      tmp___4 = tmp___0;
    } else {
      tmp___3 = __builtin_strcmp(s1 + 9, s2 + 9);
      tmp___4 = tmp___3;
    }
  } else {
    tmp___3 = __builtin_strcmp(s1 + 9, s2 + 9);
    tmp___4 = tmp___3;
  }
  return (tmp___4 == 0);
}
}
__inline static int streq8(char const   *s1 , char const   *s2 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 8) == (int const   )s28) {
    if ((int )s28 == 0) {
      return (1);
    } else {
      tmp = streq9(s1, s2);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq7(char const   *s1 , char const   *s2 , char s27 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 7) == (int const   )s27) {
    if ((int )s27 == 0) {
      return (1);
    } else {
      tmp = streq8(s1, s2, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq6(char const   *s1 , char const   *s2 , char s26 , char s27 ,
                           char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 6) == (int const   )s26) {
    if ((int )s26 == 0) {
      return (1);
    } else {
      tmp = streq7(s1, s2, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq5(char const   *s1 , char const   *s2 , char s25 , char s26 ,
                           char s27 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 5) == (int const   )s25) {
    if ((int )s25 == 0) {
      return (1);
    } else {
      tmp = streq6(s1, s2, s26, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq4(char const   *s1 , char const   *s2 , char s24 , char s25 ,
                           char s26 , char s27 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 4) == (int const   )s24) {
    if ((int )s24 == 0) {
      return (1);
    } else {
      tmp = streq5(s1, s2, s25, s26, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq3(char const   *s1 , char const   *s2 , char s23 , char s24 ,
                           char s25 , char s26 , char s27 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 3) == (int const   )s23) {
    if ((int )s23 == 0) {
      return (1);
    } else {
      tmp = streq4(s1, s2, s24, s25, s26, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq2(char const   *s1 , char const   *s2 , char s22 , char s23 ,
                           char s24 , char s25 , char s26 , char s27 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 2) == (int const   )s22) {
    if ((int )s22 == 0) {
      return (1);
    } else {
      tmp = streq3(s1, s2, s23, s24, s25, s26, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq1(char const   *s1 , char const   *s2 , char s21 , char s22 ,
                           char s23 , char s24 , char s25 , char s26 , char s27 ,
                           char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 1) == (int const   )s21) {
    if ((int )s21 == 0) {
      return (1);
    } else {
      tmp = streq2(s1, s2, s22, s23, s24, s25, s26, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
__inline static int streq0(char const   *s1 , char const   *s2 , char s20 , char s21 ,
                           char s22 , char s23 , char s24 , char s25 , char s26 ,
                           char s27 , char s28 ) 
{ int tmp ;

  {
  if ((int const   )*(s1 + 0) == (int const   )s20) {
    if ((int )s20 == 0) {
      return (1);
    } else {
      tmp = streq1(s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);
      return (tmp);
    }
  } else {
    return (0);
  }
}
}
static int is_cjk_encoding(char const   *encoding ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = streq0(encoding, "EUC-JP", (char )'E', (char )'U', (char )'C', (char )'-',
               (char )'J', (char )'P', (char)0, (char)0, (char)0);
  if (tmp) {
    return (1);
  } else {
    tmp___0 = streq0(encoding, "GB2312", (char )'G', (char )'B', (char )'2', (char )'3',
                     (char )'1', (char )'2', (char)0, (char)0, (char)0);
    if (tmp___0) {
      return (1);
    } else {
      tmp___1 = streq0(encoding, "GBK", (char )'G', (char )'B', (char )'K', (char)0,
                       (char)0, (char)0, (char)0, (char)0, (char)0);
      if (tmp___1) {
        return (1);
      } else {
        tmp___2 = streq0(encoding, "EUC-TW", (char )'E', (char )'U', (char )'C', (char )'-',
                         (char )'T', (char )'W', (char)0, (char)0, (char)0);
        if (tmp___2) {
          return (1);
        } else {
          tmp___3 = streq0(encoding, "BIG5", (char )'B', (char )'I', (char )'G', (char )'5',
                           (char)0, (char)0, (char)0, (char)0, (char)0);
          if (tmp___3) {
            return (1);
          } else {
            tmp___4 = streq0(encoding, "EUC-KR", (char )'E', (char )'U', (char )'C',
                             (char )'-', (char )'K', (char )'R', (char)0, (char)0,
                             (char)0);
            if (tmp___4) {
              return (1);
            } else {
              tmp___5 = streq0(encoding, "CP949", (char )'C', (char )'P', (char )'9',
                               (char )'4', (char )'9', (char)0, (char)0, (char)0,
                               (char)0);
              if (tmp___5) {
                return (1);
              } else {
                tmp___6 = streq0(encoding, "JOHAB", (char )'J', (char )'O', (char )'H',
                                 (char )'A', (char )'B', (char)0, (char)0, (char)0,
                                 (char)0);
                if (tmp___6) {
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static unsigned char const   nonspacing_table_data[1728]  = 
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )31,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
static signed char const   nonspacing_table_ind[240]  = 
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
int uc_width(ucs4_t uc , char const   *encoding ) 
{ int ind___0 ;
  int tmp ;
  int tmp___0 ;

  {
  if (uc >> 9 < 240U) {
    ind___0 = (int )nonspacing_table_ind[uc >> 9];
    if (ind___0 >= 0) {
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind___0) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
        if (uc > 0U) {
          if (uc < 160U) {
            return (-1);
          } else {
            return (0);
          }
        } else {
          return (0);
        }
      }
    }
  } else
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
    if (uc >= 917760U) {
      if (uc <= 917999U) {
        return (0);
      }
    } else {
      if (uc >= 917536U) {
        tmp = uc <= 917631U;
      } else {
        tmp = uc == 917505U;
      }
      if (tmp) {
        return (0);
      }
    }
  }
  if (uc >= 4352U) {
    if (uc < 4448U) {
      return (2);
    } else
    if (uc >= 9001U) {
      if (uc < 9003U) {
        return (2);
      } else {
        goto _L___9;
      }
    } else
    _L___9: 
    if (uc >= 11904U) {
      if (uc < 42192U) {
        if (! (uc == 12351U)) {
          if (uc >= 19904U) {
            if (uc < 19968U) {
              goto _L___8;
            } else {
              return (2);
            }
          } else {
            return (2);
          }
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else
    _L___8: 
    if (uc >= 44032U) {
      if (uc < 55204U) {
        return (2);
      } else {
        goto _L___5;
      }
    } else
    _L___5: 
    if (uc >= 63744U) {
      if (uc < 64256U) {
        return (2);
      } else {
        goto _L___4;
      }
    } else
    _L___4: 
    if (uc >= 65040U) {
      if (uc < 65056U) {
        return (2);
      } else {
        goto _L___3;
      }
    } else
    _L___3: 
    if (uc >= 65072U) {
      if (uc < 65136U) {
        return (2);
      } else {
        goto _L___2;
      }
    } else
    _L___2: 
    if (uc >= 65280U) {
      if (uc < 65377U) {
        return (2);
      } else {
        goto _L___1;
      }
    } else
    _L___1: 
    if (uc >= 65504U) {
      if (uc < 65511U) {
        return (2);
      } else {
        goto _L___0;
      }
    } else
    _L___0: 
    if (uc >= 131072U) {
      if (uc <= 196607U) {
        return (2);
      } else {
        goto _L;
      }
    } else
    _L: 
    if (uc >= 196608U) {
      if (uc <= 262143U) {
        return (2);
      }
    }
  }
  if (uc >= 161U) {
    if (uc < 65377U) {
      if (uc != 8361U) {
        tmp___0 = is_cjk_encoding(encoding);
        if (tmp___0) {
          return (2);
        }
      }
    }
  }
  return (1);
}
}
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
extern void endpwent(void) ;
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
static char const   *E_invalid_user  =    "invalid user";
static char const   *E_invalid_group  =    "invalid group";
static char const   *E_bad_spec  =    "invalid spec";
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) 
{ char const   *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const   *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *tmp ;
  size_t ulen ;
  void *tmp___0 ;
  struct passwd *tmp___1 ;
  _Bool use_login_group ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  strtol_error tmp___4 ;
  char buf___1[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct group *tmp___7 ;
  unsigned long tmp___8 ;
  strtol_error tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  gname = (char *)((void *)0);
  unum = *uid;
  gnum = *gid;
  error_msg = (char const   *)((void *)0);
  tmp = (char *)((void *)0);
  *groupname = tmp;
  *username = tmp;
  u = (char *)((void *)0);
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
    if (*spec) {
      u = xstrdup(spec);
    }
  } else {
    ulen = (size_t )(separator - spec);
    if (ulen != 0UL) {
      tmp___0 = xmemdup((void const   *)spec, ulen + 1UL);
      u = (char *)tmp___0;
      *(u + ulen) = (char )'\000';
    }
  }
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
    g = (char const   *)((void *)0);
  } else
  if ((int const   )*(separator + 1) == 0) {
    g = (char const   *)((void *)0);
  } else {
    g = separator + 1;
  }
  if ((unsigned long )u != (unsigned long )((void *)0)) {
    if ((int )*u == 43) {
      pwd = (struct passwd *)((void *)0);
    } else {
      tmp___1 = getpwnam((char const   *)u);
      pwd = tmp___1;
    }
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
      if ((unsigned long )separator != (unsigned long )((void *)0)) {
        if ((unsigned long )g == (unsigned long )((void *)0)) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      use_login_group = (_Bool )tmp___2;
      if (use_login_group) {
        error_msg = E_bad_spec;
      } else {
        tmp___4 = xstrtoul((char const   *)u, (char **)((void *)0), 10, & tmp___3,
                           "");
        if ((unsigned int )tmp___4 == 0U) {
          if (tmp___3 <= 4294967295UL) {
            if ((uid_t )tmp___3 != 4294967295U) {
              unum = (uid_t )tmp___3;
            } else {
              error_msg = E_invalid_user;
            }
          } else {
            error_msg = E_invalid_user;
          }
        } else {
          error_msg = E_invalid_user;
        }
      }
    } else {
      unum = pwd->pw_uid;
      if ((unsigned long )g == (unsigned long )((void *)0)) {
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
          gnum = pwd->pw_gid;
          grp = getgrgid(gnum);
          if (grp) {
            tmp___6 = grp->gr_name;
          } else {
            tmp___11 = (char *)umaxtostr((uintmax_t )gnum, buf___1);
            tmp___5 = tmp___11;
            tmp___6 = tmp___5;
          }
          gname = xstrdup((char const   *)tmp___6);
          endgrent();
        }
      }
    }
    endpwent();
  }
  if ((unsigned long )g != (unsigned long )((void *)0)) {
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
      if ((int const   )*g == 43) {
        grp = (struct group *)((void *)0);
      } else {
        tmp___7 = getgrnam(g);
        grp = tmp___7;
      }
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
        tmp___9 = xstrtoul(g, (char **)((void *)0), 10, & tmp___8, "");
        if ((unsigned int )tmp___9 == 0U) {
          if (tmp___8 <= 4294967295UL) {
            if ((gid_t )tmp___8 != 4294967295U) {
              gnum = (gid_t )tmp___8;
            } else {
              error_msg = E_invalid_group;
            }
          } else {
            error_msg = E_invalid_group;
          }
        } else {
          error_msg = E_invalid_group;
        }
      } else {
        gnum = grp->gr_gid;
      }
      endgrent();
      gname = xstrdup(g);
    }
  }
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
    *uid = unum;
    *gid = gnum;
    *username = u;
    *groupname = gname;
    u = (char *)((void *)0);
  } else {
    free((void *)gname);
  }
  free((void *)u);
  tmp___10 = dcgettext((char const   *)((void *)0), error_msg, 5);
  return ((char const   *)tmp___10);
}
}
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) 
{ char const   *colon ;
  char *tmp___0 ;
  char const   *error_msg ;
  char const   *tmp___1 ;
  char const   *dot ;
  char *tmp___3 ;
  char const   *tmp___4 ;

  {
  tmp___0 = __builtin_strchr((char *)spec, ':');
  colon = (char const   *)tmp___0;
  tmp___1 = parse_with_separator(spec, colon, uid, gid, username, groupname);
  error_msg = tmp___1;
  if (! colon) {
    if (error_msg) {
      tmp___3 = __builtin_strchr((char *)spec, '.');
      dot = (char const   *)tmp___3;
      if (dot) {
        tmp___4 = parse_with_separator(spec, dot, uid, gid, username, groupname);
        if (! tmp___4) {
          error_msg = (char const   *)((void *)0);
        }
      }
    }
  }
  return (error_msg);
}
}
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) ;
__inline static long get_stat_atime_ns(struct stat  const  *st ) 
{ 

  {
  return ((long )st->st_atim.tv_nsec);
}
}
__inline static long get_stat_ctime_ns(struct stat  const  *st ) 
{ 

  {
  return ((long )st->st_ctim.tv_nsec);
}
}
__inline static long get_stat_mtime_ns(struct stat  const  *st ) 
{ 

  {
  return ((long )st->st_mtim.tv_nsec);
}
}
int utimens(char const   *file , struct timespec  const  *timespec ) ;
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
static size_t dev_info_hash(void const   *x , size_t table_size ) 
{ struct fs_res  const  *p ;

  {
  p = (struct fs_res  const  *)x;
  return ((size_t )(p->dev % (unsigned long const   )table_size));
}
}
static _Bool dev_info_compare(void const   *x , void const   *y ) 
{ struct fs_res  const  *a ;
  struct fs_res  const  *b ;

  {
  a = (struct fs_res  const  *)x;
  b = (struct fs_res  const  *)y;
  return ((_Bool )(a->dev == b->dev));
}
}
static Hash_table *ht  ;
static struct fs_res *new_dst_res  ;
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) 
{ time_t dst_s ;
  time_t src_s ;
  int dst_ns ;
  long tmp ;
  int src_ns ;
  long tmp___0 ;
  struct fs_res *dst_res ;
  struct fs_res tmp_dst_res ;
  int res ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  time_t dst_a_s ;
  time_t dst_c_s ;
  time_t dst_m_s ;
  int dst_a_ns ;
  long tmp___4 ;
  int dst_c_ns ;
  long tmp___5 ;
  int dst_m_ns ;
  _Bool odd_second ;
  int a ;
  int c ;
  int m ;
  int SR10 ;
  struct timespec timespec[2] ;
  struct stat dst_status ;
  time_t s ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int stat_result ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int old_res ;
  int a___0 ;
  long tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  dst_s = (time_t )dst_stat->st_mtim.tv_sec;
  src_s = (time_t )src_stat->st_mtim.tv_sec;
  tmp = get_stat_mtime_ns(dst_stat);
  dst_ns = (int )tmp;
  tmp___0 = get_stat_mtime_ns(src_stat);
  src_ns = (int )tmp___0;
  if (options & 1) {
    dst_res = (struct fs_res *)((void *)0);
    if (dst_s == src_s) {
      if (dst_ns == src_ns) {
        return (0);
      }
    }
    if (dst_s <= src_s - 2L) {
      return (-1);
    }
    if (src_s <= dst_s - 2L) {
      return (1);
    }
    if (! ht) {
      ht = hash_initialize((size_t )16, (Hash_tuning const   *)((void *)0), & dev_info_hash,
                           & dev_info_compare, & free);
    }
    if (ht) {
      if (! new_dst_res) {
        tmp___1 = malloc(sizeof(*new_dst_res));
        new_dst_res = (struct fs_res *)tmp___1;
        if (! new_dst_res) {
          goto low_memory;
        }
        new_dst_res->resolution = 2000000000;
        new_dst_res->exact = (_Bool)0;
      }
      new_dst_res->dev = (dev_t )dst_stat->st_dev;
      tmp___2 = hash_insert(ht, (void const   *)new_dst_res);
      dst_res = (struct fs_res *)tmp___2;
      if (! dst_res) {
        goto low_memory;
      }
      if ((unsigned long )dst_res == (unsigned long )new_dst_res) {
        new_dst_res = (struct fs_res *)((void *)0);
      }
    } else {
      low_memory: 
      if (ht) {
        tmp_dst_res.dev = (dev_t )dst_stat->st_dev;
        tmp___3 = hash_lookup((Hash_table const   *)ht, (void const   *)(& tmp_dst_res));
        dst_res = (struct fs_res *)tmp___3;
      }
      if (! dst_res) {
        dst_res = & tmp_dst_res;
        dst_res->resolution = 2000000000;
        dst_res->exact = (_Bool)0;
      }
    }
    res = dst_res->resolution;
    if (! dst_res->exact) {
      dst_a_s = (time_t )dst_stat->st_atim.tv_sec;
      dst_c_s = (time_t )dst_stat->st_ctim.tv_sec;
      dst_m_s = dst_s;
      tmp___4 = get_stat_atime_ns(dst_stat);
      dst_a_ns = (int )tmp___4;
      tmp___5 = get_stat_ctime_ns(dst_stat);
      dst_c_ns = (int )tmp___5;
      dst_m_ns = dst_ns;
      odd_second = (_Bool )(((dst_a_s | dst_c_s) | dst_m_s) & 1L);
      a = dst_a_ns;
      c = dst_c_ns;
      m = dst_m_ns;
      SR10 = 1;
      SR10 *= 10;
      if (((a % SR10 | c % SR10) | m % SR10) != 0) {
        res = 1;
      } else {
        res = SR10;
        a /= SR10;
        c /= SR10;
        m /= SR10;
        while (1) {
          if (res < dst_res->resolution) {
            if (! (((a % 10 | c % 10) | m % 10) == 0)) {
              break;
            }
          } else {
            break;
          }
          if (res == 1000000000) {
            if (! odd_second) {
              res *= 2;
            }
            break;
          }
          res *= 10;
          a /= 10;
          c /= 10;
          m /= 10;
        }
      }
      dst_res->resolution = res;
      if (1 < res) {
        src_ns = src_ns;
        s = src_s & (long )(~ (res == 2000000000));
        if (src_s < dst_s) {
          return (1);
        } else
        if (src_s == dst_s) {
          if (src_ns <= dst_ns) {
            return (1);
          }
        }
        if (dst_s < s) {
          return (-1);
        } else
        if (dst_s == s) {
          if (dst_ns < src_ns - src_ns % res) {
            return (-1);
          }
        }
        timespec[0].tv_sec = dst_a_s;
        timespec[0].tv_nsec = (long )dst_a_ns;
        timespec[1].tv_sec = dst_m_s | (long )(res == 2000000000);
        timespec[1].tv_nsec = (long )(dst_m_ns + res / 9);
        if ((dst_stat->st_mode & 61440U) == 40960U) {
          tmp___6 = lutimens(dst_name, (struct timespec  const  *)(timespec));
          tmp___8 = tmp___6;
        } else {
          tmp___7 = utimens(dst_name, (struct timespec  const  *)(timespec));
          tmp___8 = tmp___7;
        }
        if (tmp___8 != 0) {
          return (-2);
        }
        if ((dst_stat->st_mode & 61440U) == 40960U) {
          tmp___9 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_status));
          tmp___11 = tmp___9;
        } else {
          tmp___10 = stat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_status));
          tmp___11 = tmp___10;
        }
        stat_result = tmp___11;
        tmp___12 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
        if (((long )stat_result | (dst_status.st_mtim.tv_sec ^ dst_m_s)) | (tmp___12 ^ (long )dst_m_ns)) {
          timespec[1].tv_sec = dst_m_s;
          timespec[1].tv_nsec = (long )dst_m_ns;
          if ((dst_stat->st_mode & 61440U) == 40960U) {
            lutimens(dst_name, (struct timespec  const  *)(timespec));
          } else {
            utimens(dst_name, (struct timespec  const  *)(timespec));
          }
        }
        if (stat_result != 0) {
          return (-2);
        }
        old_res = res;
        tmp___13 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
        a___0 = (int )(1000000000L * (dst_status.st_mtim.tv_sec & 1L) + tmp___13);
        res = 1;
        a___0 /= res;
        while (a___0 % 10 == 0) {
          if (res == 1000000000) {
            res *= 2;
            break;
          }
          res *= 10;
          if (res == old_res) {
            break;
          }
          a___0 /= 10;
        }
      }
      dst_res->resolution = res;
      dst_res->exact = (_Bool)1;
    }
    src_s &= (long )(~ (res == 2000000000));
    src_ns -= src_ns % res;
  }
  if (dst_s < src_s) {
    tmp___16 = -1;
  } else {
    if (dst_s > src_s) {
      tmp___15 = 1;
    } else {
      if (dst_ns < src_ns) {
        tmp___14 = -1;
      } else {
        tmp___14 = dst_ns > src_ns;
      }
      tmp___15 = tmp___14;
    }
    tmp___16 = tmp___15;
  }
  return (tmp___16);
}
}
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec  const  *__times ,
                                                   int __flags )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec  const  *__times ) ;
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval  const  *__tvp )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval  const  *__tvp ) ;
__inline static struct timespec get_stat_atime(struct stat  const  *st ) 
{ 

  {
  return ((struct timespec )st->st_atim);
}
}
__inline static struct timespec get_stat_mtime(struct stat  const  *st ) 
{ 

  {
  return ((struct timespec )st->st_mtim);
}
}
static int utimensat_works_really  ;
static int lutimensat_works_really  ;
static int validate_timespec(struct timespec *timespec ) 
{ int result ;
  int utime_omit_count ;
  int *tmp ;

  {
  result = 0;
  utime_omit_count = 0;
  if (! timespec) {
    __assert_fail("timespec", "utimens.c", 89U, "validate_timespec");
  }
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
      if ((timespec + 0)->tv_nsec < 0L) {
        tmp = __errno_location();
        *tmp = 22;
        return (-1);
      } else
      if (1000000000L <= (timespec + 0)->tv_nsec) {
        tmp = __errno_location();
        *tmp = 22;
        return (-1);
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else
  _L___0: 
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
      if ((timespec + 1)->tv_nsec < 0L) {
        tmp = __errno_location();
        *tmp = 22;
        return (-1);
      } else
      if (1000000000L <= (timespec + 1)->tv_nsec) {
        tmp = __errno_location();
        *tmp = 22;
        return (-1);
      }
    }
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    goto _L___1;
  } else
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    _L___1: 
    (timespec + 0)->tv_sec = (__time_t )0;
    result = 1;
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
      utime_omit_count ++;
    }
  }
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    goto _L___2;
  } else
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    _L___2: 
    (timespec + 1)->tv_sec = (__time_t )0;
    result = 1;
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
      utime_omit_count ++;
    }
  }
  return (result + (utime_omit_count == 1));
}
}
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ struct timespec *timespec ;

  {
  timespec = *ts;
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
      return ((_Bool)1);
    }
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
      *ts = (struct timespec *)((void *)0);
      return ((_Bool)0);
    }
  }
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    *(timespec + 0) = get_stat_atime(statbuf);
  } else
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    gettime(timespec + 0);
  }
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    *(timespec + 1) = get_stat_mtime(statbuf);
  } else
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    gettime(timespec + 1);
  }
  return ((_Bool)0);
}
}
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int tmp___12 ;
  _Bool abig ;
  _Bool mbig ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  if (timespec) {
    tmp = adjusted_timespec;
  } else {
    tmp = (struct timespec *)((void *)0);
  }
  ts = tmp;
  adjustment_needed = 0;
  if (ts) {
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
    adjustment_needed = validate_timespec(ts);
  }
  if (adjustment_needed < 0) {
    return (-1);
  }
  if (fd < 0) {
    if (! file) {
      tmp___0 = __errno_location();
      *tmp___0 = 9;
      return (-1);
    }
  }
  if (0 <= utimensat_works_really) {
    if (adjustment_needed == 2) {
      if (fd < 0) {
        tmp___1 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
        tmp___3 = tmp___1;
      } else {
        tmp___2 = fstat(fd, & st);
        tmp___3 = tmp___2;
      }
      if (tmp___3) {
        return (-1);
      }
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
      } else
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
      }
      adjustment_needed ++;
    }
    if (fd < 0) {
      result = utimensat(-100, file, (struct timespec  const  *)ts, 0);
      if (0 < result) {
        tmp___4 = __errno_location();
        *tmp___4 = 38;
      }
      if (result == 0) {
        utimensat_works_really = 1;
        return (result);
      } else {
        tmp___5 = __errno_location();
        if (*tmp___5 != 38) {
          utimensat_works_really = 1;
          return (result);
        }
      }
    }
    if (0 <= fd) {
      result = futimens(fd, (struct timespec  const  *)ts);
      if (0 < result) {
        tmp___6 = __errno_location();
        *tmp___6 = 38;
      }
      if (result == 0) {
        utimensat_works_really = 1;
        return (result);
      } else {
        tmp___7 = __errno_location();
        if (*tmp___7 != 38) {
          utimensat_works_really = 1;
          return (result);
        }
      }
    }
  }
  utimensat_works_really = -1;
  lutimensat_works_really = -1;
  if (adjustment_needed) {
    goto _L;
  } else
  if (0) {
    _L: 
    if (adjustment_needed != 3) {
      if (fd < 0) {
        tmp___8 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
        tmp___10 = tmp___8;
      } else {
        tmp___9 = fstat(fd, & st);
        tmp___10 = tmp___9;
      }
      if (tmp___10) {
        return (-1);
      }
    }
    if (ts) {
      tmp___11 = update_timespec((struct stat  const  *)(& st), & ts);
      if (tmp___11) {
        return (0);
      }
    }
  }
  if (ts) {
    timeval[0].tv_sec = (ts + 0)->tv_sec;
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
    timeval[1].tv_sec = (ts + 1)->tv_sec;
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
    t = timeval;
  } else {
    t = (struct timeval *)((void *)0);
  }
  if (fd < 0) {
    tmp___12 = futimesat(-100, file, (struct timeval  const  *)t);
    return (tmp___12);
  } else {
    tmp___16 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
    if (tmp___16 == 0) {
      if (t) {
        abig = (_Bool )(500000L <= (t + 0)->tv_usec);
        mbig = (_Bool )(500000L <= (t + 1)->tv_usec);
        if ((int )abig | (int )mbig) {
          tmp___15 = fstat(fd, & st);
          if (tmp___15 == 0) {
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
            tt = (struct timeval *)((void *)0);
            truncated_timeval[0] = *(t + 0);
            truncated_timeval[1] = *(t + 1);
            if (abig) {
              if (adiff == 1L) {
                tmp___13 = get_stat_atime_ns((struct stat  const  *)(& st));
                if (tmp___13 == 0L) {
                  tt = truncated_timeval;
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                }
              }
            }
            if (mbig) {
              if (mdiff == 1L) {
                tmp___14 = get_stat_mtime_ns((struct stat  const  *)(& st));
                if (tmp___14 == 0L) {
                  tt = truncated_timeval;
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                }
              }
            }
            if (tt) {
              futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)tt);
            }
          }
        }
      }
      return (0);
    }
  }
  if (! file) {
    return (-1);
  }
  tmp___17 = utimes(file, (struct timeval  const  *)t);
  return (tmp___17);
}
}
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ int tmp ;

  {
  tmp = fdutimens(-1, file, timespec);
  return (tmp);
}
}
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
  if (timespec) {
    tmp = adjusted_timespec;
  } else {
    tmp = (struct timespec *)((void *)0);
  }
  ts = tmp;
  adjustment_needed = 0;
  if (ts) {
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
    adjustment_needed = validate_timespec(ts);
  }
  if (adjustment_needed < 0) {
    return (-1);
  }
  if (0 <= lutimensat_works_really) {
    if (adjustment_needed == 2) {
      tmp___0 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
      if (tmp___0) {
        return (-1);
      }
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        *(ts + 0) = get_stat_atime((struct stat  const  *)(& st));
      } else
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        *(ts + 1) = get_stat_mtime((struct stat  const  *)(& st));
      }
      adjustment_needed ++;
    }
    result = utimensat(-100, file, (struct timespec  const  *)ts, 256);
    if (0 < result) {
      tmp___1 = __errno_location();
      *tmp___1 = 38;
    }
    if (result == 0) {
      utimensat_works_really = 1;
      lutimensat_works_really = 1;
      return (result);
    } else {
      tmp___2 = __errno_location();
      if (*tmp___2 != 38) {
        utimensat_works_really = 1;
        lutimensat_works_really = 1;
        return (result);
      }
    }
  }
  lutimensat_works_really = -1;
  if (adjustment_needed) {
    goto _L;
  } else
  if (0) {
    _L: 
    if (adjustment_needed != 3) {
      tmp___3 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
      if (tmp___3) {
        return (-1);
      }
    }
    if (ts) {
      tmp___4 = update_timespec((struct stat  const  *)(& st), & ts);
      if (tmp___4) {
        return (0);
      }
    }
  }
  if (! adjustment_needed) {
    tmp___5 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
    if (tmp___5) {
      return (-1);
    }
  }
  if (! ((st.st_mode & 61440U) == 40960U)) {
    tmp___6 = fdutimens(-1, file, (struct timespec  const  *)ts);
    return (tmp___6);
  }
  tmp___7 = __errno_location();
  *tmp___7 = 38;
  return (-1);
}
}
extern void error_at_line(int __status , int __errnum , char const   *__fname , unsigned int __lineno ,
                          char const   *__format  , ...) ;
void verror(int status , int errnum , char const   *format , va_list args ) ;
void verror_at_line(int status , int errnum , char const   *file , unsigned int line_number ,
                    char const   *format , va_list args ) ;
char *xvasprintf(char const   *format , va_list args ) ;
void verror(int status , int errnum , char const   *format , va_list args ) 
{ 

  {
  verror_at_line(status, errnum, (char const   *)((void *)0), 0U, format, args);
  return;
}
}
void verror_at_line(int status , int errnum , char const   *file , unsigned int line_number ,
                    char const   *format , va_list args ) 
{ char *message ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = xvasprintf(format, args);
  message = tmp;
  if (message) {
    if (file) {
      error_at_line(status, errnum, file, line_number, "%s", message);
    } else {
      error(status, errnum, "%s", message);
    }
  } else {
    tmp___0 = dcgettext((char const   *)((void *)0), "unable to display error message",
                        5);
    tmp___1 = __errno_location();
    error(0, *tmp___1, (char const   *)tmp___0);
    abort();
  }
  free((void *)message);
  return;
}
}
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
char const   version_etc_copyright[47] ;
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
void emit_bug_reporting_address(void) ;
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  if (command_name) {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s (%s) %s\n",
            command_name, package, version);
  } else {
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s %s\n", package,
            version);
  }
  tmp = dcgettext((char const   *)((void *)0), "(C)", 5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )(version_etc_copyright),
          tmp, 2011);
  tmp___0 = dcgettext((char const   *)((void *)0), "\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n",
                      5);
  fputs_unlocked((char const   * __restrict  )tmp___0, (FILE * __restrict  )stream);
  switch ((int )n_authors) {
  case 0: 
  abort();
  case 1: 
  tmp___1 = dcgettext((char const   *)((void *)0), "Written by %s.\n", 5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___1, *(authors + 0));
  break;
  case 2: 
  tmp___2 = dcgettext((char const   *)((void *)0), "Written by %s and %s.\n", 5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___2, *(authors + 0),
          *(authors + 1));
  break;
  case 3: 
  tmp___3 = dcgettext((char const   *)((void *)0), "Written by %s, %s, and %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___3, *(authors + 0),
          *(authors + 1), *(authors + 2));
  break;
  case 4: 
  tmp___4 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\nand %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___4, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3));
  break;
  case 5: 
  tmp___5 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, and %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___5, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  break;
  case 6: 
  tmp___6 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, and %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___6, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
  break;
  case 7: 
  tmp___7 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___7, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6));
  break;
  case 8: 
  tmp___8 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___8, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7));
  break;
  case 9: 
  tmp___9 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n",
                      5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___9, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7), *(authors + 8));
  break;
  default: 
  tmp___10 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
                       5);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___10, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7), *(authors + 8));
  break;
  }
  return;
}
}
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ size_t n_authors ;

  {
  n_authors = (size_t )0;
  while (*(authors + n_authors)) {
    n_authors ++;
  }
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  return;
}
}
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;

  {
  n_authors = (size_t )0;
  while (1) {
    if (n_authors < 10UL) {
      tmp = __builtin_va_arg(authors, char const   *);
      authtab[n_authors] = tmp;
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    n_authors ++;
  }
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  return;
}
}
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ va_list authors ;

  {
  __builtin_va_start(authors, version);
  version_etc_va(stream, command_name, package, version, authors);
  __builtin_va_end(authors);
  return;
}
}
void emit_bug_reporting_address(void) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = dcgettext((char const   *)((void *)0), "\nReport bugs to: %s\n", 5);
  printf((char const   * __restrict  )tmp, "bug-coreutils@gnu.org");
  tmp___0 = dcgettext((char const   *)((void *)0), "%s home page: <%s>\n", 5);
  printf((char const   * __restrict  )tmp___0, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  tmp___1 = dcgettext((char const   *)((void *)0), "General help using GNU software: <http://www.gnu.org/gethelp/>\n",
                      5);
  fputs_unlocked((char const   * __restrict  )tmp___1, (FILE * __restrict  )stdout);
  return;
}
}
char const   version_etc_copyright[47]  = 
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
_Bool can_write_any_file(void) ;
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
static _Bool initialized___0  ;
static _Bool can_write  ;
_Bool can_write_any_file(void) 
{ _Bool can ;
  __uid_t tmp ;

  {
  if (! initialized___0) {
    can = (_Bool)0;
    tmp = geteuid();
    can = (_Bool )(tmp == 0U);
    can_write = can;
    initialized___0 = (_Bool)1;
  }
  return (can_write);
}
}
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
void *xmalloc(size_t n ) 
{ void *p ;
  void *tmp ;

  {
  tmp = malloc(n);
  p = tmp;
  if (! p) {
    if (n != 0UL) {
      xalloc_die();
    }
  }
  return (p);
}
}
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
void *xrealloc(void *p , size_t n ) 
{ 

  {
  if (! n) {
    if (p) {
      free(p);
      return ((void *)0);
    }
  }
  p = realloc(p, n);
  if (! p) {
    if (n) {
      xalloc_die();
    }
  }
  return (p);
}
}
void *x2realloc(void *p , size_t *pn ) 
{ void *tmp ;

  {
  tmp = x2nrealloc(p, pn, (size_t )1);
  return (tmp);
}
}
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
void *xzalloc(size_t s ) 
{ void *tmp ;
  void __attribute__((__artificial__))  *tmp___0 ;

  {
  tmp = xmalloc(s);
  tmp___0 = memset(tmp, 0, s);
  return ((void *)tmp___0);
}
}
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
void *xcalloc(size_t n , size_t s ) 
{ void *p ;

  {
  p = calloc(n, s);
  if (! p) {
    xalloc_die();
  }
  return (p);
}
}
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__, __alloc_size__(2))) ;
void *xmemdup(void const   *p , size_t s ) 
{ void *tmp ;
  void __attribute__((__artificial__))  *tmp___0 ;

  {
  tmp = xmalloc(s);
  tmp___0 = memcpy((void * __restrict  )tmp, (void const   * __restrict  )p, s);
  return ((void *)tmp___0);
}
}
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
char *xstrdup(char const   *string ) 
{ size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(string);
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  return ((char *)tmp___0);
}
}
 __attribute__((__noreturn__)) void xalloc_die(void) ;
void xalloc_die(void) 
{ char *tmp ;

  {
  tmp = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
  error((int )exit_failure, 0, "%s", tmp);
  abort();
}
}
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) ;
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) 
{ char const   *f ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  FILE *tmp___11 ;

  {
  tmp___11 = freopen_safer(filename, mode, fp);
  if (! tmp___11) {
    if (filename) {
      tmp___6 = filename;
    } else {
      if ((unsigned long )fp == (unsigned long )stdin) {
        tmp = dcgettext((char const   *)((void *)0), "stdin", 5);
        tmp___5 = tmp;
      } else {
        if ((unsigned long )fp == (unsigned long )stdout) {
          tmp___0 = dcgettext((char const   *)((void *)0), "stdout", 5);
          tmp___4 = tmp___0;
        } else {
          if ((unsigned long )fp == (unsigned long )stderr) {
            tmp___1 = dcgettext((char const   *)((void *)0), "stderr", 5);
            tmp___3 = tmp___1;
          } else {
            tmp___2 = dcgettext((char const   *)((void *)0), "unknown stream", 5);
            tmp___3 = tmp___2;
          }
          tmp___4 = tmp___3;
        }
        tmp___5 = tmp___4;
      }
      tmp___6 = (char const   *)tmp___5;
    }
    f = tmp___6;
    tmp___7 = quote_n(1, mode);
    tmp___8 = quote_n(0, f);
    tmp___9 = dcgettext((char const   *)((void *)0), "failed to reopen %s with mode %s",
                        5);
    tmp___10 = __errno_location();
    error((int )exit_failure, *tmp___10, (char const   *)tmp___9, tmp___8, tmp___7);
  }
  return;
}
}
char *xgetcwd(void) 
{ char *cwd ;
  char *tmp ;
  int *tmp___0 ;

  {
  tmp = rpl_getcwd((char *)((void *)0), (size_t )0);
  cwd = tmp;
  if (! cwd) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
  }
  return (cwd);
}
}
int xgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
int xgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ int result ;
  int tmp ;
  int *tmp___0 ;

  {
  tmp = mgetgroups(username, gid, groups);
  result = tmp;
  if (result == -1) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
  }
  return (result);
}
}
char *xgethostname(void) ;
char *xgethostname(void) 
{ char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int __attribute__((__artificial__))  tmp___7 ;

  {
  hostname = (char *)((void *)0);
  size = (size_t )34;
  while (1) {
    tmp = x2realloc((void *)hostname, & size);
    hostname = (char *)tmp;
    size_1 = size - 1UL;
    *(hostname + (size_1 - 1UL)) = (char )'\000';
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    tmp___7 = gethostname(hostname, size_1);
    if (tmp___7 == (int __attribute__((__artificial__))  )0) {
      if (! *(hostname + (size_1 - 1UL))) {
        break;
      }
    } else {
      tmp___3 = __errno_location();
      if (*tmp___3 != 0) {
        tmp___4 = __errno_location();
        if (*tmp___4 != 36) {
          tmp___5 = __errno_location();
          if (*tmp___5 != 22) {
            tmp___6 = __errno_location();
            if (*tmp___6 != 12) {
              tmp___1 = __errno_location();
              saved_errno = *tmp___1;
              free((void *)hostname);
              tmp___2 = __errno_location();
              *tmp___2 = saved_errno;
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
  return (hostname);
}
}
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
int xmemcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) ;
static void collate_error(int collation_errno , char const   *s1 , size_t s1len ,
                          char const   *s2 , size_t s2len ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  tmp = dcgettext((char const   *)((void *)0), "string comparison failed", 5);
  error(0, collation_errno, (char const   *)tmp);
  tmp___0 = dcgettext((char const   *)((void *)0), "Set LC_ALL=\'C\' to work around the problem.",
                      5);
  error(0, 0, (char const   *)tmp___0);
  tmp___1 = quotearg_n_style_mem(1, (enum quoting_style )6, s2, s2len);
  tmp___2 = quotearg_n_style_mem(0, (enum quoting_style )6, s1, s1len);
  tmp___3 = dcgettext((char const   *)((void *)0), "The strings compared were %s and %s.",
                      5);
  error((int )exit_failure, 0, (char const   *)tmp___3, tmp___2, tmp___1);
  return;
}
}
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;

  {
  tmp = memcoll(s1, s1len, s2, s2len);
  diff = tmp;
  tmp___0 = __errno_location();
  collation_errno = *tmp___0;
  if (collation_errno) {
    collate_error(collation_errno, (char const   *)s1, s1len, (char const   *)s2,
                  s2len);
  }
  return (diff);
}
}
int xmemcoll0(char const   *s1 , size_t s1size , char const   *s2 , size_t s2size ) 
{ int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;

  {
  tmp = memcoll0(s1, s1size, s2, s2size);
  diff = tmp;
  tmp___0 = __errno_location();
  collation_errno = *tmp___0;
  if (collation_errno) {
    collate_error(collation_errno, s1, s1size - 1UL, s2, s2size - 1UL);
  }
  return (diff);
}
}
int xnanosleep(double seconds ) ;
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay )  __attribute__((__nonnull__(1))) ;
int xnanosleep(double seconds ) 
{ struct timespec ts_sleep ;
  struct timespec tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  tmp = dtotimespec(seconds);
  ts_sleep = tmp;
  while (1) {
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    tmp___1 = rpl_nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
    if (tmp___1 == 0) {
      break;
    }
    tmp___2 = __errno_location();
    if (*tmp___2 != 4) {
      tmp___3 = __errno_location();
      if (*tmp___3 != 0) {
        return (-1);
      }
    }
  }
  return (0);
}
}
int rpl_vfprintf(FILE *fp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
int rpl_vprintf(char const   *format , va_list args )  __attribute__((__nonnull__(1))) ;
int xprintf(char const   * __restrict  format  , ...) ;
int xvprintf(char const   * __restrict  format , va_list args ) ;
int xfprintf(FILE * __restrict  stream , char const   * __restrict  format  , ...) ;
int xvfprintf(FILE * __restrict  stream , char const   * __restrict  format , va_list args ) ;
int xprintf(char const   * __restrict  format  , ...) 
{ va_list args ;
  int retval ;

  {
  __builtin_va_start(args, format);
  retval = xvprintf(format, args);
  __builtin_va_end(args);
  return (retval);
}
}
int xvprintf(char const   * __restrict  format , va_list args ) 
{ int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp = rpl_vprintf((char const   *)format, args);
  retval = tmp;
  if (retval < 0) {
    tmp___2 = ferror(stdout);
    if (! tmp___2) {
      tmp___0 = dcgettext((char const   *)((void *)0), "cannot perform formatted output",
                          5);
      tmp___1 = __errno_location();
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
    }
  }
  return (retval);
}
}
int xfprintf(FILE * __restrict  stream , char const   * __restrict  format  , ...) 
{ va_list args ;
  int retval ;

  {
  __builtin_va_start(args, format);
  retval = xvfprintf(stream, format, args);
  __builtin_va_end(args);
  return (retval);
}
}
int xvfprintf(FILE * __restrict  stream , char const   * __restrict  format , va_list args ) 
{ int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp = rpl_vfprintf((FILE *)stream, (char const   *)format, args);
  retval = tmp;
  if (retval < 0) {
    tmp___2 = ferror((FILE *)stream);
    if (! tmp___2) {
      tmp___0 = dcgettext((char const   *)((void *)0), "cannot perform formatted output",
                          5);
      tmp___1 = __errno_location();
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
    }
  }
  return (retval);
}
}
char *xreadlink(char const   *filename ) ;
char *xreadlink(char const   *filename ) 
{ char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  tmp = areadlink(filename);
  result = tmp;
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
  }
  return (result);
}
}
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ int retval ;
  int tmp ;
  int *tmp___0 ;

  {
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
  retval = tmp;
  if (retval < 0) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
  }
  return (retval);
}
}
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  tmp = str_cd_iconv(src, cd);
  result = tmp;
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
  }
  return (result);
}
}
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  tmp = str_iconv(src, from_codeset, to_codeset);
  result = tmp;
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
  }
  return (result);
}
}
extern  __attribute__((__nothrow__)) char *__strndup(char const   *__string , size_t __n )  __attribute__((__malloc__)) ;
char *xstrndup(char const   *string , size_t n ) 
{ char *s ;
  char *tmp___4 ;

  {
  tmp___4 = __strndup(string, n);
  s = tmp___4;
  if (! s) {
    xalloc_die();
  }
  return (s);
}
}
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) ;
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) 
{ double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
  ok = (_Bool)1;
  tmp = __errno_location();
  *tmp = 0;
  val = (*convert)(str, & terminator);
  if ((unsigned long )terminator == (unsigned long )str) {
    ok = (_Bool)0;
  } else
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    if ((int )*terminator != 0) {
      ok = (_Bool)0;
    } else {
      goto _L;
    }
  } else
  _L: 
  if (val != (double )0) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 34) {
      ok = (_Bool)0;
    }
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    *ptr = (char const   *)terminator;
  }
  *result = val;
  return (ok);
}
}
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
static strtol_error bkm_scale(intmax_t *x , int scale_factor ) 
{ 

  {
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
    *x = (-0x7FFFFFFFFFFFFFFF-1);
    return ((strtol_error )1);
  }
  if (9223372036854775807L / (long )scale_factor < *x) {
    *x = 9223372036854775807L;
    return ((strtol_error )1);
  }
  *x *= (intmax_t )scale_factor;
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power(intmax_t *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
  err = (strtol_error )0;
  while (1) {
    tmp___0 = power;
    power --;
    if (! tmp___0) {
      break;
    }
    tmp = bkm_scale(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
  return (err);
}
}
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
  err = (strtol_error )0;
  if (0 <= strtol_base) {
    if (! (strtol_base <= 36)) {
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoimax");
    }
  } else {
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoimax");
  }
  if (ptr) {
    p = ptr;
  } else {
    p = & t_ptr;
  }
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtoimax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
  if ((unsigned long )*p == (unsigned long )s) {
    if (valid_suffixes) {
      if (*(*p)) {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        if (tmp___3) {
          tmp = (intmax_t )1;
        } else {
          return ((strtol_error )4);
        }
      } else {
        return ((strtol_error )4);
      }
    } else {
      return ((strtol_error )4);
    }
  } else {
    tmp___5 = __errno_location();
    if (*tmp___5 != 0) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 34) {
        return ((strtol_error )4);
      }
      err = (strtol_error )1;
    }
  }
  if (! valid_suffixes) {
    *val = tmp;
    return (err);
  }
  if ((int )*(*p) != 0) {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    if (! tmp___7) {
      *val = tmp;
      return ((strtol_error )((unsigned int )err | 2U));
    }
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    if (tmp___9) {
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
      if ((int )*(*(p + 0) + 2) == 66) {
        suffixes += 2;
      }
      break;
      case 66: 
      case 68: 
      base = 1000;
      suffixes ++;
      break;
      }
    }
    switch ((int )*(*p)) {
    case 98: 
    overflow = bkm_scale(& tmp, 512);
    break;
    case 66: 
    overflow = bkm_scale(& tmp, 1024);
    break;
    case 99: 
    overflow = (strtol_error )0;
    break;
    case 69: 
    overflow = bkm_scale_by_power(& tmp, base, 6);
    break;
    case 71: 
    case 103: 
    overflow = bkm_scale_by_power(& tmp, base, 3);
    break;
    case 107: 
    case 75: 
    overflow = bkm_scale_by_power(& tmp, base, 1);
    break;
    case 77: 
    case 109: 
    overflow = bkm_scale_by_power(& tmp, base, 2);
    break;
    case 80: 
    overflow = bkm_scale_by_power(& tmp, base, 5);
    break;
    case 84: 
    case 116: 
    overflow = bkm_scale_by_power(& tmp, base, 4);
    break;
    case 119: 
    overflow = bkm_scale(& tmp, 2);
    break;
    case 89: 
    overflow = bkm_scale_by_power(& tmp, base, 8);
    break;
    case 90: 
    overflow = bkm_scale_by_power(& tmp, base, 7);
    break;
    default: 
    *val = tmp;
    return ((strtol_error )((unsigned int )err | 2U));
    }
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    if (*(*p)) {
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
  *val = tmp;
  return (err);
}
}
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
static strtol_error bkm_scale___0(long *x , int scale_factor ) 
{ 

  {
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
    *x = (-0x7FFFFFFFFFFFFFFF-1);
    return ((strtol_error )1);
  }
  if (9223372036854775807L / (long )scale_factor < *x) {
    *x = 9223372036854775807L;
    return ((strtol_error )1);
  }
  *x *= (long )scale_factor;
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
  err = (strtol_error )0;
  while (1) {
    tmp___0 = power;
    power --;
    if (! tmp___0) {
      break;
    }
    tmp = bkm_scale___0(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
  return (err);
}
}
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
  err = (strtol_error )0;
  if (0 <= strtol_base) {
    if (! (strtol_base <= 36)) {
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtol");
    }
  } else {
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtol");
  }
  if (ptr) {
    p = ptr;
  } else {
    p = & t_ptr;
  }
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtol((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
  if ((unsigned long )*p == (unsigned long )s) {
    if (valid_suffixes) {
      if (*(*p)) {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        if (tmp___3) {
          tmp = 1L;
        } else {
          return ((strtol_error )4);
        }
      } else {
        return ((strtol_error )4);
      }
    } else {
      return ((strtol_error )4);
    }
  } else {
    tmp___5 = __errno_location();
    if (*tmp___5 != 0) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 34) {
        return ((strtol_error )4);
      }
      err = (strtol_error )1;
    }
  }
  if (! valid_suffixes) {
    *val = tmp;
    return (err);
  }
  if ((int )*(*p) != 0) {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    if (! tmp___7) {
      *val = tmp;
      return ((strtol_error )((unsigned int )err | 2U));
    }
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    if (tmp___9) {
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
      if ((int )*(*(p + 0) + 2) == 66) {
        suffixes += 2;
      }
      break;
      case 66: 
      case 68: 
      base = 1000;
      suffixes ++;
      break;
      }
    }
    switch ((int )*(*p)) {
    case 98: 
    overflow = bkm_scale___0(& tmp, 512);
    break;
    case 66: 
    overflow = bkm_scale___0(& tmp, 1024);
    break;
    case 99: 
    overflow = (strtol_error )0;
    break;
    case 69: 
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    break;
    case 71: 
    case 103: 
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    break;
    case 107: 
    case 75: 
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    break;
    case 77: 
    case 109: 
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    break;
    case 80: 
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    break;
    case 84: 
    case 116: 
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    break;
    case 119: 
    overflow = bkm_scale___0(& tmp, 2);
    break;
    case 89: 
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    break;
    case 90: 
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    break;
    default: 
    *val = tmp;
    return ((strtol_error )((unsigned int )err | 2U));
    }
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    if (*(*p)) {
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
  *val = tmp;
  return (err);
}
}
static strtol_error bkm_scale___1(unsigned long *x , int scale_factor ) 
{ 

  {
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
    *x = 0xffffffffffffffffUL;
    return ((strtol_error )1);
  }
  *x *= (unsigned long )scale_factor;
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power___1(unsigned long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
  err = (strtol_error )0;
  while (1) {
    tmp___0 = power;
    power --;
    if (! tmp___0) {
      break;
    }
    tmp = bkm_scale___1(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
  return (err);
}
}
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
  err = (strtol_error )0;
  if (0 <= strtol_base) {
    if (! (strtol_base <= 36)) {
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoul");
    }
  } else {
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoul");
  }
  if (ptr) {
    p = ptr;
  } else {
    p = & t_ptr;
  }
  q = s;
  ch = (unsigned char )*q;
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
      break;
    }
    q ++;
    ch = (unsigned char )*q;
  }
  if ((int )ch == 45) {
    return ((strtol_error )4);
  }
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtoul((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
  if ((unsigned long )*p == (unsigned long )s) {
    if (valid_suffixes) {
      if (*(*p)) {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        if (tmp___3) {
          tmp = 1UL;
        } else {
          return ((strtol_error )4);
        }
      } else {
        return ((strtol_error )4);
      }
    } else {
      return ((strtol_error )4);
    }
  } else {
    tmp___5 = __errno_location();
    if (*tmp___5 != 0) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 34) {
        return ((strtol_error )4);
      }
      err = (strtol_error )1;
    }
  }
  if (! valid_suffixes) {
    *val = tmp;
    return (err);
  }
  if ((int )*(*p) != 0) {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    if (! tmp___7) {
      *val = tmp;
      return ((strtol_error )((unsigned int )err | 2U));
    }
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    if (tmp___9) {
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
      if ((int )*(*(p + 0) + 2) == 66) {
        suffixes += 2;
      }
      break;
      case 66: 
      case 68: 
      base = 1000;
      suffixes ++;
      break;
      }
    }
    switch ((int )*(*p)) {
    case 98: 
    overflow = bkm_scale___1(& tmp, 512);
    break;
    case 66: 
    overflow = bkm_scale___1(& tmp, 1024);
    break;
    case 99: 
    overflow = (strtol_error )0;
    break;
    case 69: 
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    break;
    case 71: 
    case 103: 
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    break;
    case 107: 
    case 75: 
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    break;
    case 77: 
    case 109: 
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    break;
    case 80: 
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    break;
    case 84: 
    case 116: 
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    break;
    case 119: 
    overflow = bkm_scale___1(& tmp, 2);
    break;
    case 89: 
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    break;
    case 90: 
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    break;
    default: 
    *val = tmp;
    return ((strtol_error )((unsigned int )err | 2U));
    }
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    if (*(*p)) {
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
  *val = tmp;
  return (err);
}
}
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options___1 ,
                                                  char const   *arg ) ;
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options___1 ,
                          char const   *arg , int exit_status___0 ) 
{ char const   *hyphens ;
  char const   *msgid ;
  char const   *rpl_option ;
  char option_buffer[2] ;
  char *tmp ;

  {
  hyphens = "--";
  switch ((int )err) {
  default: 
  abort();
  case 4: 
  msgid = "invalid %s%s argument `%s\'";
  break;
  case 2: 
  case 3: 
  msgid = "invalid suffix in %s%s argument `%s\'";
  break;
  case 1: 
  msgid = "%s%s argument `%s\' too large";
  break;
  }
  if (opt_idx < 0) {
    hyphens -= opt_idx;
    option_buffer[0] = c;
    option_buffer[1] = (char )'\000';
    rpl_option = (char const   *)(option_buffer);
  } else {
    rpl_option = (char const   *)(long_options___1 + opt_idx)->name;
  }
  tmp = dcgettext((char const   *)((void *)0), msgid, 5);
  error(exit_status___0, 0, (char const   *)tmp, hyphens, rpl_option, arg);
  return;
}
}
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options___1 ,
                                                  char const   *arg ) ;
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options___1 ,
                   char const   *arg ) 
{ 

  {
  xstrtol_error(err, opt_idx, c, long_options___1, arg, (int )exit_failure);
  abort();
}
}
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) ;
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) 
{ long double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
  ok = (_Bool)1;
  tmp = __errno_location();
  *tmp = 0;
  val = (*convert)(str, & terminator);
  if ((unsigned long )terminator == (unsigned long )str) {
    ok = (_Bool)0;
  } else
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    if ((int )*terminator != 0) {
      ok = (_Bool)0;
    } else {
      goto _L;
    }
  } else
  _L: 
  if (val != (long double )0) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 34) {
      ok = (_Bool)0;
    }
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    *ptr = (char const   *)terminator;
  }
  *result = val;
  return (ok);
}
}
static strtol_error bkm_scale___2(uintmax_t *x , int scale_factor ) 
{ 

  {
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
    *x = 0xffffffffffffffffUL;
    return ((strtol_error )1);
  }
  *x *= (uintmax_t )scale_factor;
  return ((strtol_error )0);
}
}
static strtol_error bkm_scale_by_power___2(uintmax_t *x , int base , int power ) 
{ strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
  err = (strtol_error )0;
  while (1) {
    tmp___0 = power;
    power --;
    if (! tmp___0) {
      break;
    }
    tmp = bkm_scale___2(x, base);
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
  return (err);
}
}
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___7 ;
  char *tmp___9 ;

  {
  err = (strtol_error )0;
  if (0 <= strtol_base) {
    if (! (strtol_base <= 36)) {
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoumax");
    }
  } else {
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83U, "xstrtoumax");
  }
  if (ptr) {
    p = ptr;
  } else {
    p = & t_ptr;
  }
  q = s;
  ch = (unsigned char )*q;
  while (1) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
      break;
    }
    q ++;
    ch = (unsigned char )*q;
  }
  if ((int )ch == 45) {
    return ((strtol_error )4);
  }
  tmp___1 = __errno_location();
  *tmp___1 = 0;
  tmp = strtoumax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
  if ((unsigned long )*p == (unsigned long )s) {
    if (valid_suffixes) {
      if (*(*p)) {
        tmp___3 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
        if (tmp___3) {
          tmp = (uintmax_t )1;
        } else {
          return ((strtol_error )4);
        }
      } else {
        return ((strtol_error )4);
      }
    } else {
      return ((strtol_error )4);
    }
  } else {
    tmp___5 = __errno_location();
    if (*tmp___5 != 0) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 34) {
        return ((strtol_error )4);
      }
      err = (strtol_error )1;
    }
  }
  if (! valid_suffixes) {
    *val = tmp;
    return (err);
  }
  if ((int )*(*p) != 0) {
    base = 1024;
    suffixes = 1;
    tmp___7 = __builtin_strchr((char *)valid_suffixes, (int )*(*p));
    if (! tmp___7) {
      *val = tmp;
      return ((strtol_error )((unsigned int )err | 2U));
    }
    tmp___9 = __builtin_strchr((char *)valid_suffixes, '0');
    if (tmp___9) {
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
      if ((int )*(*(p + 0) + 2) == 66) {
        suffixes += 2;
      }
      break;
      case 66: 
      case 68: 
      base = 1000;
      suffixes ++;
      break;
      }
    }
    switch ((int )*(*p)) {
    case 98: 
    overflow = bkm_scale___2(& tmp, 512);
    break;
    case 66: 
    overflow = bkm_scale___2(& tmp, 1024);
    break;
    case 99: 
    overflow = (strtol_error )0;
    break;
    case 69: 
    overflow = bkm_scale_by_power___2(& tmp, base, 6);
    break;
    case 71: 
    case 103: 
    overflow = bkm_scale_by_power___2(& tmp, base, 3);
    break;
    case 107: 
    case 75: 
    overflow = bkm_scale_by_power___2(& tmp, base, 1);
    break;
    case 77: 
    case 109: 
    overflow = bkm_scale_by_power___2(& tmp, base, 2);
    break;
    case 80: 
    overflow = bkm_scale_by_power___2(& tmp, base, 5);
    break;
    case 84: 
    case 116: 
    overflow = bkm_scale_by_power___2(& tmp, base, 4);
    break;
    case 119: 
    overflow = bkm_scale___2(& tmp, 2);
    break;
    case 89: 
    overflow = bkm_scale_by_power___2(& tmp, base, 8);
    break;
    case 90: 
    overflow = bkm_scale_by_power___2(& tmp, base, 7);
    break;
    default: 
    *val = tmp;
    return ((strtol_error )((unsigned int )err | 2U));
    }
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
    *p += suffixes;
    if (*(*p)) {
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
  *val = tmp;
  return (err);
}
}
int rpl_vasprintf(char **resultp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ size_t sum ;
  size_t tmp ;

  {
  sum = size1 + size2;
  if (sum >= size1) {
    tmp = sum;
  } else {
    tmp = 0xffffffffffffffffUL;
  }
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *next___0 ;
  char const   *tmp___6 ;
  size_t len ;
  size_t tmp___7 ;

  {
  totalsize = (size_t )0;
  __builtin_va_copy(ap, args);
  i = argcount;
  while (i > 0UL) {
    tmp = __builtin_va_arg(ap, char const   *);
    next = tmp;
    tmp___0 = strlen(next);
    tmp___1 = xsum(totalsize, tmp___0);
    totalsize = (size_t )tmp___1;
    i --;
  }
  __builtin_va_end(ap);
  if (totalsize == 0xffffffffffffffffUL) {
    tmp___2 = __errno_location();
    *tmp___2 = 75;
    return ((char *)((void *)0));
  } else
  if (totalsize > 2147483647UL) {
    tmp___2 = __errno_location();
    *tmp___2 = 75;
    return ((char *)((void *)0));
  }
  if (sizeof(char ) == 1UL) {
    tmp___3 = xmalloc(totalsize + 1UL);
    tmp___5 = tmp___3;
  } else {
    tmp___4 = xnmalloc(totalsize + 1UL, sizeof(char ));
    tmp___5 = tmp___4;
  }
  result = (char *)tmp___5;
  p = result;
  i = argcount;
  while (i > 0UL) {
    tmp___6 = __builtin_va_arg(args, char const   *);
    next___0 = tmp___6;
    tmp___7 = strlen(next___0);
    len = tmp___7;
    memcpy((void * __restrict  )p, (void const   * __restrict  )next___0, len);
    p += len;
    i --;
  }
  *p = (char )'\000';
  return (result);
}
}
char *xvasprintf(char const   *format , va_list args ) 
{ char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  argcount = (size_t )0;
  f = format;
  while (1) {
    if ((int const   )*f == 0) {
      tmp = xstrcat(argcount, args);
      return (tmp);
    }
    if ((int const   )*f != 37) {
      break;
    }
    f ++;
    if ((int const   )*f != 115) {
      break;
    }
    f ++;
    argcount ++;
  }
  tmp___1 = rpl_vasprintf(& result, format, args);
  if (tmp___1 < 0) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 12) {
      xalloc_die();
    }
    return ((char *)((void *)0));
  }
  return (result);
}
}
char *xasprintf(char const   *format  , ...) ;
char *xasprintf(char const   *format  , ...) 
{ va_list args ;
  char *result ;

  {
  __builtin_va_start(args, format);
  result = xvasprintf(format, args);
  __builtin_va_end(args);
  return (result);
}
}
_Bool yesno(void) ;
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response )  __attribute__((__warn_unused_result__,
__nonnull__(1))) ;
_Bool yesno(void) 
{ _Bool yes ;
  char *response ;
  size_t response_size ;
  ssize_t response_len ;
  __ssize_t tmp ;
  int tmp___0 ;

  {
  response = (char *)((void *)0);
  response_size = (size_t )0;
  tmp = getline((char ** __restrict  )(& response), (size_t * __restrict  )(& response_size),
                (FILE * __restrict  )stdin);
  response_len = tmp;
  if (response_len <= 0L) {
    yes = (_Bool)0;
  } else {
    *(response + (response_len - 1L)) = (char )'\000';
    tmp___0 = rpmatch((char const   *)response);
    yes = (_Bool )(0 < tmp___0);
  }
  free((void *)response);
  return (yes);
}
}
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max )  __attribute__((__const__)) ;
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max )  __attribute__((__const__)) ;
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) 
{ size_t size ;
  size_t lcm ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;
  size_t tmp ;

  {
  if (! a) {
    if (b) {
      size = b;
    } else {
      size = (size_t )8192;
    }
  } else {
    if (b) {
      m = a;
      n = b;
      while (1) {
        r = m % n;
        if (! (r != 0UL)) {
          break;
        }
        goto __Cont;
        __Cont: 
        m = n;
        n = r;
      }
      q = a / n;
      lcm = q * b;
      if (lcm <= lcm_max) {
        if (lcm / b == q) {
          return (lcm);
        }
      }
    }
    size = a;
  }
  if (size <= lcm_max) {
    tmp = size;
  } else {
    tmp = lcm_max;
  }
  return (tmp);
}
}
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) ;
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) ;
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) 
{ va_list args ;
  char *result ;

  {
  __builtin_va_start(args, format);
  result = vasnprintf(resultbuf, lengthp, format, args);
  __builtin_va_end(args);
  return (result);
}
}
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...)  __attribute__((__nonnull__(1,2))) ;
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...)  __attribute__((__nonnull__(1,2))) ;
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...) 
{ va_list args ;
  int result ;

  {
  __builtin_va_start(args, format);
  result = rpl_vasprintf(resultp, format, args);
  __builtin_va_end(args);
  return (result);
}
}
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline static void cdb_init(struct cd_buf *cdb ) 
{ 

  {
  cdb->fd = -100;
  return;
}
}
__inline static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ int tmp ;

  {
  tmp = fchdir((int )cdb->fd);
  return (tmp);
}
}
__inline static void cdb_free(struct cd_buf  const  *cdb ) 
{ _Bool close_fail ;
  int tmp ;

  {
  if (0 <= (int )cdb->fd) {
    tmp = close((int )cdb->fd);
    close_fail = (_Bool )tmp;
    if (! (! close_fail)) {
      __assert_fail("! close_fail", "chdir-long.c", 63U, "cdb_free");
    }
  }
  return;
}
}
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ int new_fd ;
  int __attribute__((__artificial__))  tmp ;

  {
  tmp = openat(cdb->fd, dir, 67840);
  new_fd = (int )tmp;
  if (new_fd < 0) {
    return (-1);
  }
  cdb_free((struct cd_buf  const  *)cdb);
  cdb->fd = new_fd;
  return (0);
}
}
__inline static char *find_non_slash(char const   *s ) 
{ size_t n_slash ;
  unsigned long tmp___8 ;

  {
  tmp___8 = __builtin_strspn(s, "/");
  n_slash = tmp___8;
  return ((char *)s + n_slash);
}
}
int chdir_long(char *dir ) 
{ int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  unsigned long tmp___11 ;
  int err ;
  char *slash ;
  void *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int saved_errno ;
  int *tmp___19 ;
  int *tmp___20 ;

  {
  tmp = chdir((char const   *)dir);
  e = tmp;
  if (e == 0) {
    return (e);
  } else {
    tmp___0 = __errno_location();
    if (*tmp___0 != 36) {
      return (e);
    }
  }
  tmp___1 = strlen((char const   *)dir);
  len = tmp___1;
  dir_end = dir + len;
  cdb_init(& cdb);
  if (! (0UL < len)) {
    __assert_fail("0 < len", "chdir-long.c", 125U, "chdir_long");
  }
  if (! (4096UL <= len)) {
    __assert_fail("4096 <= len", "chdir-long.c", 126U, "chdir_long");
  }
  tmp___11 = __builtin_strspn((char const   *)dir, "/");
  n_leading_slash = tmp___11;
  if (n_leading_slash == 2UL) {
    tmp___12 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
    slash = (char *)tmp___12;
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      tmp___13 = __errno_location();
      *tmp___13 = 36;
      return (-1);
    }
    *slash = (char )'\000';
    err = cdb_advance_fd(& cdb, (char const   *)dir);
    *slash = (char )'/';
    if (err != 0) {
      goto Fail;
    }
    dir = find_non_slash((char const   *)(slash + 1));
  } else
  if (n_leading_slash) {
    tmp___14 = cdb_advance_fd(& cdb, "/");
    if (tmp___14 != 0) {
      goto Fail;
    }
    dir += n_leading_slash;
  }
  if (! ((int )*dir != 47)) {
    __assert_fail("*dir != \'/\'", "chdir-long.c", 161U, "chdir_long");
  }
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    __assert_fail("dir <= dir_end", "chdir-long.c", 162U, "chdir_long");
  }
  while (4096 <= dir_end - dir) {
    tmp___15 = memrchr((void const   *)dir, '/', (size_t )4096);
    slash___0 = (char *)tmp___15;
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      tmp___16 = __errno_location();
      *tmp___16 = 36;
      return (-1);
    }
    *slash___0 = (char )'\000';
    if (! (slash___0 - dir < 4096)) {
      __assert_fail("slash - dir < 4096", "chdir-long.c", 178U, "chdir_long");
    }
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
    *slash___0 = (char )'/';
    if (err___0 != 0) {
      goto Fail;
    }
    dir = find_non_slash((char const   *)(slash___0 + 1));
  }
  if ((unsigned long )dir < (unsigned long )dir_end) {
    tmp___17 = cdb_advance_fd(& cdb, (char const   *)dir);
    if (tmp___17 != 0) {
      goto Fail;
    }
  }
  tmp___18 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  if (tmp___18 != 0) {
    goto Fail;
  }
  cdb_free((struct cd_buf  const  *)(& cdb));
  return (0);
  Fail: 
  tmp___19 = __errno_location();
  saved_errno = *tmp___19;
  cdb_free((struct cd_buf  const  *)(& cdb));
  tmp___20 = __errno_location();
  *tmp___20 = saved_errno;
  return (-1);
}
}
extern int fclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int __freading(FILE *__fp ) ;
int rpl_fclose(FILE *fp )  __attribute__((__nonnull__(1))) ;
int rpl_fclose(FILE *fp ) 
{ int saved_errno ;
  int fd ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  saved_errno = 0;
  result = 0;
  fd = fileno(fp);
  if (fd < 0) {
    tmp = fclose(fp);
    return (tmp);
  }
  tmp___1 = __freading(fp);
  if (tmp___1 != 0) {
    tmp___2 = fileno(fp);
    tmp___3 = lseek(tmp___2, (__off_t )0, 1);
    if (tmp___3 != -1L) {
      _L: 
      tmp___4 = rpl_fflush(fp);
      if (tmp___4) {
        tmp___0 = __errno_location();
        saved_errno = *tmp___0;
      }
    }
  } else {
    goto _L;
  }
  result = fclose(fp);
  if (saved_errno != 0) {
    tmp___5 = __errno_location();
    *tmp___5 = saved_errno;
    result = -1;
  }
  return (result);
}
}
extern int fcntl(int __fd , int __cmd  , ...) ;
static int have_dupfd_cloexec  =    0;
int rpl_fcntl(int fd , int action  , ...) 
{ va_list arg ;
  int result ;
  int target ;
  int tmp ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *p ;
  void *tmp___5 ;

  {
  result = -1;
  __builtin_va_start(arg, action);
  switch (action) {
  case 1030: 
  tmp = __builtin_va_arg(arg, int );
  target = tmp;
  if (0 <= have_dupfd_cloexec) {
    result = fcntl(fd, action, target);
    if (0 <= result) {
      have_dupfd_cloexec = 1;
    } else {
      tmp___0 = __errno_location();
      if (*tmp___0 != 22) {
        have_dupfd_cloexec = 1;
      } else {
        result = rpl_fcntl(fd, 0, target);
        if (result < 0) {
          break;
        }
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    result = rpl_fcntl(fd, 0, target);
  }
  if (0 <= result) {
    if (have_dupfd_cloexec == -1) {
      tmp___1 = fcntl(result, 1);
      flags = tmp___1;
      if (flags < 0) {
        goto _L;
      } else {
        tmp___4 = fcntl(result, 2, flags | 1);
        if (tmp___4 == -1) {
          _L: 
          tmp___2 = __errno_location();
          saved_errno = *tmp___2;
          close(result);
          tmp___3 = __errno_location();
          *tmp___3 = saved_errno;
          result = -1;
        }
      }
    }
  }
  break;
  default: 
  tmp___5 = __builtin_va_arg(arg, void *);
  p = tmp___5;
  result = fcntl(fd, action, p);
  break;
  }
  __builtin_va_end(arg);
  return (result);
}
}
extern int fflush(FILE *__stream ) ;
__inline static void clear_ungetc_buffer_preserving_position(FILE *fp ) 
{ 

  {
  if (fp->_flags & 256) {
    rpl_fseeko(fp, (off_t )0, 1);
  }
  return;
}
}
int rpl_fflush(FILE *stream ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    tmp = fflush(stream);
    return (tmp);
  } else {
    tmp___0 = __freading(stream);
    if (! (tmp___0 != 0)) {
      tmp = fflush(stream);
      return (tmp);
    }
  }
  clear_ungetc_buffer_preserving_position(stream);
  tmp___1 = fflush(stream);
  return (tmp___1);
}
}
int fpurge(FILE *fp )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void __fpurge(FILE *__fp ) ;
int fpurge(FILE *fp )  __attribute__((__nonnull__(1))) ;
int fpurge(FILE *fp ) 
{ 

  {
  __fpurge(fp);
  return (0);
}
}
int rpl_fseek(FILE *fp , long offset , int whence )  __attribute__((__nonnull__(1))) ;
int rpl_fseek(FILE *fp , long offset , int whence )  __attribute__((__nonnull__(1))) ;
int rpl_fseek(FILE *fp , long offset , int whence ) 
{ int tmp ;

  {
  tmp = rpl_fseeko(fp, offset, whence);
  return (tmp);
}
}
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
int rpl_fseeko(FILE *fp , off_t offset , int whence )  __attribute__((__nonnull__(1))) ;
int rpl_fseeko(FILE *fp , off_t offset , int whence ) 
{ off_t pos ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )fp->_IO_read_end == (unsigned long )fp->_IO_read_ptr) {
    if ((unsigned long )fp->_IO_write_ptr == (unsigned long )fp->_IO_write_base) {
      if ((unsigned long )fp->_IO_save_base == (unsigned long )((void *)0)) {
        tmp = fileno(fp);
        tmp___0 = lseek(tmp, offset, whence);
        pos = tmp___0;
        if (pos == -1L) {
          return (-1);
        }
        fp->_flags &= -17;
        fp->_offset = pos;
        return (0);
      }
    }
  }
  tmp___1 = fseeko(fp, offset, whence);
  return (tmp___1);
}
}
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) ;
extern  __attribute__((__nothrow__)) int statfs(char const   *__file , struct statfs *__buf )  __attribute__((__nonnull__(1,2))) ;
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) 
{ struct statfs fsd ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;

  {
  tmp = statfs(file, & fsd);
  if (tmp < 0) {
    return (-1);
  }
  if (sizeof(fsd.f_bsize) < sizeof(uintmax_t )) {
    if (sizeof(fsd.f_bsize) < sizeof(int )) {
      tmp___1 = - (1 << sizeof(fsd.f_bsize) * 8UL);
    } else {
      tmp___1 = 0;
    }
    if (~ fsd.f_bsize == (long )tmp___1) {
      fsp->fsu_blocksize = 0xffffffffffffffffUL;
    } else {
      fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
    }
  } else {
    fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
  }
  if (sizeof(fsd.f_blocks) < sizeof(uintmax_t )) {
    if (sizeof(fsd.f_blocks) < sizeof(int )) {
      tmp___3 = - (1 << sizeof(fsd.f_blocks) * 8UL);
    } else {
      tmp___3 = 0;
    }
    if (~ fsd.f_blocks == (__fsblkcnt_t )tmp___3) {
      fsp->fsu_blocks = 0xffffffffffffffffUL;
    } else {
      fsp->fsu_blocks = fsd.f_blocks;
    }
  } else {
    fsp->fsu_blocks = fsd.f_blocks;
  }
  if (sizeof(fsd.f_bfree) < sizeof(uintmax_t )) {
    if (sizeof(fsd.f_bfree) < sizeof(int )) {
      tmp___5 = - (1 << sizeof(fsd.f_bfree) * 8UL);
    } else {
      tmp___5 = 0;
    }
    if (~ fsd.f_bfree == (__fsblkcnt_t )tmp___5) {
      fsp->fsu_bfree = 0xffffffffffffffffUL;
    } else {
      fsp->fsu_bfree = fsd.f_bfree;
    }
  } else {
    fsp->fsu_bfree = fsd.f_bfree;
  }
  fsp->fsu_bavail = fsd.f_bavail | ~ ((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) - 1UL);
  fsp->fsu_bavail_top_bit_set = (_Bool )((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) != 0UL);
  if (sizeof(fsd.f_files) < sizeof(uintmax_t )) {
    if (sizeof(fsd.f_files) < sizeof(int )) {
      tmp___7 = - (1 << sizeof(fsd.f_files) * 8UL);
    } else {
      tmp___7 = 0;
    }
    if (~ fsd.f_files == (__fsfilcnt_t )tmp___7) {
      fsp->fsu_files = 0xffffffffffffffffUL;
    } else {
      fsp->fsu_files = fsd.f_files;
    }
  } else {
    fsp->fsu_files = fsd.f_files;
  }
  if (sizeof(fsd.f_ffree) < sizeof(uintmax_t )) {
    if (sizeof(fsd.f_ffree) < sizeof(int )) {
      tmp___9 = - (1 << sizeof(fsd.f_ffree) * 8UL);
    } else {
      tmp___9 = 0;
    }
    if (~ fsd.f_ffree == (__fsfilcnt_t )tmp___9) {
      fsp->fsu_ffree = 0xffffffffffffffffUL;
    } else {
      fsp->fsu_ffree = fsd.f_ffree;
    }
  } else {
    fsp->fsu_ffree = fsd.f_ffree;
  }
  return (0);
}
}
 __attribute__((__nothrow__)) FTSENT *fts_children(FTS *sp , int instr )  __attribute__((__warn_unused_result__)) ;
 __attribute__((__nothrow__)) int fts_close(FTS *sp )  __attribute__((__warn_unused_result__)) ;
 __attribute__((__nothrow__)) FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                                              FTSENT const   ** ) )  __attribute__((__warn_unused_result__)) ;
 __attribute__((__nothrow__)) FTSENT *fts_read(FTS *sp )  __attribute__((__warn_unused_result__)) ;
 __attribute__((__nothrow__)) int fts_set(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                          int instr ) ;
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
static FTSENT *fts_build(FTS *sp , int type ) ;
static void fts_lfree(FTSENT *head ) ;
static void fts_load(FTS *sp , FTSENT *p ) ;
static size_t fts_maxarglen(char * const  *argv ) ;
static void fts_padjust(FTS *sp , FTSENT *head ) ;
static _Bool fts_palloc(FTS *sp , size_t more ) ;
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
static _Bool AD_compare(void const   *x , void const   *y ) 
{ struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
  ax = (struct Active_dir  const  *)x;
  ay = (struct Active_dir  const  *)y;
  if (ax->ino == ay->ino) {
    if (ax->dev == ay->dev) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static size_t AD_hash(void const   *x , size_t table_size ) 
{ struct Active_dir  const  *ax ;

  {
  ax = (struct Active_dir  const  *)x;
  return ((uintmax_t )ax->ino % table_size);
}
}
static _Bool setup_dir(FTS *fts ) 
{ void *tmp ;

  {
  if (fts->fts_options & 258) {
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, & free);
    if (! fts->fts_cycle.ht) {
      return ((_Bool)0);
    }
  } else {
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
    if (! fts->fts_cycle.state) {
      return ((_Bool)0);
    }
    cycle_check_init(fts->fts_cycle.state);
  }
  return ((_Bool)1);
}
}
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
  if (fts->fts_options & 258) {
    st = (struct stat  const  *)(ent->fts_statp);
    tmp = malloc(sizeof(*ad));
    ad = (struct Active_dir *)tmp;
    if (! ad) {
      return ((_Bool)0);
    }
    ad->dev = (dev_t )st->st_dev;
    ad->ino = (ino_t )st->st_ino;
    ad->fts_ent = ent;
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
    ad_from_table = (struct Active_dir *)tmp___0;
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
      free((void *)ad);
      if (! ad_from_table) {
        return ((_Bool)0);
      }
      ent->fts_cycle = ad_from_table->fts_ent;
      ent->fts_info = (unsigned short)2;
    }
  } else {
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
    if (tmp___1) {
      ent->fts_cycle = ent;
      ent->fts_info = (unsigned short)2;
    }
  }
  return ((_Bool)1);
}
}
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
  st = (struct stat  const  *)(ent->fts_statp);
  if (fts->fts_options & 258) {
    obj.dev = (dev_t )st->st_dev;
    obj.ino = (ino_t )st->st_ino;
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
    if (! found) {
      abort();
    }
    free(found);
  } else {
    parent = ent->fts_parent;
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
      if (0L <= parent->fts_level) {
        while (1) {
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
            abort();
          }
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
          break;
        }
      }
    }
  }
  return;
}
}
static void free_dir(FTS *sp ) 
{ 

  {
  if (sp->fts_options & 258) {
    if (sp->fts_cycle.ht) {
      hash_free(sp->fts_cycle.ht);
    }
  } else {
    free((void *)sp->fts_cycle.state);
  }
  return;
}
}
static void fd_ring_clear(I_ring *fd_ring ) 
{ int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
  while (1) {
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
    if (tmp___0) {
      break;
    }
    tmp = i_ring_pop(fd_ring);
    fd = tmp;
    if (0 <= fd) {
      close(fd);
    }
  }
  return;
}
}
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 

  {
  while (1) {
    if (! ((int )p->fts_info == 11)) {
      abort();
    }
    break;
  }
  if (required) {
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
    p->fts_statp[0].st_size = (__off_t )1;
  }
  return;
}
}
__inline static DIR *opendirat(int fd , char const   *dir , int extra_flags , int *pdir_fd ) 
{ int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = openat_safer(fd, dir, 67840 | extra_flags);
  new_fd = tmp;
  if (new_fd < 0) {
    return ((DIR *)((void *)0));
  }
  set_cloexec_flag(new_fd, (_Bool)1);
  dirp = fdopendir(new_fd);
  if (dirp) {
    *pdir_fd = new_fd;
  } else {
    tmp___0 = __errno_location();
    saved_errno = *tmp___0;
    close(new_fd);
    tmp___1 = __errno_location();
    *tmp___1 = saved_errno;
  }
  return (dirp);
}
}
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
  old = sp->fts_cwd_fd;
  while (1) {
    if (! (old != fd)) {
      if (! (old == -100)) {
        abort();
      }
    }
    break;
  }
  if (chdir_down_one) {
    tmp = i_ring_push(& sp->fts_fd_ring, old);
    prev_fd_in_slot = tmp;
    if (0 <= prev_fd_in_slot) {
      close(prev_fd_in_slot);
    }
  } else
  if (! (sp->fts_options & 4)) {
    if (0 <= old) {
      close(old);
    }
  }
  sp->fts_cwd_fd = fd;
  return;
}
}
__inline static int diropen(FTS const   *sp , char const   *dir ) 
{ int open_flags ;
  int tmp ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (sp->fts_options & 16) {
    tmp = 131072;
  } else {
    tmp = 0;
  }
  if (sp->fts_options & 2048) {
    tmp___0 = 262144;
  } else {
    tmp___0 = 0;
  }
  open_flags = (67840 | tmp) | tmp___0;
  if (sp->fts_options & 512) {
    tmp___1 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
    tmp___3 = tmp___1;
  } else {
    tmp___2 = open_safer(dir, open_flags);
    tmp___3 = tmp___2;
  }
  fd = tmp___3;
  if (0 <= fd) {
    set_cloexec_flag(fd, (_Bool)1);
  }
  return (fd);
}
}
 __attribute__((__nothrow__)) FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                                              FTSENT const   ** ) )  __attribute__((__warn_unused_result__)) ;
FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                FTSENT const   ** ) ) 
{ register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  size_t len ;
  size_t tmp___10 ;
  struct _ftsent *tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;

  {
  parent = (FTSENT *)((void *)0);
  tmp = (FTSENT *)((void *)0);
  if (options & -4096) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((FTS *)((void *)0));
  }
  if (options & 4) {
    if (options & 512) {
      tmp___1 = __errno_location();
      *tmp___1 = 22;
      return ((FTS *)((void *)0));
    }
  }
  if (! (options & 18)) {
    tmp___2 = __errno_location();
    *tmp___2 = 22;
    return ((FTS *)((void *)0));
  }
  tmp___3 = malloc(sizeof(FTS ));
  sp = (FTS *)tmp___3;
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
    return ((FTS *)((void *)0));
  }
  memset((void *)sp, 0, sizeof(FTS ));
  sp->fts_compar = compar;
  sp->fts_options = options;
  if (sp->fts_options & 2) {
    sp->fts_options |= 4;
    sp->fts_options &= -513;
  }
  sp->fts_cwd_fd = -100;
  tmp___6 = fts_maxarglen(argv);
  maxarglen = tmp___6;
  if (maxarglen > 4096UL) {
    tmp___7 = maxarglen;
  } else {
    tmp___7 = (size_t )4096;
  }
  tmp___8 = fts_palloc(sp, tmp___7);
  if (! tmp___8) {
    goto mem1;
  }
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
    parent = fts_alloc(sp, "", (size_t )0);
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
      goto mem2;
    }
    parent->fts_level = (ptrdiff_t )-1;
  }
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
    tmp___9 = 1;
  } else
  if (sp->fts_options & 1024) {
    tmp___9 = 1;
  } else {
    tmp___9 = 0;
  }
  defer_stat = (_Bool )tmp___9;
  root = (FTSENT *)((void *)0);
  nitems = (size_t )0;
  while ((unsigned long )*argv != (unsigned long )((void *)0)) {
    tmp___10 = strlen((char const   *)*argv);
    len = tmp___10;
    p = fts_alloc(sp, (char const   *)*argv, len);
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      goto mem3;
    }
    p->fts_level = (ptrdiff_t )0;
    p->fts_parent = parent;
    p->fts_accpath = p->fts_name;
    if (defer_stat) {
      if ((unsigned long )root != (unsigned long )((void *)0)) {
        p->fts_info = (unsigned short)11;
        fts_set_stat_required(p, (_Bool)1);
      } else {
        p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    } else {
      p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
    if (compar) {
      p->fts_link = root;
      root = p;
    } else {
      p->fts_link = (struct _ftsent *)((void *)0);
      if ((unsigned long )root == (unsigned long )((void *)0)) {
        root = p;
        tmp = root;
      } else {
        tmp->fts_link = p;
        tmp = p;
      }
    }
    argv ++;
    nitems ++;
  }
  if (compar) {
    if (nitems > 1UL) {
      root = fts_sort(sp, root, nitems);
    }
  }
  tmp___11 = fts_alloc(sp, "", (size_t )0);
  sp->fts_cur = tmp___11;
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
    goto mem3;
  }
  (sp->fts_cur)->fts_link = root;
  (sp->fts_cur)->fts_info = (unsigned short)9;
  tmp___12 = setup_dir(sp);
  if (! tmp___12) {
    goto mem3;
  }
  if (! (sp->fts_options & 4)) {
    if (! (sp->fts_options & 512)) {
      tmp___13 = diropen((FTS const   *)sp, ".");
      sp->fts_rfd = tmp___13;
      if (tmp___13 < 0) {
        sp->fts_options |= 4;
      }
    }
  }
  i_ring_init(& sp->fts_fd_ring, -1);
  return (sp);
  mem3: 
  fts_lfree(root);
  free((void *)parent);
  mem2: 
  free((void *)sp->fts_path);
  mem1: 
  free((void *)sp);
  return ((FTS *)((void *)0));
}
}
static void fts_load(FTS *sp , FTSENT *p ) 
{ register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  tmp = p->fts_namelen;
  p->fts_pathlen = tmp;
  len = tmp;
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
  cp = strrchr((char const   *)(p->fts_name), '/');
  if (cp) {
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
      cp ++;
      len = strlen((char const   *)cp);
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
      p->fts_namelen = len;
    } else
    if (*(cp + 1)) {
      cp ++;
      len = strlen((char const   *)cp);
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
      p->fts_namelen = len;
    }
  }
  tmp___0 = sp->fts_path;
  p->fts_path = tmp___0;
  p->fts_accpath = tmp___0;
  return;
}
}
 __attribute__((__nothrow__)) int fts_close(FTS *sp )  __attribute__((__warn_unused_result__)) ;
int fts_close(FTS *sp ) 
{ register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  saved_errno = 0;
  if (sp->fts_cur) {
    p = sp->fts_cur;
    while (p->fts_level >= 0L) {
      freep = p;
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
        p = p->fts_link;
      } else {
        p = p->fts_parent;
      }
      free((void *)freep);
    }
    free((void *)p);
  }
  if (sp->fts_child) {
    fts_lfree(sp->fts_child);
  }
  free((void *)sp->fts_array);
  free((void *)sp->fts_path);
  if (sp->fts_options & 512) {
    if (0 <= sp->fts_cwd_fd) {
      tmp___0 = close(sp->fts_cwd_fd);
      if (tmp___0) {
        tmp = __errno_location();
        saved_errno = *tmp;
      }
    }
  } else
  if (! (sp->fts_options & 4)) {
    tmp___2 = fchdir(sp->fts_rfd);
    if (tmp___2) {
      tmp___1 = __errno_location();
      saved_errno = *tmp___1;
    }
    tmp___4 = close(sp->fts_rfd);
    if (tmp___4) {
      if (saved_errno == 0) {
        tmp___3 = __errno_location();
        saved_errno = *tmp___3;
      }
    }
  }
  fd_ring_clear(& sp->fts_fd_ring);
  if (sp->fts_leaf_optimization_works_ht) {
    hash_free(sp->fts_leaf_optimization_works_ht);
  }
  free_dir(sp);
  free((void *)sp);
  if (saved_errno) {
    tmp___5 = __errno_location();
    *tmp___5 = saved_errno;
    return (-1);
  }
  return (0);
}
}
extern  __attribute__((__nothrow__)) int fstatfs(int __fildes , struct statfs *__buf )  __attribute__((__nonnull__(2))) ;
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ struct statfs fs_buf ;
  int tmp ;

  {
  tmp = fstatfs(dir_fd, & fs_buf);
  if (tmp != 0) {
    return ((_Bool)1);
  }
  switch ((int )fs_buf.f_type) {
  case 16914836: 
  case 26985: 
  return ((_Bool)0);
  default: 
  return ((_Bool)1);
  }
}
}
static _Bool leaf_optimization_applies(int dir_fd ) 
{ struct statfs fs_buf ;
  int tmp ;

  {
  tmp = fstatfs(dir_fd, & fs_buf);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  switch ((int )fs_buf.f_type) {
  case 1382369651: 
  return ((_Bool)1);
  default: 
  return ((_Bool)0);
  }
}
}
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ struct LCO_ent  const  *ax ;

  {
  ax = (struct LCO_ent  const  *)x;
  return ((uintmax_t )ax->st_dev % table_size);
}
}
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
  ax = (struct LCO_ent  const  *)x;
  ay = (struct LCO_ent  const  *)y;
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  sp = (FTS *)p->fts_fts;
  h = sp->fts_leaf_optimization_works_ht;
  if (! (sp->fts_options & 512)) {
    return ((_Bool)0);
  }
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, & free);
    sp->fts_leaf_optimization_works_ht = tmp___0;
    h = tmp___0;
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      return ((_Bool)0);
    }
  }
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
  ent = (struct LCO_ent *)tmp___1;
  if (ent) {
    return (ent->opt_ok);
  }
  tmp___2 = malloc(sizeof(*t2));
  t2 = (struct LCO_ent *)tmp___2;
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
  t2->opt_ok = opt_ok;
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
  tmp___3 = hash_insert(h, (void const   *)t2);
  ent = (struct LCO_ent *)tmp___3;
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
    free((void *)t2);
    return ((_Bool)0);
  }
  while (1) {
    if (! ((unsigned long )ent == (unsigned long )t2)) {
      abort();
    }
    break;
  }
  return (opt_ok);
}
}
 __attribute__((__nothrow__)) FTSENT *fts_read(FTS *sp )  __attribute__((__warn_unused_result__)) ;
FTSENT *fts_read(FTS *sp ) 
{ register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  FTSENT *parent ;
  _Bool tmp___14 ;
  int *tmp___15 ;
  _Bool tmp___16 ;
  int *tmp___17 ;
  struct _ftsent *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int saved_errno ;
  int *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  FTSENT *tmp___32 ;

  {
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
    return ((FTSENT *)((void *)0));
  } else
  if (sp->fts_options & 8192) {
    return ((FTSENT *)((void *)0));
  }
  p = sp->fts_cur;
  instr = p->fts_instr;
  p->fts_instr = (unsigned short)3;
  if ((int )instr == 1) {
    p->fts_info = fts_stat(sp, p, (_Bool)0);
    return (p);
  }
  if ((int )instr == 2) {
    if ((int )p->fts_info == 12) {
      goto _L;
    } else
    if ((int )p->fts_info == 13) {
      _L: 
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      if ((int )p->fts_info == 1) {
        if (! (sp->fts_options & 4)) {
          tmp___1 = diropen((FTS const   *)sp, ".");
          p->fts_symfd = tmp___1;
          if (tmp___1 < 0) {
            tmp___0 = __errno_location();
            p->fts_errno = *tmp___0;
            p->fts_info = (unsigned short)7;
          } else {
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
      goto check_for_dir;
    }
  }
  if ((int )p->fts_info == 1) {
    if ((int )instr == 4) {
      goto _L___0;
    } else
    if (sp->fts_options & 64) {
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: 
        if ((int )p->fts_flags & 2) {
          close(p->fts_symfd);
        }
        if (sp->fts_child) {
          fts_lfree(sp->fts_child);
          sp->fts_child = (struct _ftsent *)((void *)0);
        }
        p->fts_info = (unsigned short)6;
        while (1) {
          leave_dir(sp, p);
          break;
        }
        return (p);
      }
    }
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      if (sp->fts_options & 4096) {
        sp->fts_options &= -4097;
        fts_lfree(sp->fts_child);
        sp->fts_child = (struct _ftsent *)((void *)0);
      }
    }
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
      if (tmp___3) {
        tmp___2 = __errno_location();
        p->fts_errno = *tmp___2;
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
        p = sp->fts_child;
        while ((unsigned long )p != (unsigned long )((void *)0)) {
          p->fts_accpath = (p->fts_parent)->fts_accpath;
          p = p->fts_link;
        }
      }
    } else {
      tmp___4 = fts_build(sp, 3);
      sp->fts_child = tmp___4;
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        if (sp->fts_options & 8192) {
          return ((FTSENT *)((void *)0));
        }
        if (p->fts_errno) {
          if ((int )p->fts_info != 4) {
            p->fts_info = (unsigned short)7;
          }
        }
        while (1) {
          leave_dir(sp, p);
          break;
        }
        return (p);
      }
    }
    p = sp->fts_child;
    sp->fts_child = (struct _ftsent *)((void *)0);
    goto name;
  }
  next: 
  tmp = p;
  if ((unsigned long )p->fts_link == (unsigned long )((void *)0)) {
    if ((p->fts_parent)->fts_dirp) {
      p = tmp->fts_parent;
      sp->fts_cur = p;
      *(sp->fts_path + p->fts_pathlen) = (char )'\000';
      p = fts_build(sp, 3);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        if (sp->fts_options & 8192) {
          return ((FTSENT *)((void *)0));
        }
        goto cd_dot_dot;
      }
      free((void *)tmp);
      goto name;
    }
  }
  p = p->fts_link;
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    sp->fts_cur = p;
    free((void *)tmp);
    if (p->fts_level == 0L) {
      fd_ring_clear(& sp->fts_fd_ring);
      if (! (sp->fts_options & 4)) {
        if (sp->fts_options & 512) {
          if (sp->fts_options & 512) {
            tmp___5 = -100;
          } else {
            tmp___5 = sp->fts_rfd;
          }
          cwd_advance_fd(sp, tmp___5, (_Bool)1);
          tmp___8 = 0;
        } else {
          if (sp->fts_options & 512) {
            tmp___6 = -100;
          } else {
            tmp___6 = sp->fts_rfd;
          }
          tmp___7 = fchdir(tmp___6);
          tmp___8 = tmp___7;
        }
        if (tmp___8) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      if (tmp___9) {
        sp->fts_options |= 8192;
        return ((FTSENT *)((void *)0));
      }
      free_dir(sp);
      fts_load(sp, p);
      setup_dir(sp);
      goto check_for_dir;
    }
    if ((int )p->fts_instr == 4) {
      goto next;
    }
    if ((int )p->fts_instr == 2) {
      p->fts_info = fts_stat(sp, p, (_Bool)1);
      if ((int )p->fts_info == 1) {
        if (! (sp->fts_options & 4)) {
          tmp___11 = diropen((FTS const   *)sp, ".");
          p->fts_symfd = tmp___11;
          if (tmp___11 < 0) {
            tmp___10 = __errno_location();
            p->fts_errno = *tmp___10;
            p->fts_info = (unsigned short)7;
          } else {
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
      p->fts_instr = (unsigned short)3;
    }
    name: 
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
      tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
      tmp___12 = (p->fts_parent)->fts_pathlen;
    }
    t = sp->fts_path + tmp___12;
    tmp___13 = t;
    t ++;
    *tmp___13 = (char )'/';
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    check_for_dir: 
    sp->fts_cur = p;
    if ((int )p->fts_info == 11) {
      if (p->fts_statp[0].st_size == 2L) {
        parent = p->fts_parent;
        if (0L < p->fts_level) {
          if (parent->fts_n_dirs_remaining == 0UL) {
            if (sp->fts_options & 8) {
              if (sp->fts_options & 16) {
                tmp___14 = link_count_optimize_ok((FTSENT const   *)parent);
                if (! tmp___14) {
                  goto _L___4;
                }
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: 
          p->fts_info = fts_stat(sp, p, (_Bool)0);
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
            if (p->fts_level != 0L) {
              if (parent->fts_n_dirs_remaining) {
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
        while (1) {
          if (! (p->fts_statp[0].st_size == 1L)) {
            abort();
          }
          break;
        }
      }
    }
    if ((int )p->fts_info == 1) {
      if (p->fts_level == 0L) {
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
      tmp___16 = enter_dir(sp, p);
      if (! tmp___16) {
        tmp___15 = __errno_location();
        *tmp___15 = 12;
        return ((FTSENT *)((void *)0));
      }
    }
    return (p);
  }
  cd_dot_dot: 
  p = tmp->fts_parent;
  sp->fts_cur = p;
  free((void *)tmp);
  if (p->fts_level == -1L) {
    free((void *)p);
    tmp___17 = __errno_location();
    *tmp___17 = 0;
    tmp___18 = (struct _ftsent *)((void *)0);
    sp->fts_cur = tmp___18;
    return (tmp___18);
  }
  while (1) {
    if (! ((int )p->fts_info != 11)) {
      abort();
    }
    break;
  }
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
  if (p->fts_level == 0L) {
    fd_ring_clear(& sp->fts_fd_ring);
    if (! (sp->fts_options & 4)) {
      if (sp->fts_options & 512) {
        if (sp->fts_options & 512) {
          tmp___20 = -100;
        } else {
          tmp___20 = sp->fts_rfd;
        }
        cwd_advance_fd(sp, tmp___20, (_Bool)1);
        tmp___23 = 0;
      } else {
        if (sp->fts_options & 512) {
          tmp___21 = -100;
        } else {
          tmp___21 = sp->fts_rfd;
        }
        tmp___22 = fchdir(tmp___21);
        tmp___23 = tmp___22;
      }
      if (tmp___23) {
        tmp___24 = 1;
      } else {
        tmp___24 = 0;
      }
    } else {
      tmp___24 = 0;
    }
    if (tmp___24) {
      tmp___19 = __errno_location();
      p->fts_errno = *tmp___19;
      sp->fts_options |= 8192;
    }
  } else
  if ((int )p->fts_flags & 2) {
    if (! (sp->fts_options & 4)) {
      if (sp->fts_options & 512) {
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
        tmp___29 = 0;
      } else {
        tmp___28 = fchdir(p->fts_symfd);
        tmp___29 = tmp___28;
      }
      if (tmp___29) {
        tmp___25 = __errno_location();
        saved_errno = *tmp___25;
        close(p->fts_symfd);
        tmp___26 = __errno_location();
        *tmp___26 = saved_errno;
        tmp___27 = __errno_location();
        p->fts_errno = *tmp___27;
        sp->fts_options |= 8192;
      }
    }
    close(p->fts_symfd);
  } else
  if (! ((int )p->fts_flags & 1)) {
    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
    if (tmp___31) {
      tmp___30 = __errno_location();
      p->fts_errno = *tmp___30;
      sp->fts_options |= 8192;
    }
  }
  if (p->fts_errno) {
    p->fts_info = (unsigned short)7;
  } else {
    p->fts_info = (unsigned short)6;
  }
  if (p->fts_errno == 0) {
    while (1) {
      leave_dir(sp, p);
      break;
    }
  }
  if (sp->fts_options & 8192) {
    tmp___32 = (FTSENT *)((void *)0);
  } else {
    tmp___32 = p;
  }
  return (tmp___32);
}
}
 __attribute__((__nothrow__)) int fts_set(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                          int instr ) ;
int fts_set(FTS *sp  __attribute__((__unused__)) , FTSENT *p , int instr ) 
{ int *tmp ;

  {
  if (instr != 0) {
    if (instr != 1) {
      if (instr != 2) {
        if (instr != 3) {
          if (instr != 4) {
            tmp = __errno_location();
            *tmp = 22;
            return (1);
          }
        }
      }
    }
  }
  p->fts_instr = (unsigned short )instr;
  return (0);
}
}
 __attribute__((__nothrow__)) FTSENT *fts_children(FTS *sp , int instr )  __attribute__((__warn_unused_result__)) ;
FTSENT *fts_children(FTS *sp , int instr ) 
{ register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  if (instr != 0) {
    if (instr != 4096) {
      tmp = __errno_location();
      *tmp = 22;
      return ((FTSENT *)((void *)0));
    }
  }
  p = sp->fts_cur;
  tmp___0 = __errno_location();
  *tmp___0 = 0;
  if (sp->fts_options & 8192) {
    return ((FTSENT *)((void *)0));
  }
  if ((int )p->fts_info == 9) {
    return (p->fts_link);
  }
  if ((int )p->fts_info != 1) {
    return ((FTSENT *)((void *)0));
  }
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
    fts_lfree(sp->fts_child);
  }
  if (instr == 4096) {
    sp->fts_options |= 4096;
    instr = 2;
  } else {
    instr = 1;
  }
  if (p->fts_level != 0L) {
    tmp___1 = fts_build(sp, instr);
    sp->fts_child = tmp___1;
    return (tmp___1);
  } else
  if ((int )*(p->fts_accpath + 0) == 47) {
    tmp___1 = fts_build(sp, instr);
    sp->fts_child = tmp___1;
    return (tmp___1);
  } else
  if (sp->fts_options & 4) {
    tmp___1 = fts_build(sp, instr);
    sp->fts_child = tmp___1;
    return (tmp___1);
  }
  fd = diropen((FTS const   *)sp, ".");
  if (fd < 0) {
    tmp___2 = (struct _ftsent *)((void *)0);
    sp->fts_child = tmp___2;
    return (tmp___2);
  }
  sp->fts_child = fts_build(sp, instr);
  if (sp->fts_options & 512) {
    cwd_advance_fd(sp, fd, (_Bool)1);
  } else {
    tmp___5 = fchdir(fd);
    if (tmp___5) {
      tmp___3 = __errno_location();
      saved_errno = *tmp___3;
      close(fd);
      tmp___4 = __errno_location();
      *tmp___4 = saved_errno;
      return ((FTSENT *)((void *)0));
    }
    close(fd);
  }
  return (sp->fts_child);
}
}
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
    tmp___0 = -1;
  } else {
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ mode_t type ;

  {
  switch ((int )dtype) {
  case 6: 
  type = (mode_t )24576;
  break;
  case 2: 
  type = (mode_t )8192;
  break;
  case 4: 
  type = (mode_t )16384;
  break;
  case 1: 
  type = (mode_t )4096;
  break;
  case 10: 
  type = (mode_t )40960;
  break;
  case 8: 
  type = (mode_t )32768;
  break;
  case 12: 
  type = (mode_t )49152;
  break;
  default: 
  type = (mode_t )0;
  }
  st->st_mode = type;
  return;
}
}
static FTSENT *fts_build(FTS *sp , int type ) 
{ register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *tail ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int dir_fd ;
  FTSENT *cur ;
  _Bool continue_readdir ;
  DIR *dp ;
  int *tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  _Bool tmp___6 ;
  size_t max_entries ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool is_dir ;
  struct dirent *dp___0 ;
  struct dirent *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  size_t tmp___16 ;
  _Bool tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  int *tmp___20 ;
  _Bool skip_stat ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  _Bool tmp___31 ;

  {
  cur = sp->fts_cur;
  continue_readdir = (_Bool )(! (! cur->fts_dirp));
  if (continue_readdir) {
    dp = cur->fts_dirp;
    dir_fd = dirfd(dp);
    if (dir_fd < 0) {
      while (1) {
        closedir(cur->fts_dirp);
        cur->fts_dirp = (DIR *)((void *)0);
        break;
      }
      if (type == 3) {
        cur->fts_info = (unsigned short)4;
        tmp = __errno_location();
        cur->fts_errno = *tmp;
      }
      return ((FTSENT *)((void *)0));
    }
  } else {
    if (sp->fts_options & 16) {
      if (sp->fts_options & 1) {
        if (cur->fts_level == 0L) {
          tmp___2 = 0;
        } else {
          tmp___2 = 131072;
        }
      } else {
        tmp___2 = 131072;
      }
    } else {
      tmp___2 = 0;
    }
    if (sp->fts_options & 2048) {
      tmp___3 = 262144;
    } else {
      tmp___3 = 0;
    }
    if (! (sp->fts_options & 4)) {
      if (sp->fts_options & 512) {
        tmp___4 = sp->fts_cwd_fd;
      } else {
        tmp___4 = -100;
      }
    } else {
      tmp___4 = -100;
    }
    tmp___1 = opendirat(tmp___4, (char const   *)cur->fts_accpath, tmp___2 | tmp___3,
                        & dir_fd);
    cur->fts_dirp = tmp___1;
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      if (type == 3) {
        cur->fts_info = (unsigned short)4;
        tmp___0 = __errno_location();
        cur->fts_errno = *tmp___0;
      }
      return ((FTSENT *)((void *)0));
    }
    if ((int )cur->fts_info == 11) {
      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
    } else
    if (sp->fts_options & 256) {
      while (1) {
        leave_dir(sp, cur);
        break;
      }
      fts_stat(sp, cur, (_Bool)0);
      tmp___6 = enter_dir(sp, cur);
      if (! tmp___6) {
        tmp___5 = __errno_location();
        *tmp___5 = 12;
        return ((FTSENT *)((void *)0));
      }
    }
  }
  if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
    tmp___7 = 100000UL;
  } else {
    tmp___7 = 0xffffffffffffffffUL;
  }
  max_entries = tmp___7;
  if (type == 2) {
    nlinks = (nlink_t )0;
    nostat = (_Bool)0;
  } else
  if (sp->fts_options & 8) {
    if (sp->fts_options & 16) {
      if (sp->fts_options & 32) {
        tmp___8 = 0;
      } else {
        tmp___8 = 2;
      }
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___8;
      nostat = (_Bool)1;
    } else {
      nlinks = (nlink_t )-1;
      nostat = (_Bool)0;
    }
  } else {
    nlinks = (nlink_t )-1;
    nostat = (_Bool)0;
  }
  if (continue_readdir) {
    descend = (_Bool)1;
  } else
  if (nlinks) {
    goto _L___0;
  } else
  if (type == 3) {
    _L___0: 
    if (sp->fts_options & 512) {
      dir_fd = dup_safer(dir_fd);
      if (0 <= dir_fd) {
        set_cloexec_flag(dir_fd, (_Bool)1);
      }
    }
    if (dir_fd < 0) {
      goto _L;
    } else {
      tmp___10 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
      if (tmp___10) {
        _L: 
        if (nlinks) {
          if (type == 3) {
            tmp___9 = __errno_location();
            cur->fts_errno = *tmp___9;
          }
        }
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
        descend = (_Bool)0;
        while (1) {
          closedir(cur->fts_dirp);
          cur->fts_dirp = (DIR *)((void *)0);
          break;
        }
        if (sp->fts_options & 512) {
          if (0 <= dir_fd) {
            close(dir_fd);
          }
        }
        cur->fts_dirp = (DIR *)((void *)0);
      } else {
        descend = (_Bool)1;
      }
    }
  } else {
    descend = (_Bool)0;
  }
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
    len = cur->fts_pathlen - 1UL;
  } else {
    len = cur->fts_pathlen;
  }
  if (sp->fts_options & 4) {
    cp = sp->fts_path + len;
    tmp___11 = cp;
    cp ++;
    *tmp___11 = (char )'/';
  } else {
    cp = (char *)((void *)0);
  }
  len ++;
  maxlen = sp->fts_pathlen - len;
  level = cur->fts_level + 1L;
  doadjust = (_Bool)0;
  head = (FTSENT *)((void *)0);
  tail = (FTSENT *)((void *)0);
  nitems = (size_t )0;
  while (cur->fts_dirp) {
    tmp___12 = readdir(cur->fts_dirp);
    dp___0 = tmp___12;
    if ((unsigned long )dp___0 == (unsigned long )((void *)0)) {
      break;
    }
    if (! (sp->fts_options & 32)) {
      if ((int )dp___0->d_name[0] == 46) {
        if (! dp___0->d_name[1]) {
          continue;
        } else
        if ((int )dp___0->d_name[1] == 46) {
          if (! dp___0->d_name[2]) {
            continue;
          }
        }
      }
    }
    tmp___13 = strlen((char const   *)(dp___0->d_name));
    p = fts_alloc(sp, (char const   *)(dp___0->d_name), tmp___13);
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      goto mem1;
    }
    tmp___18 = strlen((char const   *)(dp___0->d_name));
    if (tmp___18 >= maxlen) {
      oldaddr = (void *)sp->fts_path;
      tmp___16 = strlen((char const   *)(dp___0->d_name));
      tmp___17 = fts_palloc(sp, (tmp___16 + len) + 1UL);
      if (! tmp___17) {
        mem1: 
        tmp___14 = __errno_location();
        saved_errno = *tmp___14;
        free((void *)p);
        fts_lfree(head);
        while (1) {
          closedir(cur->fts_dirp);
          cur->fts_dirp = (DIR *)((void *)0);
          break;
        }
        cur->fts_info = (unsigned short)7;
        sp->fts_options |= 8192;
        tmp___15 = __errno_location();
        *tmp___15 = saved_errno;
        return ((FTSENT *)((void *)0));
      }
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
        doadjust = (_Bool)1;
        if (sp->fts_options & 4) {
          cp = sp->fts_path + len;
        }
      }
      maxlen = sp->fts_pathlen - len;
    }
    tmp___19 = strlen((char const   *)(dp___0->d_name));
    new_len = len + tmp___19;
    if (new_len < len) {
      free((void *)p);
      fts_lfree(head);
      while (1) {
        closedir(cur->fts_dirp);
        cur->fts_dirp = (DIR *)((void *)0);
        break;
      }
      cur->fts_info = (unsigned short)7;
      sp->fts_options |= 8192;
      tmp___20 = __errno_location();
      *tmp___20 = 36;
      return ((FTSENT *)((void *)0));
    }
    p->fts_level = level;
    p->fts_parent = sp->fts_cur;
    p->fts_pathlen = new_len;
    p->fts_statp[0].st_ino = dp___0->d_ino;
    if (sp->fts_options & 4) {
      p->fts_accpath = p->fts_path;
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    } else {
      p->fts_accpath = p->fts_name;
    }
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
      goto _L___1;
    } else
    if (sp->fts_options & 1024) {
      _L___1: 
      if (sp->fts_options & 16) {
        if (sp->fts_options & 8) {
          if ((int )dp___0->d_type != 0) {
            if (! ((int )dp___0->d_type == 4)) {
              tmp___21 = 1;
            } else {
              tmp___21 = 0;
            }
          } else {
            tmp___21 = 0;
          }
        } else {
          tmp___21 = 0;
        }
      } else {
        tmp___21 = 0;
      }
      skip_stat = (_Bool )tmp___21;
      p->fts_info = (unsigned short)11;
      set_stat_type(p->fts_statp, (unsigned int )dp___0->d_type);
      fts_set_stat_required(p, (_Bool )(! skip_stat));
      if (sp->fts_options & 16) {
        if ((int )dp___0->d_type == 4) {
          tmp___22 = 1;
        } else {
          tmp___22 = 0;
        }
      } else {
        tmp___22 = 0;
      }
      is_dir = (_Bool )tmp___22;
    } else {
      p->fts_info = fts_stat(sp, p, (_Bool)0);
      if ((int )p->fts_info == 1) {
        tmp___23 = 1;
      } else
      if ((int )p->fts_info == 2) {
        tmp___23 = 1;
      } else
      if ((int )p->fts_info == 5) {
        tmp___23 = 1;
      } else {
        tmp___23 = 0;
      }
      is_dir = (_Bool )tmp___23;
    }
    if (nlinks > 0UL) {
      if (is_dir) {
        nlinks -= (nlink_t )nostat;
      }
    }
    p->fts_link = (struct _ftsent *)((void *)0);
    if ((unsigned long )head == (unsigned long )((void *)0)) {
      tail = p;
      head = tail;
    } else {
      tail->fts_link = p;
      tail = p;
    }
    nitems ++;
    if (max_entries <= nitems) {
      goto break_without_closedir;
    }
  }
  if (cur->fts_dirp) {
    while (1) {
      closedir(cur->fts_dirp);
      cur->fts_dirp = (DIR *)((void *)0);
      break;
    }
  }
  break_without_closedir: 
  if (doadjust) {
    fts_padjust(sp, head);
  }
  if (sp->fts_options & 4) {
    if (len == sp->fts_pathlen) {
      cp --;
    } else
    if (nitems == 0UL) {
      cp --;
    }
    *cp = (char )'\000';
  }
  if (! continue_readdir) {
    if (descend) {
      if (type == 1) {
        goto _L___2;
      } else
      if (! nitems) {
        _L___2: 
        if (cur->fts_level == 0L) {
          fd_ring_clear(& sp->fts_fd_ring);
          if (! (sp->fts_options & 4)) {
            if (sp->fts_options & 512) {
              if (sp->fts_options & 512) {
                tmp___24 = -100;
              } else {
                tmp___24 = sp->fts_rfd;
              }
              cwd_advance_fd(sp, tmp___24, (_Bool)1);
              tmp___27 = 0;
            } else {
              if (sp->fts_options & 512) {
                tmp___25 = -100;
              } else {
                tmp___25 = sp->fts_rfd;
              }
              tmp___26 = fchdir(tmp___25);
              tmp___27 = tmp___26;
            }
            if (tmp___27) {
              tmp___28 = 1;
            } else {
              tmp___28 = 0;
            }
          } else {
            tmp___28 = 0;
          }
          tmp___30 = tmp___28;
        } else {
          tmp___29 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
          tmp___30 = tmp___29;
        }
        if (tmp___30) {
          cur->fts_info = (unsigned short)7;
          sp->fts_options |= 8192;
          fts_lfree(head);
          return ((FTSENT *)((void *)0));
        }
      }
    }
  }
  if (! nitems) {
    if (type == 3) {
      cur->fts_info = (unsigned short)6;
    }
    fts_lfree(head);
    return ((FTSENT *)((void *)0));
  }
  if (nitems > 10000UL) {
    if (! sp->fts_compar) {
      if (sp->fts_options & 512) {
        tmp___31 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
        if (tmp___31) {
          sp->fts_compar = & fts_compare_ino;
          head = fts_sort(sp, head, nitems);
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
        }
      }
    }
  }
  if (sp->fts_compar) {
    if (nitems > 1UL) {
      head = fts_sort(sp, head, nitems);
    }
  }
  return (head);
}
}
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  sbp = p->fts_statp;
  if (p->fts_level == 0L) {
    if (sp->fts_options & 1) {
      follow = (_Bool)1;
    }
  }
  if (sp->fts_options & 2) {
    goto _L;
  } else
  if (follow) {
    _L: 
    tmp___3 = stat((char const   * __restrict  )p->fts_accpath, (struct stat * __restrict  )sbp);
    if (tmp___3) {
      tmp = __errno_location();
      saved_errno = *tmp;
      tmp___1 = __errno_location();
      if (*tmp___1 == 2) {
        tmp___2 = lstat((char const   * __restrict  )p->fts_accpath, (struct stat * __restrict  )sbp);
        if (tmp___2 == 0) {
          tmp___0 = __errno_location();
          *tmp___0 = 0;
          return ((unsigned short)13);
        }
      }
      p->fts_errno = saved_errno;
      goto err;
    }
  } else {
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   * __restrict  )p->fts_accpath,
                      (struct stat * __restrict  )sbp, 256);
    if (tmp___5) {
      tmp___4 = __errno_location();
      p->fts_errno = *tmp___4;
      err: 
      memset((void *)sbp, 0, sizeof(struct stat ));
      return ((unsigned short)10);
    }
  }
  if ((sbp->st_mode & 61440U) == 16384U) {
    if (sp->fts_options & 32) {
      tmp___6 = 0;
    } else {
      tmp___6 = 2;
    }
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
    if ((int )p->fts_name[0] == 46) {
      if (! p->fts_name[1]) {
        goto _L___0;
      } else
      if ((int )p->fts_name[1] == 46) {
        if (! p->fts_name[2]) {
          _L___0: 
          if (p->fts_level == 0L) {
            tmp___7 = 1;
          } else {
            tmp___7 = 5;
          }
          return ((unsigned short )tmp___7);
        }
      }
    }
    return ((unsigned short)1);
  }
  if ((sbp->st_mode & 61440U) == 40960U) {
    return ((unsigned short)12);
  }
  if ((sbp->st_mode & 61440U) == 32768U) {
    return ((unsigned short)8);
  }
  return ((unsigned short)3);
}
}
static int fts_compar(void const   *a , void const   *b ) 
{ FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
  pa = (FTSENT const   **)a;
  pb = (FTSENT const   **)b;
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
  return (tmp);
}
}
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
  if (sizeof(& dummy) == sizeof(void *)) {
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
      tmp = & fts_compar;
    }
  } else {
    tmp = & fts_compar;
  }
  compare = tmp;
  if (nitems > sp->fts_nitems) {
    sp->fts_nitems = nitems + 40UL;
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
      free((void *)sp->fts_array);
      sp->fts_array = (struct _ftsent **)((void *)0);
      sp->fts_nitems = (size_t )0;
      return (head);
    } else {
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
      a = (FTSENT **)tmp___0;
      if (! a) {
        free((void *)sp->fts_array);
        sp->fts_array = (struct _ftsent **)((void *)0);
        sp->fts_nitems = (size_t )0;
        return (head);
      }
    }
    sp->fts_array = a;
  }
  ap = sp->fts_array;
  p = head;
  while (p) {
    tmp___1 = ap;
    ap ++;
    *tmp___1 = p;
    p = p->fts_link;
  }
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
  ap = sp->fts_array;
  head = *ap;
  while (1) {
    nitems --;
    if (! nitems) {
      break;
    }
    (*(ap + 0))->fts_link = *(ap + 1);
    ap ++;
  }
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
  return (head);
}
}
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
  len = sizeof(FTSENT ) + namelen;
  tmp = malloc(len);
  p = (FTSENT *)tmp;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return ((FTSENT *)((void *)0));
  }
  memmove((void *)(p->fts_name), (void const   *)name, namelen);
  p->fts_name[namelen] = (char )'\000';
  p->fts_namelen = namelen;
  p->fts_fts = sp;
  p->fts_path = sp->fts_path;
  p->fts_errno = 0;
  p->fts_dirp = (DIR *)((void *)0);
  p->fts_flags = (unsigned short)0;
  p->fts_instr = (unsigned short)3;
  p->fts_number = 0L;
  p->fts_pointer = (void *)0;
  return (p);
}
}
static void fts_lfree(FTSENT *head ) 
{ register FTSENT *p ;

  {
  while (1) {
    p = head;
    if (! p) {
      break;
    }
    head = head->fts_link;
    if (p->fts_dirp) {
      closedir(p->fts_dirp);
    }
    free((void *)p);
  }
  return;
}
}
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
  new_len = (sp->fts_pathlen + more) + 256UL;
  if (new_len < sp->fts_pathlen) {
    free((void *)sp->fts_path);
    sp->fts_path = (char *)((void *)0);
    tmp = __errno_location();
    *tmp = 36;
    return ((_Bool)0);
  }
  sp->fts_pathlen = new_len;
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
  p = (char *)tmp___0;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    free((void *)sp->fts_path);
    sp->fts_path = (char *)((void *)0);
    return ((_Bool)0);
  }
  sp->fts_path = p;
  return ((_Bool)1);
}
}
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ FTSENT *p ;
  char *addr ;

  {
  addr = sp->fts_path;
  p = sp->fts_child;
  while (p) {
    while (1) {
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
      p->fts_path = addr;
      break;
    }
    p = p->fts_link;
  }
  p = head;
  while (p->fts_level >= 0L) {
    while (1) {
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
      p->fts_path = addr;
      break;
    }
    if (p->fts_link) {
      p = p->fts_link;
    } else {
      p = p->fts_parent;
    }
  }
  return;
}
}
static size_t fts_maxarglen(char * const  *argv ) 
{ size_t len ;
  size_t max ;

  {
  max = (size_t )0;
  while (*argv) {
    len = strlen((char const   *)*argv);
    if (len > max) {
      max = len;
    }
    argv ++;
  }
  return (max + 1UL);
}
}
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ int ret ;
  _Bool is_dotdot ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___7 ;
  struct stat sb ;
  int tmp___8 ;
  int *tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int oerrno ;
  int *tmp___17 ;
  int *tmp___18 ;

  {
  if (dir) {
    if (0) {
      __s1_len = __builtin_strlen(dir);
      __s2_len = __builtin_strlen("..");
      if (! ((size_t )((void const   *)(dir + 1)) - (size_t )((void const   *)dir) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
          tmp___5 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
      } else {
        tmp___5 = 0;
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp(dir, "..");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp(dir, "..");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp(dir, "..");
      tmp___4 = tmp___3;
    }
    if (tmp___4 == 0) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  is_dotdot = (_Bool )tmp___6;
  if (sp->fts_options & 4) {
    if (sp->fts_options & 512) {
      if (0 <= fd) {
        close(fd);
      }
    }
    return (0);
  }
  if (fd < 0) {
    if (is_dotdot) {
      if (sp->fts_options & 512) {
        tmp___7 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
        if (! tmp___7) {
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
          is_dotdot = (_Bool)1;
          if (0 <= parent_fd) {
            fd = parent_fd;
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
  newfd = fd;
  if (fd < 0) {
    newfd = diropen((FTS const   *)sp, dir);
    if (newfd < 0) {
      return (-1);
    }
  }
  if (sp->fts_options & 2) {
    goto _L___3;
  } else
  if (dir) {
    if (0) {
      __s1_len___0 = __builtin_strlen(dir);
      __s2_len___0 = __builtin_strlen("..");
      if (! ((size_t )((void const   *)(dir + 1)) - (size_t )((void const   *)dir) == 1UL)) {
        goto _L___2;
      } else
      if (__s1_len___0 >= 4UL) {
        _L___2: 
        if (! ((size_t )((void const   *)(".." + 1)) - (size_t )((void const   *)"..") == 1UL)) {
          tmp___16 = 1;
        } else
        if (__s2_len___0 >= 4UL) {
          tmp___16 = 1;
        } else {
          tmp___16 = 0;
        }
      } else {
        tmp___16 = 0;
      }
      if (tmp___16) {
        tmp___11 = __builtin_strcmp(dir, "..");
        tmp___15 = tmp___11;
      } else {
        tmp___14 = __builtin_strcmp(dir, "..");
        tmp___15 = tmp___14;
      }
    } else {
      tmp___14 = __builtin_strcmp(dir, "..");
      tmp___15 = tmp___14;
    }
    if (tmp___15 == 0) {
      _L___3: 
      tmp___8 = fstat(newfd, & sb);
      if (tmp___8) {
        ret = -1;
        goto bail;
      }
      if (p->fts_statp[0].st_dev != sb.st_dev) {
        tmp___9 = __errno_location();
        *tmp___9 = 2;
        ret = -1;
        goto bail;
      } else
      if (p->fts_statp[0].st_ino != sb.st_ino) {
        tmp___9 = __errno_location();
        *tmp___9 = 2;
        ret = -1;
        goto bail;
      }
    }
  }
  if (sp->fts_options & 512) {
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
    return (0);
  }
  ret = fchdir(newfd);
  bail: 
  if (fd < 0) {
    tmp___17 = __errno_location();
    oerrno = *tmp___17;
    close(newfd);
    tmp___18 = __errno_location();
    *tmp___18 = oerrno;
  }
  return (ret);
}
}
int rpl_futimens(int fd , struct timespec  const  *times ) 
{ int tmp ;

  {
  tmp = fdutimens(fd, (char const   *)((void *)0), times);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
char *rpl_getcwd(char *buf___1 , size_t size ) 
{ int fd ;
  _Bool fd_needs_closing ;
  DIR *dirstream ;
  dev_t rootdev ;
  dev_t thisdev ;
  ino_t rootino ;
  ino_t thisino ;
  char *dir ;
  register char *dirp ;
  struct stat st ;
  size_t allocated ;
  size_t used ;
  char __attribute__((__warn_unused_result__, __artificial__))  *tmp ;
  int *tmp___0 ;
  char big_buffer[4096] ;
  char __attribute__((__warn_unused_result__, __artificial__))  *tmp___1 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct dirent *d ;
  dev_t dotdev ;
  ino_t dotino ;
  _Bool mount_point ;
  int parent_status ;
  size_t dirroom ;
  size_t namlen ;
  _Bool use_d_ino ;
  int __attribute__((__artificial__))  tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  _Bool match ;
  int tmp___22 ;
  int entry_status ;
  int *tmp___23 ;
  char *tmp___24 ;
  size_t oldsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  void __attribute__((__artificial__))  *tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  int *tmp___30 ;
  int save ;
  int *tmp___31 ;
  int *tmp___32 ;

  {
  fd = -100;
  fd_needs_closing = (_Bool)0;
  dirstream = (DIR *)((void *)0);
  allocated = size;
  tmp = getcwd(buf___1, size);
  dir = (char *)tmp;
  if (dir) {
    return (dir);
  } else
  if (size) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 34) {
      return (dir);
    }
  }
  tmp___8 = __errno_location();
  if (*tmp___8 == 22) {
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
      if (size == 0UL) {
        tmp___1 = getcwd(big_buffer, sizeof(big_buffer));
        dir = (char *)tmp___1;
        if (dir) {
          tmp___7 = __strdup((char const   *)dir);
          return (tmp___7);
        }
      }
    }
  }
  tmp___9 = __errno_location();
  if (*tmp___9 != 34) {
    tmp___10 = __errno_location();
    if (*tmp___10 != 36) {
      tmp___11 = __errno_location();
      if (*tmp___11 != 2) {
        return ((char *)((void *)0));
      }
    }
  }
  if (size == 0UL) {
    if ((unsigned long )buf___1 != (unsigned long )((void *)0)) {
      tmp___12 = __errno_location();
      *tmp___12 = 22;
      return ((char *)((void *)0));
    }
    allocated = (size_t )4096;
  }
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
    tmp___13 = malloc(allocated);
    dir = (char *)tmp___13;
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      return ((char *)((void *)0));
    }
  } else {
    dir = buf___1;
  }
  dirp = dir + allocated;
  dirp --;
  *dirp = (char )'\000';
  tmp___14 = lstat((char const   * __restrict  )".", (struct stat * __restrict  )(& st));
  if (tmp___14 < 0) {
    goto lose;
  }
  thisdev = st.st_dev;
  thisino = st.st_ino;
  tmp___15 = lstat((char const   * __restrict  )"/", (struct stat * __restrict  )(& st));
  if (tmp___15 < 0) {
    goto lose;
  }
  rootdev = st.st_dev;
  rootino = st.st_ino;
  while (1) {
    if (thisdev == rootdev) {
      if (thisino == rootino) {
        break;
      }
    }
    use_d_ino = (_Bool)1;
    tmp___16 = openat(fd, "..", 0);
    fd = (int )tmp___16;
    if (fd < 0) {
      goto lose;
    }
    fd_needs_closing = (_Bool)1;
    parent_status = fstat(fd, & st);
    if (parent_status != 0) {
      goto lose;
    }
    if (dirstream) {
      tmp___17 = closedir(dirstream);
      if (tmp___17 != 0) {
        dirstream = (DIR *)((void *)0);
        goto lose;
      }
    }
    dotdev = st.st_dev;
    dotino = st.st_ino;
    mount_point = (_Bool )(dotdev != thisdev);
    dirstream = fdopendir(fd);
    if ((unsigned long )dirstream == (unsigned long )((void *)0)) {
      goto lose;
    }
    fd_needs_closing = (_Bool)0;
    while (1) {
      tmp___18 = __errno_location();
      *tmp___18 = 0;
      d = readdir(dirstream);
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        tmp___19 = __errno_location();
        if (*tmp___19 == 0) {
          if (use_d_ino) {
            use_d_ino = (_Bool)0;
            rewinddir(dirstream);
            d = readdir(dirstream);
          }
        }
      }
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        tmp___21 = __errno_location();
        if (*tmp___21 == 0) {
          tmp___20 = __errno_location();
          *tmp___20 = 2;
        }
        goto lose;
      }
      if ((int )d->d_name[0] == 46) {
        if ((int )d->d_name[1] == 0) {
          goto __Cont;
        } else
        if ((int )d->d_name[1] == 46) {
          if ((int )d->d_name[2] == 0) {
            goto __Cont;
          }
        }
      }
      if (use_d_ino) {
        if (d->d_ino == thisino) {
          tmp___22 = 1;
        } else
        if (mount_point) {
          tmp___22 = 1;
        } else {
          tmp___22 = 0;
        }
        match = (_Bool )tmp___22;
        if (! match) {
          goto __Cont;
        }
      }
      entry_status = fstatat(fd, (char const   * __restrict  )(d->d_name), (struct stat * __restrict  )(& st),
                             256);
      if (entry_status == 0) {
        if ((st.st_mode & 61440U) == 16384U) {
          if (st.st_dev == thisdev) {
            if (st.st_ino == thisino) {
              break;
            }
          }
        }
      }
      __Cont: ;
    }
    dirroom = (size_t )(dirp - dir);
    namlen = strlen((char const   *)(d->d_name));
    if (dirroom <= namlen) {
      if (size != 0UL) {
        tmp___23 = __errno_location();
        *tmp___23 = 34;
        goto lose;
      } else {
        oldsize = allocated;
        if (allocated < namlen) {
          tmp___25 = namlen;
        } else {
          tmp___25 = allocated;
        }
        allocated += tmp___25;
        if (allocated < oldsize) {
          goto memory_exhausted;
        } else {
          tmp___26 = realloc((void *)dir, allocated);
          tmp___24 = (char *)tmp___26;
          if (! tmp___24) {
            goto memory_exhausted;
          }
        }
        tmp___27 = memcpy((void * __restrict  )((tmp___24 + allocated) - (oldsize - dirroom)),
                          (void const   * __restrict  )(tmp___24 + dirroom), oldsize - dirroom);
        dirp = (char *)tmp___27;
        dir = tmp___24;
      }
    }
    dirp -= namlen;
    memcpy((void * __restrict  )dirp, (void const   * __restrict  )(d->d_name), namlen);
    dirp --;
    *dirp = (char )'/';
    thisdev = dotdev;
    thisino = dotino;
  }
  if (dirstream) {
    tmp___28 = closedir(dirstream);
    if (tmp___28 != 0) {
      dirstream = (DIR *)((void *)0);
      goto lose;
    }
  }
  if ((unsigned long )dirp == (unsigned long )(dir + (allocated - 1UL))) {
    dirp --;
    *dirp = (char )'/';
  }
  used = (size_t )((dir + allocated) - dirp);
  memmove((void *)dir, (void const   *)dirp, used);
  if (size == 0UL) {
    tmp___29 = realloc((void *)dir, used);
    buf___1 = (char *)tmp___29;
  }
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
    buf___1 = dir;
  }
  return (buf___1);
  memory_exhausted: 
  tmp___30 = __errno_location();
  *tmp___30 = 12;
  lose: 
  tmp___31 = __errno_location();
  save = *tmp___31;
  if (dirstream) {
    closedir(dirstream);
  }
  if (fd_needs_closing) {
    close(fd);
  }
  if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
    free((void *)dir);
  }
  tmp___32 = __errno_location();
  *tmp___32 = save;
  return ((char *)((void *)0));
}
}
__inline static xtime_t xtime_make(xtime_t s , long ns ) 
{ 

  {
  return (1000000000LL * s + (xtime_t )ns);
}
}
xtime_t gethrxtime(void) ;
xtime_t gethrxtime(void) 
{ struct timespec ts ;
  xtime_t tmp ;
  int tmp___0 ;
  struct timespec ts___0 ;
  xtime_t tmp___1 ;

  {
  tmp___0 = clock_gettime(1, & ts);
  if (tmp___0 == 0) {
    tmp = xtime_make((xtime_t )ts.tv_sec, ts.tv_nsec);
    return (tmp);
  }
  gettime(& ts___0);
  tmp___1 = xtime_make((xtime_t )ts___0.tv_sec, ts___0.tv_nsec);
  return (tmp___1);
}
}
char *rpl_optarg  ;
int rpl_optopt ;
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring )  __attribute__((__nonnull__(2,3))) ;
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
int rpl_optind  =    1;
int rpl_opterr  =    1;
int rpl_optopt  =    '?';
static struct _getopt_data getopt_data  ;
static void exchange(char **argv , struct _getopt_data *d ) 
{ int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
  bottom = d->__first_nonopt;
  middle = d->__last_nonopt;
  top = d->rpl_optind;
  while (1) {
    if (top > middle) {
      if (! (middle > bottom)) {
        break;
      }
    } else {
      break;
    }
    if (top - middle > middle - bottom) {
      len = middle - bottom;
      i = 0;
      while (i < len) {
        tem = *(argv + (bottom + i));
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
        *(argv + ((top - (middle - bottom)) + i)) = tem;
        i ++;
      }
      top -= len;
    } else {
      len___0 = top - middle;
      i___0 = 0;
      while (i___0 < len___0) {
        tem = *(argv + (bottom + i___0));
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
        *(argv + (middle + i___0)) = tem;
        i___0 ++;
      }
      bottom += len___0;
    }
  }
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
  d->__last_nonopt = d->rpl_optind;
  return;
}
}
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct ) 
{ int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp = d->rpl_optind;
  d->__last_nonopt = tmp;
  d->__first_nonopt = tmp;
  d->__nextchar = (char *)((void *)0);
  if (posixly_correct) {
    tmp___1 = 1;
  } else {
    tmp___0 = getenv("POSIXLY_CORRECT");
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  d->__posixly_correct = tmp___1;
  if ((int const   )*(optstring + 0) == 45) {
    d->__ordering = (enum __ord )2;
    optstring ++;
  } else
  if ((int const   )*(optstring + 0) == 43) {
    d->__ordering = (enum __ord )0;
    optstring ++;
  } else
  if (d->__posixly_correct) {
    d->__ordering = (enum __ord )0;
  } else {
    d->__ordering = (enum __ord )1;
  }
  return (optstring);
}
}
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) 
{ int print_errors ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct option_list first ;
  char *tmp___23 ;
  size_t tmp___24 ;
  struct option_list *pn ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___36 ;
  char *tmp___38 ;
  char c ;
  char *tmp___39 ;
  char const   *temp ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *tmp___59 ;
  size_t tmp___60 ;
  char *tmp___61 ;
  size_t tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;
  size_t tmp___65 ;
  int tmp___66 ;
  size_t tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;

  {
  print_errors = d->rpl_opterr;
  if (argc < 1) {
    return (-1);
  }
  d->rpl_optarg = (char *)((void *)0);
  if (d->rpl_optind == 0) {
    goto _L;
  } else
  if (! d->__initialized) {
    _L: 
    if (d->rpl_optind == 0) {
      d->rpl_optind = 1;
    }
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
    d->__initialized = 1;
  } else
  if ((int const   )*(optstring + 0) == 45) {
    optstring ++;
  } else
  if ((int const   )*(optstring + 0) == 43) {
    optstring ++;
  }
  if ((int const   )*(optstring + 0) == 58) {
    print_errors = 0;
  }
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
    goto _L___5;
  } else
  if ((int )*(d->__nextchar) == 0) {
    _L___5: 
    if (d->__last_nonopt > d->rpl_optind) {
      d->__last_nonopt = d->rpl_optind;
    }
    if (d->__first_nonopt > d->rpl_optind) {
      d->__first_nonopt = d->rpl_optind;
    }
    if ((unsigned int )d->__ordering == 1U) {
      if (d->__first_nonopt != d->__last_nonopt) {
        if (d->__last_nonopt != d->rpl_optind) {
          exchange(argv, d);
        } else {
          goto _L___0;
        }
      } else
      _L___0: 
      if (d->__last_nonopt != d->rpl_optind) {
        d->__first_nonopt = d->rpl_optind;
      }
      while (1) {
        if (d->rpl_optind < argc) {
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
              break;
            }
          }
        } else {
          break;
        }
        (d->rpl_optind) ++;
      }
      d->__last_nonopt = d->rpl_optind;
    }
    if (d->rpl_optind != argc) {
      if (0) {
        __s1_len = __builtin_strlen((char const   *)*(argv + d->rpl_optind));
        __s2_len = __builtin_strlen("--");
        if (! ((size_t )((void const   *)(*(argv + d->rpl_optind) + 1)) - (size_t )((void const   *)*(argv + d->rpl_optind)) == 1UL)) {
          goto _L___3;
        } else
        if (__s1_len >= 4UL) {
          _L___3: 
          if (! ((size_t )((void const   *)("--" + 1)) - (size_t )((void const   *)"--") == 1UL)) {
            tmp___5 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___5 = 1;
          } else {
            tmp___5 = 0;
          }
        } else {
          tmp___5 = 0;
        }
        if (tmp___5) {
          tmp___0 = __builtin_strcmp((char const   *)*(argv + d->rpl_optind), "--");
          tmp___4 = tmp___0;
        } else {
          tmp___3 = __builtin_strcmp((char const   *)*(argv + d->rpl_optind), "--");
          tmp___4 = tmp___3;
        }
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(argv + d->rpl_optind), "--");
        tmp___4 = tmp___3;
      }
      if (! tmp___4) {
        (d->rpl_optind) ++;
        if (d->__first_nonopt != d->__last_nonopt) {
          if (d->__last_nonopt != d->rpl_optind) {
            exchange(argv, d);
          } else {
            goto _L___1;
          }
        } else
        _L___1: 
        if (d->__first_nonopt == d->__last_nonopt) {
          d->__first_nonopt = d->rpl_optind;
        }
        d->__last_nonopt = argc;
        d->rpl_optind = argc;
      }
    }
    if (d->rpl_optind == argc) {
      if (d->__first_nonopt != d->__last_nonopt) {
        d->rpl_optind = d->__first_nonopt;
      }
      return (-1);
    }
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
      goto _L___4;
    } else
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___4: 
      if ((unsigned int )d->__ordering == 0U) {
        return (-1);
      }
      tmp___6 = d->rpl_optind;
      (d->rpl_optind) ++;
      d->rpl_optarg = *(argv + tmp___6);
      return (1);
    }
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___7;
  }
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
      goto _L___10;
    } else
    if (long_only) {
      if (*(*(argv + d->rpl_optind) + 2)) {
        goto _L___10;
      } else {
        tmp___38 = __builtin_strchr((char *)optstring, (int )*(*(argv + d->rpl_optind) + 1));
        if (! tmp___38) {
          _L___10: 
          pfound = (struct rpl_option  const  *)((void *)0);
          ambig_list = (struct option_list *)((void *)0);
          exact = 0;
          indfound = -1;
          nameend = d->__nextchar;
          while (1) {
            if (*nameend) {
              if (! ((int )*nameend != 61)) {
                break;
              }
            } else {
              break;
            }
            nameend ++;
          }
          namelen = (unsigned int )(nameend - d->__nextchar);
          p = longopts;
          option_index = 0;
          while (p->name) {
            if (0) {
              if (0) {
                __s1_len___0 = __builtin_strlen((char const   *)p->name);
                __s2_len___0 = __builtin_strlen((char const   *)d->__nextchar);
                if (! ((size_t )((void const   *)(p->name + 1)) - (size_t )((void const   *)p->name) == 1UL)) {
                  goto _L___7;
                } else
                if (__s1_len___0 >= 4UL) {
                  _L___7: 
                  if (! ((size_t )((void const   *)(d->__nextchar + 1)) - (size_t )((void const   *)d->__nextchar) == 1UL)) {
                    tmp___18 = 1;
                  } else
                  if (__s2_len___0 >= 4UL) {
                    tmp___18 = 1;
                  } else {
                    tmp___18 = 0;
                  }
                } else {
                  tmp___18 = 0;
                }
                if (tmp___18) {
                  tmp___13 = __builtin_strcmp((char const   *)p->name, (char const   *)d->__nextchar);
                  tmp___17 = tmp___13;
                } else {
                  tmp___16 = __builtin_strcmp((char const   *)p->name, (char const   *)d->__nextchar);
                  tmp___17 = tmp___16;
                }
              } else {
                tmp___16 = __builtin_strcmp((char const   *)p->name, (char const   *)d->__nextchar);
                tmp___17 = tmp___16;
              }
              tmp___20 = tmp___17;
            } else {
              tmp___19 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                                 (size_t )namelen);
              tmp___20 = tmp___19;
            }
            if (! tmp___20) {
              tmp___9 = strlen((char const   *)p->name);
              if (namelen == (unsigned int )tmp___9) {
                pfound = p;
                indfound = option_index;
                exact = 1;
                break;
              } else
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
                pfound = p;
                indfound = option_index;
              } else
              if (long_only) {
                tmp___8 = malloc(sizeof(*newp));
                newp = (struct option_list *)tmp___8;
                newp->p = p;
                newp->next = ambig_list;
                ambig_list = newp;
              } else
              if (pfound->has_arg != p->has_arg) {
                tmp___8 = malloc(sizeof(*newp));
                newp = (struct option_list *)tmp___8;
                newp->p = p;
                newp->next = ambig_list;
                ambig_list = newp;
              } else
              if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
                tmp___8 = malloc(sizeof(*newp));
                newp = (struct option_list *)tmp___8;
                newp->p = p;
                newp->next = ambig_list;
                ambig_list = newp;
              } else
              if (pfound->val != p->val) {
                tmp___8 = malloc(sizeof(*newp));
                newp = (struct option_list *)tmp___8;
                newp->p = p;
                newp->next = ambig_list;
                ambig_list = newp;
              }
            }
            p ++;
            option_index ++;
          }
          if ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
            if (! exact) {
              if (print_errors) {
                first.p = pfound;
                first.next = ambig_list;
                ambig_list = & first;
                tmp___23 = dcgettext((char const   *)((void *)0), "%s: option \'%s\' is ambiguous; possibilities:",
                                     5);
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___23,
                        *(argv + 0), *(argv + d->rpl_optind));
                while (1) {
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" \'--%s\'",
                          (ambig_list->p)->name);
                  ambig_list = ambig_list->next;
                  if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
                    break;
                  }
                }
                fputc('\n', stderr);
              }
              tmp___24 = strlen((char const   *)d->__nextchar);
              d->__nextchar += tmp___24;
              (d->rpl_optind) ++;
              d->rpl_optopt = 0;
              return ('?');
            }
          }
          while ((unsigned long )ambig_list != (unsigned long )((void *)0)) {
            pn = ambig_list->next;
            free((void *)ambig_list);
            ambig_list = pn;
          }
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
            option_index = indfound;
            (d->rpl_optind) ++;
            if (*nameend) {
              if (pfound->has_arg) {
                d->rpl_optarg = nameend + 1;
              } else {
                if (print_errors) {
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    tmp___25 = dcgettext((char const   *)((void *)0), "%s: option \'--%s\' doesn\'t allow an argument\n",
                                         5);
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___25,
                            *(argv + 0), pfound->name);
                  } else {
                    tmp___26 = dcgettext((char const   *)((void *)0), "%s: option \'%c%s\' doesn\'t allow an argument\n",
                                         5);
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___26,
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                  }
                }
                tmp___27 = strlen((char const   *)d->__nextchar);
                d->__nextchar += tmp___27;
                d->rpl_optopt = (int )pfound->val;
                return ('?');
              }
            } else
            if (pfound->has_arg == 1) {
              if (d->rpl_optind < argc) {
                tmp___28 = d->rpl_optind;
                (d->rpl_optind) ++;
                d->rpl_optarg = *(argv + tmp___28);
              } else {
                if (print_errors) {
                  tmp___29 = dcgettext((char const   *)((void *)0), "%s: option \'--%s\' requires an argument\n",
                                       5);
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___29,
                          *(argv + 0), pfound->name);
                }
                tmp___30 = strlen((char const   *)d->__nextchar);
                d->__nextchar += tmp___30;
                d->rpl_optopt = (int )pfound->val;
                if ((int const   )*(optstring + 0) == 58) {
                  tmp___31 = ':';
                } else {
                  tmp___31 = '?';
                }
                return (tmp___31);
              }
            }
            tmp___32 = strlen((char const   *)d->__nextchar);
            d->__nextchar += tmp___32;
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
              *longind = option_index;
            }
            if (pfound->flag) {
              *(pfound->flag) = (int )pfound->val;
              return (0);
            }
            return ((int )pfound->val);
          }
          if (! long_only) {
            goto _L___8;
          } else
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
            goto _L___8;
          } else {
            tmp___36 = __builtin_strchr((char *)optstring, (int )*(d->__nextchar));
            if ((unsigned long )tmp___36 == (unsigned long )((void *)0)) {
              _L___8: 
              if (print_errors) {
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  tmp___33 = dcgettext((char const   *)((void *)0), "%s: unrecognized option \'--%s\'\n",
                                       5);
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___33,
                          *(argv + 0), d->__nextchar);
                } else {
                  tmp___34 = dcgettext((char const   *)((void *)0), "%s: unrecognized option \'%c%s\'\n",
                                       5);
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___34,
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                }
              }
              d->__nextchar = (char *)"";
              (d->rpl_optind) ++;
              d->rpl_optopt = 0;
              return ('?');
            }
          }
        }
      }
    }
  }
  tmp___39 = d->__nextchar;
  (d->__nextchar) ++;
  c = *tmp___39;
  tmp___41 = __builtin_strchr((char *)optstring, (int )c);
  temp = (char const   *)tmp___41;
  if ((int )*(d->__nextchar) == 0) {
    (d->rpl_optind) ++;
  }
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    goto _L___11;
  } else
  if ((int )c == 58) {
    goto _L___11;
  } else
  if ((int )c == 59) {
    _L___11: 
    if (print_errors) {
      tmp___42 = dcgettext((char const   *)((void *)0), "%s: invalid option -- \'%c\'\n",
                           5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___42,
              *(argv + 0), (int )c);
    }
    d->rpl_optopt = (int )c;
    return ('?');
  }
  if ((int const   )*(temp + 0) == 87) {
    if ((int const   )*(temp + 1) == 59) {
      pfound___0 = (struct rpl_option  const  *)((void *)0);
      exact___0 = 0;
      ambig = 0;
      indfound___0 = 0;
      if ((unsigned long )longopts == (unsigned long )((void *)0)) {
        goto no_longs;
      }
      if ((int )*(d->__nextchar) != 0) {
        d->rpl_optarg = d->__nextchar;
        (d->rpl_optind) ++;
      } else
      if (d->rpl_optind == argc) {
        if (print_errors) {
          tmp___43 = dcgettext((char const   *)((void *)0), "%s: option requires an argument -- \'%c\'\n",
                               5);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___43,
                  *(argv + 0), (int )c);
        }
        d->rpl_optopt = (int )c;
        if ((int const   )*(optstring + 0) == 58) {
          c = (char )':';
        } else {
          c = (char )'?';
        }
        return ((int )c);
      } else {
        tmp___44 = d->rpl_optind;
        (d->rpl_optind) ++;
        d->rpl_optarg = *(argv + tmp___44);
      }
      nameend___0 = d->rpl_optarg;
      d->__nextchar = nameend___0;
      while (1) {
        if (*nameend___0) {
          if (! ((int )*nameend___0 != 61)) {
            break;
          }
        } else {
          break;
        }
        nameend___0 ++;
      }
      p___0 = longopts;
      option_index___0 = 0;
      while (p___0->name) {
        if (0) {
          if (0) {
            __s1_len___1 = __builtin_strlen((char const   *)p___0->name);
            __s2_len___1 = __builtin_strlen((char const   *)d->__nextchar);
            if (! ((size_t )((void const   *)(p___0->name + 1)) - (size_t )((void const   *)p___0->name) == 1UL)) {
              goto _L___13;
            } else
            if (__s1_len___1 >= 4UL) {
              _L___13: 
              if (! ((size_t )((void const   *)(d->__nextchar + 1)) - (size_t )((void const   *)d->__nextchar) == 1UL)) {
                tmp___54 = 1;
              } else
              if (__s2_len___1 >= 4UL) {
                tmp___54 = 1;
              } else {
                tmp___54 = 0;
              }
            } else {
              tmp___54 = 0;
            }
            if (tmp___54) {
              tmp___49 = __builtin_strcmp((char const   *)p___0->name, (char const   *)d->__nextchar);
              tmp___53 = tmp___49;
            } else {
              tmp___52 = __builtin_strcmp((char const   *)p___0->name, (char const   *)d->__nextchar);
              tmp___53 = tmp___52;
            }
          } else {
            tmp___52 = __builtin_strcmp((char const   *)p___0->name, (char const   *)d->__nextchar);
            tmp___53 = tmp___52;
          }
          tmp___56 = tmp___53;
        } else {
          tmp___55 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                             (size_t )(nameend___0 - d->__nextchar));
          tmp___56 = tmp___55;
        }
        if (! tmp___56) {
          tmp___45 = strlen((char const   *)p___0->name);
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___45) {
            pfound___0 = p___0;
            indfound___0 = option_index___0;
            exact___0 = 1;
            break;
          } else
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
            pfound___0 = p___0;
            indfound___0 = option_index___0;
          } else
          if (long_only) {
            ambig = 1;
          } else
          if (pfound___0->has_arg != p___0->has_arg) {
            ambig = 1;
          } else
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
            ambig = 1;
          } else
          if (pfound___0->val != p___0->val) {
            ambig = 1;
          }
        }
        p___0 ++;
        option_index___0 ++;
      }
      if (ambig) {
        if (! exact___0) {
          if (print_errors) {
            tmp___59 = dcgettext((char const   *)((void *)0), "%s: option \'-W %s\' is ambiguous\n",
                                 5);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___59,
                    *(argv + 0), d->rpl_optarg);
          }
          tmp___60 = strlen((char const   *)d->__nextchar);
          d->__nextchar += tmp___60;
          (d->rpl_optind) ++;
          return ('?');
        }
      }
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
        option_index___0 = indfound___0;
        if (*nameend___0) {
          if (pfound___0->has_arg) {
            d->rpl_optarg = nameend___0 + 1;
          } else {
            if (print_errors) {
              tmp___61 = dcgettext((char const   *)((void *)0), "%s: option \'-W %s\' doesn\'t allow an argument\n",
                                   5);
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___61,
                      *(argv + 0), pfound___0->name);
            }
            tmp___62 = strlen((char const   *)d->__nextchar);
            d->__nextchar += tmp___62;
            return ('?');
          }
        } else
        if (pfound___0->has_arg == 1) {
          if (d->rpl_optind < argc) {
            tmp___63 = d->rpl_optind;
            (d->rpl_optind) ++;
            d->rpl_optarg = *(argv + tmp___63);
          } else {
            if (print_errors) {
              tmp___64 = dcgettext((char const   *)((void *)0), "%s: option \'-W %s\' requires an argument\n",
                                   5);
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___64,
                      *(argv + 0), pfound___0->name);
            }
            tmp___65 = strlen((char const   *)d->__nextchar);
            d->__nextchar += tmp___65;
            if ((int const   )*(optstring + 0) == 58) {
              tmp___66 = ':';
            } else {
              tmp___66 = '?';
            }
            return (tmp___66);
          }
        } else {
          d->rpl_optarg = (char *)((void *)0);
        }
        tmp___67 = strlen((char const   *)d->__nextchar);
        d->__nextchar += tmp___67;
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
          *longind = option_index___0;
        }
        if (pfound___0->flag) {
          *(pfound___0->flag) = (int )pfound___0->val;
          return (0);
        }
        return ((int )pfound___0->val);
      }
      no_longs: 
      d->__nextchar = (char *)((void *)0);
      return ('W');
    }
  }
  if ((int const   )*(temp + 1) == 58) {
    if ((int const   )*(temp + 2) == 58) {
      if ((int )*(d->__nextchar) != 0) {
        d->rpl_optarg = d->__nextchar;
        (d->rpl_optind) ++;
      } else {
        d->rpl_optarg = (char *)((void *)0);
      }
      d->__nextchar = (char *)((void *)0);
    } else {
      if ((int )*(d->__nextchar) != 0) {
        d->rpl_optarg = d->__nextchar;
        (d->rpl_optind) ++;
      } else
      if (d->rpl_optind == argc) {
        if (print_errors) {
          tmp___68 = dcgettext((char const   *)((void *)0), "%s: option requires an argument -- \'%c\'\n",
                               5);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___68,
                  *(argv + 0), (int )c);
        }
        d->rpl_optopt = (int )c;
        if ((int const   )*(optstring + 0) == 58) {
          c = (char )':';
        } else {
          c = (char )'?';
        }
      } else {
        tmp___69 = d->rpl_optind;
        (d->rpl_optind) ++;
        d->rpl_optarg = *(argv + tmp___69);
      }
      d->__nextchar = (char *)((void *)0);
    }
  }
  return ((int )c);
}
}
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ int result ;

  {
  getopt_data.rpl_optind = rpl_optind;
  getopt_data.rpl_opterr = rpl_opterr;
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
  rpl_optind = getopt_data.rpl_optind;
  rpl_optarg = getopt_data.rpl_optarg;
  rpl_optopt = getopt_data.rpl_optopt;
  return (result);
}
}
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring )  __attribute__((__nonnull__(2,3))) ;
int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) 
{ int tmp ;

  {
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
  return (tmp);
}
}
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options ,
                                                       struct rpl_option  const  *long_options___1 ,
                                                       int *opt_index )  __attribute__((__nonnull__(2,3))) ;
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                   int *opt_index , struct _getopt_data *d ) ;
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                        int *opt_index , struct _getopt_data *d ) ;
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options ,
                                                  struct rpl_option  const  *long_options___1 ,
                                                  int *opt_index )  __attribute__((__nonnull__(2,3))) ;
int rpl_getopt_long(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                    int *opt_index ) 
{ int tmp ;

  {
  tmp = rpl_getopt_internal(argc, argv, options, long_options___1, opt_index, 0, 0);
  return (tmp);
}
}
int _getopt_long_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                   int *opt_index , struct _getopt_data *d ) 
{ int tmp ;

  {
  tmp = _getopt_internal_r(argc, argv, options, long_options___1, opt_index, 0, d,
                           0);
  return (tmp);
}
}
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options ,
                                                       struct rpl_option  const  *long_options___1 ,
                                                       int *opt_index )  __attribute__((__nonnull__(2,3))) ;
int rpl_getopt_long_only(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                         int *opt_index ) 
{ int tmp ;

  {
  tmp = rpl_getopt_internal(argc, argv, options, long_options___1, opt_index, 1, 0);
  return (tmp);
}
}
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct rpl_option  const  *long_options___1 ,
                        int *opt_index , struct _getopt_data *d ) 
{ int tmp ;

  {
  tmp = _getopt_internal_r(argc, argv, options, long_options___1, opt_index, 1, d,
                           0);
  return (tmp);
}
}
char *gnu_getpass(char const   *prompt )  __attribute__((__nonnull__(1))) ;
extern int fflush_unlocked(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int __fsetlocking(FILE *__fp , int __type ) ;
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
static void call_fclose(void *arg ) 
{ 

  {
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    rpl_fclose((FILE *)arg);
  }
  return;
}
}
static char *buf  ;
static size_t bufsize  ;
char *gnu_getpass(char const   *prompt )  __attribute__((__nonnull__(1))) ;
char *gnu_getpass(char const   *prompt ) 
{ FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tty_changed = (_Bool)0;
  tty = fopen((char const   * __restrict  )"/dev/tty", (char const   * __restrict  )"w+");
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
    in = stdin;
    out = stderr;
  } else {
    __fsetlocking(tty, 2);
    in = tty;
    out = in;
  }
  tmp___1 = fileno(in);
  tmp___2 = tcgetattr(tmp___1, & t);
  if (tmp___2 == 0) {
    s = t;
    t.c_lflag &= 4294967286U;
    tmp = fileno(in);
    tmp___0 = tcsetattr(tmp, 2, (struct termios  const  *)(& t));
    tty_changed = (_Bool )(tmp___0 == 0);
  }
  fputs_unlocked((char const   * __restrict  )prompt, (FILE * __restrict  )out);
  fflush_unlocked(out);
  nread = getline((char ** __restrict  )(& buf), (size_t * __restrict  )(& bufsize),
                  (FILE * __restrict  )in);
  rpl_fseeko(out, (off_t )0, 1);
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    if (nread < 0L) {
      *(buf + 0) = (char )'\000';
    } else
    if ((int )*(buf + (nread - 1L)) == 10) {
      *(buf + (nread - 1L)) = (char )'\000';
      if (tty_changed) {
        fputc_unlocked('\n', out);
      }
    }
  }
  if (tty_changed) {
    tmp___3 = fileno(in);
    tcsetattr(tmp___3, 2, (struct termios  const  *)(& s));
  }
  call_fclose((void *)tty);
  return (buf);
}
}
int isapipe(int fd ) ;
int isapipe(int fd ) 
{ nlink_t pipe_link_count_max ;
  _Bool check_for_fifo ;
  struct stat st ;
  int fstat_result ;
  int tmp ;
  int tmp___4 ;
  int tmp___5 ;

  {
  pipe_link_count_max = (nlink_t )1;
  check_for_fifo = (_Bool)1;
  tmp = fstat(fd, & st);
  fstat_result = tmp;
  if (fstat_result != 0) {
    return (fstat_result);
  }
  if (st.st_nlink <= pipe_link_count_max) {
    if (check_for_fifo) {
      tmp___4 = (st.st_mode & 61440U) == 4096U;
    } else {
      tmp___4 = (st.st_mode & 61440U) == 49152U;
    }
    if (tmp___4) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  return (tmp___5);
}
}
int rpl_isnanl(long double x ) ;
int rpl_isnanl(long double x ) 
{ memory_double m ;
  unsigned int exponent ;

  {
  m.value = x;
  exponent = m.word[2] & 32767U;
  if (exponent == 0U) {
    return ((int )(m.word[1] >> 31));
  } else
  if (exponent == 32767U) {
    return (((m.word[1] ^ 2147483648U) | m.word[0]) != 0U);
  } else {
    return ((int )((m.word[1] >> 31) ^ 1U));
  }
}
}
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags )  __attribute__((__warn_unused_result__,
__nonnull__(2,4))) ;
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag )  __attribute__((__nonnull__(2,4))) ;
static int linkat_follow(int fd1 , char const   *file1 , int fd2 , char const   *file2 ) 
{ char *name ;
  char *target ;
  int result ;
  int i ;
  char *dir ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int saved_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int saved_errno___0 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
  name = (char *)file1;
  i = 20;
  while (1) {
    tmp___2 = i;
    i --;
    if (tmp___2) {
      target = areadlinkat(fd1, (char const   *)name);
      if (! target) {
        break;
      }
    } else {
      break;
    }
    if ((int )*(target + 0) == 47) {
      goto _L;
    } else
    if (0) {
      _L: 
      if ((unsigned long )name != (unsigned long )file1) {
        free((void *)name);
      }
      name = target;
    } else {
      tmp = mdir_name((char const   *)name);
      dir = tmp;
      if ((unsigned long )name != (unsigned long )file1) {
        free((void *)name);
      }
      if (! dir) {
        free((void *)target);
        tmp___0 = __errno_location();
        *tmp___0 = 12;
        return (-1);
      }
      name = mfile_name_concat((char const   *)dir, (char const   *)target, (char **)((void *)0));
      free((void *)dir);
      free((void *)target);
      if (! name) {
        tmp___1 = __errno_location();
        *tmp___1 = 12;
        return (-1);
      }
    }
  }
  if (i < 0) {
    target = (char *)((void *)0);
    tmp___3 = __errno_location();
    *tmp___3 = 40;
  }
  if (! target) {
    tmp___6 = __errno_location();
    if (*tmp___6 != 22) {
      if ((unsigned long )name != (unsigned long )file1) {
        tmp___4 = __errno_location();
        saved_errno = *tmp___4;
        free((void *)name);
        tmp___5 = __errno_location();
        *tmp___5 = saved_errno;
      }
      return (-1);
    }
  }
  result = linkat(fd1, (char const   *)name, fd2, file2, 0);
  if ((unsigned long )name != (unsigned long )file1) {
    tmp___7 = __errno_location();
    saved_errno___0 = *tmp___7;
    free((void *)name);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno___0;
  }
  return (result);
}
}
static int have_follow_really  ;
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag )  __attribute__((__nonnull__(2,4))) ;
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag ) 
{ int *tmp ;
  int tmp___0 ;
  int result ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  if (flag & -1025) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (! flag) {
    tmp___0 = linkat(fd1, file1, fd2, file2, flag);
    return (tmp___0);
  }
  if (0 <= have_follow_really) {
    tmp___1 = linkat(fd1, file1, fd2, file2, flag);
    result = tmp___1;
    if (result == -1) {
      tmp___2 = __errno_location();
      if (! (*tmp___2 == 22)) {
        have_follow_really = 1;
        return (result);
      }
    } else {
      have_follow_really = 1;
      return (result);
    }
    have_follow_really = -1;
  }
  tmp___3 = linkat_follow(fd1, file1, fd2, file2);
  return (tmp___3);
}
}
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
extern  __attribute__((__nothrow__)) FILE *setmntent(char const   *__file , char const   *__mode ) ;
extern  __attribute__((__nothrow__)) struct mntent *getmntent(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int endmntent(FILE *__stream ) ;
static dev_t dev_from_mount_options(char const   *mount_options ) 
{ 

  {
  return ((dev_t )-1);
}
}
struct mount_entry *read_file_system_list(_Bool need_fs_type ) 
{ struct mount_entry *mount_list___0 ;
  struct mount_entry *me ;
  struct mount_entry **mtail ;
  struct mntent *mnt ;
  char const   *table___1 ;
  FILE *fp ;
  void *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  char *tmp___44 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___53 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int saved_errno ;
  int *tmp___61 ;
  int *tmp___62 ;

  {
  mtail = & mount_list___0;
  table___1 = "/etc/mtab";
  fp = setmntent(table___1, "r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return ((struct mount_entry *)((void *)0));
  }
  while (1) {
    mnt = getmntent(fp);
    if (! mnt) {
      break;
    }
    tmp = xmalloc(sizeof(*me));
    me = (struct mount_entry *)tmp;
    me->me_devname = xstrdup((char const   *)mnt->mnt_fsname);
    me->me_mountdir = xstrdup((char const   *)mnt->mnt_dir);
    me->me_type = xstrdup((char const   *)mnt->mnt_type);
    me->me_type_malloced = 1U;
    if (0) {
      __s1_len = __builtin_strlen((char const   *)me->me_type);
      __s2_len = __builtin_strlen("autofs");
      if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
        goto _L___0;
      } else
      if (__s1_len >= 4UL) {
        _L___0: 
        if (! ((size_t )((void const   *)("autofs" + 1)) - (size_t )((void const   *)"autofs") == 1UL)) {
          tmp___6 = 1;
        } else
        if (__s2_len >= 4UL) {
          tmp___6 = 1;
        } else {
          tmp___6 = 0;
        }
      } else {
        tmp___6 = 0;
      }
      if (tmp___6) {
        tmp___1 = __builtin_strcmp((char const   *)me->me_type, "autofs");
        tmp___5 = tmp___1;
      } else {
        tmp___4 = __builtin_strcmp((char const   *)me->me_type, "autofs");
        tmp___5 = tmp___4;
      }
    } else {
      tmp___4 = __builtin_strcmp((char const   *)me->me_type, "autofs");
      tmp___5 = tmp___4;
    }
    if (tmp___5 == 0) {
      tmp___42 = 1;
    } else {
      if (0) {
        __s1_len___0 = __builtin_strlen((char const   *)me->me_type);
        __s2_len___0 = __builtin_strlen("none");
        if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
          goto _L___2;
        } else
        if (__s1_len___0 >= 4UL) {
          _L___2: 
          if (! ((size_t )((void const   *)("none" + 1)) - (size_t )((void const   *)"none") == 1UL)) {
            tmp___13 = 1;
          } else
          if (__s2_len___0 >= 4UL) {
            tmp___13 = 1;
          } else {
            tmp___13 = 0;
          }
        } else {
          tmp___13 = 0;
        }
        if (tmp___13) {
          tmp___8 = __builtin_strcmp((char const   *)me->me_type, "none");
          tmp___12 = tmp___8;
        } else {
          tmp___11 = __builtin_strcmp((char const   *)me->me_type, "none");
          tmp___12 = tmp___11;
        }
      } else {
        tmp___11 = __builtin_strcmp((char const   *)me->me_type, "none");
        tmp___12 = tmp___11;
      }
      if (tmp___12 == 0) {
        tmp___42 = 1;
      } else {
        if (0) {
          __s1_len___1 = __builtin_strlen((char const   *)me->me_type);
          __s2_len___1 = __builtin_strlen("proc");
          if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
            goto _L___4;
          } else
          if (__s1_len___1 >= 4UL) {
            _L___4: 
            if (! ((size_t )((void const   *)("proc" + 1)) - (size_t )((void const   *)"proc") == 1UL)) {
              tmp___20 = 1;
            } else
            if (__s2_len___1 >= 4UL) {
              tmp___20 = 1;
            } else {
              tmp___20 = 0;
            }
          } else {
            tmp___20 = 0;
          }
          if (tmp___20) {
            tmp___15 = __builtin_strcmp((char const   *)me->me_type, "proc");
            tmp___19 = tmp___15;
          } else {
            tmp___18 = __builtin_strcmp((char const   *)me->me_type, "proc");
            tmp___19 = tmp___18;
          }
        } else {
          tmp___18 = __builtin_strcmp((char const   *)me->me_type, "proc");
          tmp___19 = tmp___18;
        }
        if (tmp___19 == 0) {
          tmp___42 = 1;
        } else {
          if (0) {
            __s1_len___2 = __builtin_strlen((char const   *)me->me_type);
            __s2_len___2 = __builtin_strlen("subfs");
            if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
              goto _L___6;
            } else
            if (__s1_len___2 >= 4UL) {
              _L___6: 
              if (! ((size_t )((void const   *)("subfs" + 1)) - (size_t )((void const   *)"subfs") == 1UL)) {
                tmp___27 = 1;
              } else
              if (__s2_len___2 >= 4UL) {
                tmp___27 = 1;
              } else {
                tmp___27 = 0;
              }
            } else {
              tmp___27 = 0;
            }
            if (tmp___27) {
              tmp___22 = __builtin_strcmp((char const   *)me->me_type, "subfs");
              tmp___26 = tmp___22;
            } else {
              tmp___25 = __builtin_strcmp((char const   *)me->me_type, "subfs");
              tmp___26 = tmp___25;
            }
          } else {
            tmp___25 = __builtin_strcmp((char const   *)me->me_type, "subfs");
            tmp___26 = tmp___25;
          }
          if (tmp___26 == 0) {
            tmp___42 = 1;
          } else {
            if (0) {
              __s1_len___3 = __builtin_strlen((char const   *)me->me_type);
              __s2_len___3 = __builtin_strlen("kernfs");
              if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
                goto _L___8;
              } else
              if (__s1_len___3 >= 4UL) {
                _L___8: 
                if (! ((size_t )((void const   *)("kernfs" + 1)) - (size_t )((void const   *)"kernfs") == 1UL)) {
                  tmp___34 = 1;
                } else
                if (__s2_len___3 >= 4UL) {
                  tmp___34 = 1;
                } else {
                  tmp___34 = 0;
                }
              } else {
                tmp___34 = 0;
              }
              if (tmp___34) {
                tmp___29 = __builtin_strcmp((char const   *)me->me_type, "kernfs");
                tmp___33 = tmp___29;
              } else {
                tmp___32 = __builtin_strcmp((char const   *)me->me_type, "kernfs");
                tmp___33 = tmp___32;
              }
            } else {
              tmp___32 = __builtin_strcmp((char const   *)me->me_type, "kernfs");
              tmp___33 = tmp___32;
            }
            if (tmp___33 == 0) {
              tmp___42 = 1;
            } else {
              if (0) {
                __s1_len___4 = __builtin_strlen((char const   *)me->me_type);
                __s2_len___4 = __builtin_strlen("ignore");
                if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
                  goto _L___10;
                } else
                if (__s1_len___4 >= 4UL) {
                  _L___10: 
                  if (! ((size_t )((void const   *)("ignore" + 1)) - (size_t )((void const   *)"ignore") == 1UL)) {
                    tmp___41 = 1;
                  } else
                  if (__s2_len___4 >= 4UL) {
                    tmp___41 = 1;
                  } else {
                    tmp___41 = 0;
                  }
                } else {
                  tmp___41 = 0;
                }
                if (tmp___41) {
                  tmp___36 = __builtin_strcmp((char const   *)me->me_type, "ignore");
                  tmp___40 = tmp___36;
                } else {
                  tmp___39 = __builtin_strcmp((char const   *)me->me_type, "ignore");
                  tmp___40 = tmp___39;
                }
              } else {
                tmp___39 = __builtin_strcmp((char const   *)me->me_type, "ignore");
                tmp___40 = tmp___39;
              }
              if (tmp___40 == 0) {
                tmp___42 = 1;
              } else {
                tmp___42 = 0;
              }
            }
          }
        }
      }
    }
    me->me_dummy = (unsigned int )tmp___42;
    tmp___44 = __builtin_strchr(me->me_devname, ':');
    if ((unsigned long )tmp___44 != (unsigned long )((void *)0)) {
      tmp___59 = 1;
    } else
    if ((int )*(me->me_devname + 0) == 47) {
      if ((int )*(me->me_devname + 1) == 47) {
        if (0) {
          __s1_len___5 = __builtin_strlen((char const   *)me->me_type);
          __s2_len___5 = __builtin_strlen("smbfs");
          if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
            goto _L___12;
          } else
          if (__s1_len___5 >= 4UL) {
            _L___12: 
            if (! ((size_t )((void const   *)("smbfs" + 1)) - (size_t )((void const   *)"smbfs") == 1UL)) {
              tmp___51 = 1;
            } else
            if (__s2_len___5 >= 4UL) {
              tmp___51 = 1;
            } else {
              tmp___51 = 0;
            }
          } else {
            tmp___51 = 0;
          }
          if (tmp___51) {
            tmp___46 = __builtin_strcmp((char const   *)me->me_type, "smbfs");
            tmp___50 = tmp___46;
          } else {
            tmp___49 = __builtin_strcmp((char const   *)me->me_type, "smbfs");
            tmp___50 = tmp___49;
          }
        } else {
          tmp___49 = __builtin_strcmp((char const   *)me->me_type, "smbfs");
          tmp___50 = tmp___49;
        }
        if (tmp___50 == 0) {
          tmp___59 = 1;
        } else {
          if (0) {
            __s1_len___6 = __builtin_strlen((char const   *)me->me_type);
            __s2_len___6 = __builtin_strlen("cifs");
            if (! ((size_t )((void const   *)(me->me_type + 1)) - (size_t )((void const   *)me->me_type) == 1UL)) {
              goto _L___14;
            } else
            if (__s1_len___6 >= 4UL) {
              _L___14: 
              if (! ((size_t )((void const   *)("cifs" + 1)) - (size_t )((void const   *)"cifs") == 1UL)) {
                tmp___58 = 1;
              } else
              if (__s2_len___6 >= 4UL) {
                tmp___58 = 1;
              } else {
                tmp___58 = 0;
              }
            } else {
              tmp___58 = 0;
            }
            if (tmp___58) {
              tmp___53 = __builtin_strcmp((char const   *)me->me_type, "cifs");
              tmp___57 = tmp___53;
            } else {
              tmp___56 = __builtin_strcmp((char const   *)me->me_type, "cifs");
              tmp___57 = tmp___56;
            }
          } else {
            tmp___56 = __builtin_strcmp((char const   *)me->me_type, "cifs");
            tmp___57 = tmp___56;
          }
          if (tmp___57 == 0) {
            tmp___59 = 1;
          } else {
            tmp___59 = 0;
          }
        }
      } else {
        tmp___59 = 0;
      }
    } else {
      tmp___59 = 0;
    }
    me->me_remote = (unsigned int )tmp___59;
    me->me_dev = dev_from_mount_options((char const   *)mnt->mnt_opts);
    *mtail = me;
    mtail = & me->me_next;
  }
  tmp___60 = endmntent(fp);
  if (tmp___60 == 0) {
    goto free_then_fail;
  }
  *mtail = (struct mount_entry *)((void *)0);
  return (mount_list___0);
  free_then_fail: 
  tmp___61 = __errno_location();
  saved_errno = *tmp___61;
  *mtail = (struct mount_entry *)((void *)0);
  while (mount_list___0) {
    me = mount_list___0->me_next;
    free((void *)mount_list___0->me_devname);
    free((void *)mount_list___0->me_mountdir);
    if (mount_list___0->me_type_malloced) {
      free((void *)mount_list___0->me_type);
    }
    free((void *)mount_list___0);
    mount_list___0 = me;
  }
  tmp___62 = __errno_location();
  *tmp___62 = saved_errno;
  return ((struct mount_entry *)((void *)0));
}
}
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay )  __attribute__((__nonnull__(1))) ;
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) 
{ int *tmp ;
  time_t limit ;
  time_t seconds ;
  struct timespec intermediate ;
  int result ;
  int tmp___0 ;

  {
  if (requested_delay->tv_nsec < 0L) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if (1000000000L <= (long )requested_delay->tv_nsec) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  limit = (time_t )2073600;
  seconds = (time_t )requested_delay->tv_sec;
  intermediate.tv_nsec = (long )requested_delay->tv_nsec;
  while (limit < seconds) {
    intermediate.tv_sec = limit;
    result = nanosleep((struct timespec  const  *)(& intermediate), remaining_delay);
    seconds -= limit;
    if (result) {
      if (remaining_delay) {
        remaining_delay->tv_sec += seconds;
      }
      return (result);
    }
    intermediate.tv_nsec = 0L;
  }
  intermediate.tv_sec = seconds;
  tmp___0 = nanosleep((struct timespec  const  *)(& intermediate), remaining_delay);
  return (tmp___0);
}
}
char *openat_proc_name(char *buf___1 , int fd , char const   *file ) ;
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
static int proc_status  =    0;
char *openat_proc_name(char *buf___1 , int fd , char const   *file ) 
{ int proc_self_fd ;
  int __attribute__((__artificial__))  tmp ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + (sizeof("../fd") - 1UL)) + 1UL] ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *result ;
  void *tmp___3 ;

  {
  if (! *file) {
    *(buf___1 + 0) = (char )'\000';
    return (buf___1);
  }
  if (! proc_status) {
    tmp = open("/proc/self/fd", 67840);
    proc_self_fd = (int )tmp;
    if (proc_self_fd < 0) {
      proc_status = -1;
    } else {
      sprintf((char * __restrict  )(dotdot_buf), (char const   * __restrict  )"/proc/self/fd/%d/%s",
              proc_self_fd, "../fd");
      tmp___1 = access((char const   *)(dotdot_buf), 0);
      if (tmp___1) {
        proc_status = -1;
      } else {
        proc_status = 1;
      }
      close(proc_self_fd);
    }
  }
  if (proc_status < 0) {
    return ((char *)((void *)0));
  } else {
    tmp___2 = strlen(file);
    bufsize___0 = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + tmp___2) + 1UL;
    result = buf___1;
    if (4032UL < bufsize___0) {
      tmp___3 = malloc(bufsize___0);
      result = (char *)tmp___3;
      if (! result) {
        return ((char *)((void *)0));
      }
    }
    sprintf((char * __restrict  )result, (char const   * __restrict  )"/proc/self/fd/%d/%s",
            fd, file);
    return (result);
  }
}
}
int printf_fetchargs(va_list args , arguments *a ) ;
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
int printf_fetchargs(va_list args , arguments *a ) 
{ size_t i ;
  argument *ap ;
  int tmp ;
  wint_t tmp___0 ;

  {
  i = (size_t )0;
  ap = a->arg + 0;
  while (i < a->count) {
    switch ((int )ap->type) {
    case 1: 
    ap->a.a_schar = __builtin_va_arg(args, int );
    break;
    case 2: 
    ap->a.a_uchar = __builtin_va_arg(args, int );
    break;
    case 3: 
    ap->a.a_short = __builtin_va_arg(args, int );
    break;
    case 4: 
    ap->a.a_ushort = __builtin_va_arg(args, int );
    break;
    case 5: 
    ap->a.a_int = __builtin_va_arg(args, int );
    break;
    case 6: 
    ap->a.a_uint = __builtin_va_arg(args, unsigned int );
    break;
    case 7: 
    ap->a.a_longint = __builtin_va_arg(args, long );
    break;
    case 8: 
    ap->a.a_ulongint = __builtin_va_arg(args, unsigned long );
    break;
    case 9: 
    ap->a.a_longlongint = __builtin_va_arg(args, long long );
    break;
    case 10: 
    ap->a.a_ulonglongint = __builtin_va_arg(args, unsigned long long );
    break;
    case 11: 
    ap->a.a_double = __builtin_va_arg(args, double );
    break;
    case 12: 
    ap->a.a_longdouble = __builtin_va_arg(args, long double );
    break;
    case 13: 
    ap->a.a_char = __builtin_va_arg(args, int );
    break;
    case 14: 
    if (sizeof(wint_t ) < sizeof(int )) {
      tmp = __builtin_va_arg(args, int );
      ap->a.a_wide_char = (wint_t )tmp;
    } else {
      tmp___0 = __builtin_va_arg(args, wint_t );
      ap->a.a_wide_char = tmp___0;
    }
    break;
    case 15: 
    ap->a.a_string = __builtin_va_arg(args, char const   *);
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
      ap->a.a_string = "(NULL)";
    }
    break;
    case 16: 
    ap->a.a_wide_string = __builtin_va_arg(args, wchar_t const   *);
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
      ap->a.a_wide_string = wide_null_string;
    }
    break;
    case 17: 
    ap->a.a_pointer = __builtin_va_arg(args, void *);
    break;
    case 18: 
    ap->a.a_count_schar_pointer = __builtin_va_arg(args, signed char *);
    break;
    case 19: 
    ap->a.a_count_short_pointer = __builtin_va_arg(args, short *);
    break;
    case 20: 
    ap->a.a_count_int_pointer = __builtin_va_arg(args, int *);
    break;
    case 21: 
    ap->a.a_count_longint_pointer = __builtin_va_arg(args, long *);
    break;
    case 22: 
    ap->a.a_count_longlongint_pointer = __builtin_va_arg(args, long long *);
    break;
    default: 
    return (-1);
    }
    i ++;
    ap ++;
  }
  return (0);
}
}
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__))  tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
  cp = format;
  arg_posn = (size_t )0;
  max_width_length = (size_t )0;
  max_precision_length = (size_t )0;
  d->count = (size_t )0;
  d_allocated = (size_t )7;
  d->dir = d->direct_alloc_dir;
  a->count = (size_t )0;
  a_allocated = (size_t )7;
  a->arg = a->direct_alloc_arg;
  while ((int const   )*cp != 0) {
    tmp = cp;
    cp ++;
    c = (char )*tmp;
    if ((int )c == 37) {
      arg_index = ~ ((size_t )0);
      dp = d->dir + d->count;
      dp->dir_start = cp - 1;
      dp->flags = 0;
      dp->width_start = (char const   *)((void *)0);
      dp->width_end = (char const   *)((void *)0);
      dp->width_arg_index = ~ ((size_t )0);
      dp->precision_start = (char const   *)((void *)0);
      dp->precision_end = (char const   *)((void *)0);
      dp->precision_arg_index = ~ ((size_t )0);
      dp->arg_index = ~ ((size_t )0);
      if ((int const   )*cp >= 48) {
        if ((int const   )*cp <= 57) {
          np = cp;
          while (1) {
            if ((int const   )*np >= 48) {
              if (! ((int const   )*np <= 57)) {
                break;
              }
            } else {
              break;
            }
            np ++;
          }
          if ((int const   )*np == 36) {
            n = (size_t )0;
            np = cp;
            while (1) {
              if ((int const   )*np >= 48) {
                if (! ((int const   )*np <= 57)) {
                  break;
                }
              } else {
                break;
              }
              if (n <= 1844674407370955161UL) {
                tmp___0 = n * 10UL;
              } else {
                tmp___0 = 0xffffffffffffffffUL;
              }
              tmp___1 = xsum(tmp___0, (size_t )((int const   )*np - 48));
              n = (size_t )tmp___1;
              np ++;
            }
            if (n == 0UL) {
              goto error;
            }
            if (n == 0xffffffffffffffffUL) {
              goto error;
            }
            arg_index = n - 1UL;
            cp = np + 1;
          }
        }
      }
      while (1) {
        if ((int const   )*cp == 39) {
          dp->flags |= 1;
          cp ++;
        } else
        if ((int const   )*cp == 45) {
          dp->flags |= 2;
          cp ++;
        } else
        if ((int const   )*cp == 43) {
          dp->flags |= 4;
          cp ++;
        } else
        if ((int const   )*cp == 32) {
          dp->flags |= 8;
          cp ++;
        } else
        if ((int const   )*cp == 35) {
          dp->flags |= 16;
          cp ++;
        } else
        if ((int const   )*cp == 48) {
          dp->flags |= 32;
          cp ++;
        } else
        if ((int const   )*cp == 73) {
          dp->flags |= 64;
          cp ++;
        } else {
          break;
        }
      }
      if ((int const   )*cp == 42) {
        dp->width_start = cp;
        cp ++;
        dp->width_end = cp;
        if (max_width_length < 1UL) {
          max_width_length = (size_t )1;
        }
        if ((int const   )*cp >= 48) {
          if ((int const   )*cp <= 57) {
            np___0 = cp;
            while (1) {
              if ((int const   )*np___0 >= 48) {
                if (! ((int const   )*np___0 <= 57)) {
                  break;
                }
              } else {
                break;
              }
              np___0 ++;
            }
            if ((int const   )*np___0 == 36) {
              n___0 = (size_t )0;
              np___0 = cp;
              while (1) {
                if ((int const   )*np___0 >= 48) {
                  if (! ((int const   )*np___0 <= 57)) {
                    break;
                  }
                } else {
                  break;
                }
                if (n___0 <= 1844674407370955161UL) {
                  tmp___2 = n___0 * 10UL;
                } else {
                  tmp___2 = 0xffffffffffffffffUL;
                }
                tmp___3 = xsum(tmp___2, (size_t )((int const   )*np___0 - 48));
                n___0 = (size_t )tmp___3;
                np___0 ++;
              }
              if (n___0 == 0UL) {
                goto error;
              }
              if (n___0 == 0xffffffffffffffffUL) {
                goto error;
              }
              dp->width_arg_index = n___0 - 1UL;
              cp = np___0 + 1;
            }
          }
        }
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
          tmp___4 = arg_posn;
          arg_posn ++;
          dp->width_arg_index = tmp___4;
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
            goto error;
          }
        }
        n___1 = dp->width_arg_index;
        if (n___1 >= a_allocated) {
          if (a_allocated <= 9223372036854775807UL) {
            a_allocated *= 2UL;
          } else {
            a_allocated = 0xffffffffffffffffUL;
          }
          if (a_allocated <= n___1) {
            tmp___5 = xsum(n___1, (size_t )1);
            a_allocated = (size_t )tmp___5;
          }
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
            memory_size = a_allocated * sizeof(argument );
          } else {
            memory_size = 0xffffffffffffffffUL;
          }
          if (memory_size == 0xffffffffffffffffUL) {
            goto out_of_memory;
          }
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            tmp___6 = realloc((void *)a->arg, memory_size);
            tmp___8 = tmp___6;
          } else {
            tmp___7 = malloc(memory_size);
            tmp___8 = tmp___7;
          }
          memory = (argument *)tmp___8;
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
            goto out_of_memory;
          }
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            memcpy((void * __restrict  )memory, (void const   * __restrict  )a->arg,
                   a->count * sizeof(argument ));
          }
          a->arg = memory;
        }
        while (a->count <= n___1) {
          tmp___9 = a->count;
          (a->count) ++;
          (a->arg + tmp___9)->type = (arg_type )0;
        }
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
          (a->arg + n___1)->type = (arg_type )5;
        } else
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
          goto error;
        }
      } else
      if ((int const   )*cp >= 48) {
        if ((int const   )*cp <= 57) {
          dp->width_start = cp;
          while (1) {
            if ((int const   )*cp >= 48) {
              if (! ((int const   )*cp <= 57)) {
                break;
              }
            } else {
              break;
            }
            cp ++;
          }
          dp->width_end = cp;
          width_length = (size_t )(dp->width_end - dp->width_start);
          if (max_width_length < width_length) {
            max_width_length = width_length;
          }
        }
      }
      if ((int const   )*cp == 46) {
        cp ++;
        if ((int const   )*cp == 42) {
          dp->precision_start = cp - 1;
          cp ++;
          dp->precision_end = cp;
          if (max_precision_length < 2UL) {
            max_precision_length = (size_t )2;
          }
          if ((int const   )*cp >= 48) {
            if ((int const   )*cp <= 57) {
              np___1 = cp;
              while (1) {
                if ((int const   )*np___1 >= 48) {
                  if (! ((int const   )*np___1 <= 57)) {
                    break;
                  }
                } else {
                  break;
                }
                np___1 ++;
              }
              if ((int const   )*np___1 == 36) {
                n___2 = (size_t )0;
                np___1 = cp;
                while (1) {
                  if ((int const   )*np___1 >= 48) {
                    if (! ((int const   )*np___1 <= 57)) {
                      break;
                    }
                  } else {
                    break;
                  }
                  if (n___2 <= 1844674407370955161UL) {
                    tmp___10 = n___2 * 10UL;
                  } else {
                    tmp___10 = 0xffffffffffffffffUL;
                  }
                  tmp___11 = xsum(tmp___10, (size_t )((int const   )*np___1 - 48));
                  n___2 = (size_t )tmp___11;
                  np___1 ++;
                }
                if (n___2 == 0UL) {
                  goto error;
                }
                if (n___2 == 0xffffffffffffffffUL) {
                  goto error;
                }
                dp->precision_arg_index = n___2 - 1UL;
                cp = np___1 + 1;
              }
            }
          }
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
            tmp___12 = arg_posn;
            arg_posn ++;
            dp->precision_arg_index = tmp___12;
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
              goto error;
            }
          }
          n___3 = dp->precision_arg_index;
          if (n___3 >= a_allocated) {
            if (a_allocated <= 9223372036854775807UL) {
              a_allocated *= 2UL;
            } else {
              a_allocated = 0xffffffffffffffffUL;
            }
            if (a_allocated <= n___3) {
              tmp___13 = xsum(n___3, (size_t )1);
              a_allocated = (size_t )tmp___13;
            }
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
              memory_size___0 = 0xffffffffffffffffUL;
            }
            if (memory_size___0 == 0xffffffffffffffffUL) {
              goto out_of_memory;
            }
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
              tmp___14 = realloc((void *)a->arg, memory_size___0);
              tmp___16 = tmp___14;
            } else {
              tmp___15 = malloc(memory_size___0);
              tmp___16 = tmp___15;
            }
            memory___0 = (argument *)tmp___16;
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
              goto out_of_memory;
            }
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
              memcpy((void * __restrict  )memory___0, (void const   * __restrict  )a->arg,
                     a->count * sizeof(argument ));
            }
            a->arg = memory___0;
          }
          while (a->count <= n___3) {
            tmp___17 = a->count;
            (a->count) ++;
            (a->arg + tmp___17)->type = (arg_type )0;
          }
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
            (a->arg + n___3)->type = (arg_type )5;
          } else
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
            goto error;
          }
        } else {
          dp->precision_start = cp - 1;
          while (1) {
            if ((int const   )*cp >= 48) {
              if (! ((int const   )*cp <= 57)) {
                break;
              }
            } else {
              break;
            }
            cp ++;
          }
          dp->precision_end = cp;
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
          if (max_precision_length < precision_length) {
            max_precision_length = precision_length;
          }
        }
      }
      flags = 0;
      while (1) {
        if ((int const   )*cp == 104) {
          flags |= 1 << (flags & 1);
          cp ++;
        } else
        if ((int const   )*cp == 76) {
          flags |= 4;
          cp ++;
        } else
        if ((int const   )*cp == 108) {
          flags += 8;
          cp ++;
        } else
        if ((int const   )*cp == 106) {
          if (sizeof(intmax_t ) > sizeof(long )) {
            flags += 16;
          } else
          if (sizeof(intmax_t ) > sizeof(int )) {
            flags += 8;
          }
          cp ++;
        } else
        if ((int const   )*cp == 122) {
          goto _L;
        } else
        if ((int const   )*cp == 90) {
          _L: 
          if (sizeof(size_t ) > sizeof(long )) {
            flags += 16;
          } else
          if (sizeof(size_t ) > sizeof(int )) {
            flags += 8;
          }
          cp ++;
        } else
        if ((int const   )*cp == 116) {
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
            flags += 16;
          } else
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
            flags += 8;
          }
          cp ++;
        } else {
          break;
        }
      }
      tmp___18 = cp;
      cp ++;
      c = (char )*tmp___18;
      switch ((int )c) {
      case 100: 
      case 105: 
      if (flags >= 16) {
        type = (arg_type )9;
      } else
      if (flags & 4) {
        type = (arg_type )9;
      } else
      if (flags >= 8) {
        type = (arg_type )7;
      } else
      if (flags & 2) {
        type = (arg_type )1;
      } else
      if (flags & 1) {
        type = (arg_type )3;
      } else {
        type = (arg_type )5;
      }
      break;
      case 111: 
      case 117: 
      case 120: 
      case 88: 
      if (flags >= 16) {
        type = (arg_type )10;
      } else
      if (flags & 4) {
        type = (arg_type )10;
      } else
      if (flags >= 8) {
        type = (arg_type )8;
      } else
      if (flags & 2) {
        type = (arg_type )2;
      } else
      if (flags & 1) {
        type = (arg_type )4;
      } else {
        type = (arg_type )6;
      }
      break;
      case 102: 
      case 70: 
      case 101: 
      case 69: 
      case 103: 
      case 71: 
      case 97: 
      case 65: 
      if (flags >= 16) {
        type = (arg_type )12;
      } else
      if (flags & 4) {
        type = (arg_type )12;
      } else {
        type = (arg_type )11;
      }
      break;
      case 99: 
      if (flags >= 8) {
        type = (arg_type )14;
      } else {
        type = (arg_type )13;
      }
      break;
      case 67: 
      type = (arg_type )14;
      c = (char )'c';
      break;
      case 115: 
      if (flags >= 8) {
        type = (arg_type )16;
      } else {
        type = (arg_type )15;
      }
      break;
      case 83: 
      type = (arg_type )16;
      c = (char )'s';
      break;
      case 112: 
      type = (arg_type )17;
      break;
      case 110: 
      if (flags >= 16) {
        type = (arg_type )22;
      } else
      if (flags & 4) {
        type = (arg_type )22;
      } else
      if (flags >= 8) {
        type = (arg_type )21;
      } else
      if (flags & 2) {
        type = (arg_type )18;
      } else
      if (flags & 1) {
        type = (arg_type )19;
      } else {
        type = (arg_type )20;
      }
      break;
      case 37: 
      type = (arg_type )0;
      break;
      default: 
      goto error;
      }
      if ((unsigned int )type != 0U) {
        dp->arg_index = arg_index;
        if (dp->arg_index == 0xffffffffffffffffUL) {
          tmp___19 = arg_posn;
          arg_posn ++;
          dp->arg_index = tmp___19;
          if (dp->arg_index == 0xffffffffffffffffUL) {
            goto error;
          }
        }
        n___4 = dp->arg_index;
        if (n___4 >= a_allocated) {
          if (a_allocated <= 9223372036854775807UL) {
            a_allocated *= 2UL;
          } else {
            a_allocated = 0xffffffffffffffffUL;
          }
          if (a_allocated <= n___4) {
            tmp___20 = xsum(n___4, (size_t )1);
            a_allocated = (size_t )tmp___20;
          }
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
            memory_size___1 = 0xffffffffffffffffUL;
          }
          if (memory_size___1 == 0xffffffffffffffffUL) {
            goto out_of_memory;
          }
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            tmp___21 = realloc((void *)a->arg, memory_size___1);
            tmp___23 = tmp___21;
          } else {
            tmp___22 = malloc(memory_size___1);
            tmp___23 = tmp___22;
          }
          memory___1 = (argument *)tmp___23;
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
            goto out_of_memory;
          }
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            memcpy((void * __restrict  )memory___1, (void const   * __restrict  )a->arg,
                   a->count * sizeof(argument ));
          }
          a->arg = memory___1;
        }
        while (a->count <= n___4) {
          tmp___24 = a->count;
          (a->count) ++;
          (a->arg + tmp___24)->type = (arg_type )0;
        }
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
          (a->arg + n___4)->type = type;
        } else
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
          goto error;
        }
      }
      dp->conversion = c;
      dp->dir_end = cp;
      (d->count) ++;
      if (d->count >= d_allocated) {
        if (d_allocated <= 9223372036854775807UL) {
          d_allocated *= 2UL;
        } else {
          d_allocated = 0xffffffffffffffffUL;
        }
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
          memory_size___2 = 0xffffffffffffffffUL;
        }
        if (memory_size___2 == 0xffffffffffffffffUL) {
          goto out_of_memory;
        }
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
          tmp___25 = realloc((void *)d->dir, memory_size___2);
          tmp___27 = tmp___25;
        } else {
          tmp___26 = malloc(memory_size___2);
          tmp___27 = tmp___26;
        }
        memory___2 = (char_directive *)tmp___27;
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
          goto out_of_memory;
        }
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
          memcpy((void * __restrict  )memory___2, (void const   * __restrict  )d->dir,
                 d->count * sizeof(char_directive ));
        }
        d->dir = memory___2;
      }
    }
  }
  (d->dir + d->count)->dir_start = cp;
  d->max_width_length = max_width_length;
  d->max_precision_length = max_precision_length;
  return (0);
  error: 
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    free((void *)a->arg);
  }
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    free((void *)d->dir);
  }
  tmp___28 = __errno_location();
  *tmp___28 = 22;
  return (-1);
  out_of_memory: 
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    free((void *)a->arg);
  }
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    free((void *)d->dir);
  }
  tmp___29 = __errno_location();
  *tmp___29 = 12;
  return (-1);
}
}
extern void setutxent(void) ;
extern void endutxent(void) ;
extern struct utmpx *getutxent(void) ;
extern int utmpxname(char const   *__file ) ;
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) ;
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) 
{ char *p ;
  char *trimmed_name ;
  void *tmp ;
  size_t tmp___0 ;

  {
  tmp = xmalloc(sizeof(ut->ut_user) + 1UL);
  trimmed_name = (char *)tmp;
  strncpy((char * __restrict  )trimmed_name, (char const   * __restrict  )(ut->ut_user),
          sizeof(ut->ut_user));
  *(trimmed_name + sizeof(ut->ut_user)) = (char )'\000';
  tmp___0 = strlen((char const   *)trimmed_name);
  p = trimmed_name + tmp___0;
  while (1) {
    if ((unsigned long )trimmed_name < (unsigned long )p) {
      if (! ((int )*(p + -1) == 32)) {
        break;
      }
    } else {
      break;
    }
    goto __Cont;
    __Cont: 
    p --;
    *p = (char )'\000';
  }
  return (trimmed_name);
}
}
__inline static _Bool desirable_utmp_entry(STRUCT_UTMP const   *u , int options ) 
{ _Bool user_proc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  if (u->ut_user[0]) {
    if ((int const   )u->ut_type == 7) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  user_proc = (_Bool )tmp;
  if (options & 2) {
    if (! user_proc) {
      return ((_Bool)0);
    }
  }
  if (options & 1) {
    if (user_proc) {
      if (u->ut_pid <= 0) {
        return ((_Bool)0);
      } else {
        tmp___0 = kill((__pid_t )u->ut_pid, 0);
        if (tmp___0 < 0) {
          tmp___1 = __errno_location();
          if (*tmp___1 == 3) {
            return ((_Bool)0);
          }
        }
      }
    }
  }
  return ((_Bool)1);
}
}
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) 
{ size_t n_read ;
  size_t n_alloc ;
  STRUCT_UTMP *utmp ;
  STRUCT_UTMP *u ;
  void *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  n_read = (size_t )0;
  n_alloc = (size_t )0;
  utmp = (STRUCT_UTMP *)((void *)0);
  utmpxname(file);
  setutxent();
  while (1) {
    u = getutxent();
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
      break;
    }
    tmp___1 = desirable_utmp_entry((STRUCT_UTMP const   *)u, options);
    if (tmp___1) {
      if (n_read == n_alloc) {
        tmp = x2nrealloc((void *)utmp, & n_alloc, sizeof(*utmp));
        utmp = (STRUCT_UTMP *)tmp;
      }
      tmp___0 = n_read;
      n_read ++;
      *(utmp + tmp___0) = *u;
    }
  }
  endutxent();
  *n_entries = n_read;
  *utmp_buf = utmp;
  return (0);
}
}
int rpl_remove(char const   *name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
int rpl_remove(char const   *name )  __attribute__((__nonnull__(1))) ;
int rpl_remove(char const   *name ) 
{ int result ;
  int tmp ;
  int *tmp___0 ;

  {
  tmp = rmdir(name);
  result = tmp;
  if (result) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 20) {
      result = unlink(name);
    }
  }
  return (result);
}
}
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) 
{ struct stat statbuf ;
  int tmp ;

  {
  tmp = lstat((char const   * __restrict  )"/", (struct stat * __restrict  )(& statbuf));
  if (tmp) {
    return ((struct dev_ino *)((void *)0));
  }
  root_d_i->st_ino = statbuf.st_ino;
  root_d_i->st_dev = statbuf.st_dev;
  return (root_d_i);
}
}
__inline static int getfilecon(char const   *file  __attribute__((__unused__)) , char **con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
  tmp = __errno_location();
  *tmp = 95;
  return (-1);
}
}
__inline static int setfilecon(char const   *file  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ int *tmp ;

  {
  tmp = __errno_location();
  *tmp = 95;
  return (-1);
}
}
int getfileconat(int fd , char const   *file , char **con ) ;
int lgetfileconat(int fd , char const   *file , char **con ) ;
int setfileconat(int fd , char const   *file , char *con ) ;
int lsetfileconat(int fd , char const   *file , char *con ) ;
int getfileconat(int fd , char const   *file , char **con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
  if (fd == -100) {
    tmp = getfilecon(file, con);
    return (tmp);
  } else
  if ((int const   )*(file + 0) == 47) {
    tmp = getfilecon(file, con);
    return (tmp);
  }
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  if (proc_file) {
    tmp___1 = getfilecon((char const   *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      free((void *)proc_file);
    }
    if (-1 != proc_result) {
      return (proc_result);
    }
    if (! (proc_errno == 20)) {
      if (! (proc_errno == 2)) {
        if (! (proc_errno == 1)) {
          if (! (proc_errno == 13)) {
            if (! (proc_errno == 38)) {
              if (! (proc_errno == 95)) {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  tmp___5 = save_cwd(& saved_cwd);
  if (tmp___5 != 0) {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
  }
  if (0 <= fd) {
    if (fd == saved_cwd.desc) {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      return (-1);
    }
  }
  tmp___9 = fchdir(fd);
  if (tmp___9 != 0) {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    return (-1);
  }
  err = getfilecon(file, con);
  if (err == -1) {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
  } else {
    saved_errno = 0;
  }
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  if (tmp___12 != 0) {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
  }
  free_cwd(& saved_cwd);
  if (saved_errno) {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
  }
  return (err);
}
}
int lgetfileconat(int fd , char const   *file , char **con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
  if (fd == -100) {
    tmp = getfilecon(file, con);
    return (tmp);
  } else
  if ((int const   )*(file + 0) == 47) {
    tmp = getfilecon(file, con);
    return (tmp);
  }
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  if (proc_file) {
    tmp___1 = getfilecon((char const   *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      free((void *)proc_file);
    }
    if (-1 != proc_result) {
      return (proc_result);
    }
    if (! (proc_errno == 20)) {
      if (! (proc_errno == 2)) {
        if (! (proc_errno == 1)) {
          if (! (proc_errno == 13)) {
            if (! (proc_errno == 38)) {
              if (! (proc_errno == 95)) {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  tmp___5 = save_cwd(& saved_cwd);
  if (tmp___5 != 0) {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
  }
  if (0 <= fd) {
    if (fd == saved_cwd.desc) {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      return (-1);
    }
  }
  tmp___9 = fchdir(fd);
  if (tmp___9 != 0) {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    return (-1);
  }
  err = getfilecon(file, con);
  if (err == -1) {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
  } else {
    saved_errno = 0;
  }
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  if (tmp___12 != 0) {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
  }
  free_cwd(& saved_cwd);
  if (saved_errno) {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
  }
  return (err);
}
}
int setfileconat(int fd , char const   *file , char *con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
  if (fd == -100) {
    tmp = setfilecon(file, con);
    return (tmp);
  } else
  if ((int const   )*(file + 0) == 47) {
    tmp = setfilecon(file, con);
    return (tmp);
  }
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  if (proc_file) {
    tmp___1 = setfilecon((char const   *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      free((void *)proc_file);
    }
    if (-1 != proc_result) {
      return (proc_result);
    }
    if (! (proc_errno == 20)) {
      if (! (proc_errno == 2)) {
        if (! (proc_errno == 1)) {
          if (! (proc_errno == 13)) {
            if (! (proc_errno == 38)) {
              if (! (proc_errno == 95)) {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  tmp___5 = save_cwd(& saved_cwd);
  if (tmp___5 != 0) {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
  }
  if (0 <= fd) {
    if (fd == saved_cwd.desc) {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      return (-1);
    }
  }
  tmp___9 = fchdir(fd);
  if (tmp___9 != 0) {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    return (-1);
  }
  err = setfilecon(file, con);
  if (err == -1) {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
  } else {
    saved_errno = 0;
  }
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  if (tmp___12 != 0) {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
  }
  free_cwd(& saved_cwd);
  if (saved_errno) {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
  }
  return (err);
}
}
int lsetfileconat(int fd , char const   *file , char *con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
  if (fd == -100) {
    tmp = setfilecon(file, con);
    return (tmp);
  } else
  if ((int const   )*(file + 0) == 47) {
    tmp = setfilecon(file, con);
    return (tmp);
  }
  tmp___0 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___0;
  if (proc_file) {
    tmp___1 = setfilecon((char const   *)proc_file, con);
    proc_result = tmp___1;
    tmp___2 = __errno_location();
    proc_errno = *tmp___2;
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      free((void *)proc_file);
    }
    if (-1 != proc_result) {
      return (proc_result);
    }
    if (! (proc_errno == 20)) {
      if (! (proc_errno == 2)) {
        if (! (proc_errno == 1)) {
          if (! (proc_errno == 13)) {
            if (! (proc_errno == 38)) {
              if (! (proc_errno == 95)) {
                tmp___3 = __errno_location();
                *tmp___3 = proc_errno;
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  tmp___5 = save_cwd(& saved_cwd);
  if (tmp___5 != 0) {
    tmp___4 = __errno_location();
    openat_save_fail(*tmp___4);
  }
  if (0 <= fd) {
    if (fd == saved_cwd.desc) {
      free_cwd(& saved_cwd);
      tmp___6 = __errno_location();
      *tmp___6 = 9;
      return (-1);
    }
  }
  tmp___9 = fchdir(fd);
  if (tmp___9 != 0) {
    tmp___7 = __errno_location();
    saved_errno = *tmp___7;
    free_cwd(& saved_cwd);
    tmp___8 = __errno_location();
    *tmp___8 = saved_errno;
    return (-1);
  }
  err = setfilecon(file, con);
  if (err == -1) {
    tmp___10 = __errno_location();
    saved_errno = *tmp___10;
  } else {
    saved_errno = 0;
  }
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  if (tmp___12 != 0) {
    tmp___11 = __errno_location();
    openat_restore_fail(*tmp___11);
  }
  free_cwd(& saved_cwd);
  if (saved_errno) {
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
  }
  return (err);
}
}
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
int sig2str(int signum , char *signame ) ;
int str2sig(char const   *signame , int *signum ) ;
static struct numname numname_table[35]  = 
  {      {1, {(char const   )'H', (char const   )'U', (char const   )'P', (char const   )'\000',
          (char const   )(char)0, (char const   )(char)0, (char const   )(char)0,
          (char const   )(char)0}}, 
        {2, {(char const   )'I', (char const   )'N', (char const   )'T', (char const   )'\000',
          (char const   )(char)0, (char const   )(char)0, (char const   )(char)0,
          (char const   )(char)0}}, 
        {3, {(char const   )'Q', (char const   )'U', (char const   )'I', (char const   )'T',
          (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {4,
      {(char const   )'I', (char const   )'L', (char const   )'L', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {5,
      {(char const   )'T', (char const   )'R', (char const   )'A', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {6,
      {(char const   )'A', (char const   )'B', (char const   )'R', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {8,
      {(char const   )'F', (char const   )'P', (char const   )'E', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {9,
      {(char const   )'K', (char const   )'I', (char const   )'L', (char const   )'L',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {11,
      {(char const   )'S', (char const   )'E', (char const   )'G', (char const   )'V',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {7,
      {(char const   )'B', (char const   )'U', (char const   )'S', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {13,
      {(char const   )'P', (char const   )'I', (char const   )'P', (char const   )'E',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {14,
      {(char const   )'A', (char const   )'L', (char const   )'R', (char const   )'M',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {15,
      {(char const   )'T', (char const   )'E', (char const   )'R', (char const   )'M',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {10,
      {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'1',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {12,
      {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'2',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {17,
      {(char const   )'C', (char const   )'H', (char const   )'L', (char const   )'D',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {23,
      {(char const   )'U', (char const   )'R', (char const   )'G', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {19,
      {(char const   )'S', (char const   )'T', (char const   )'O', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {20,
      {(char const   )'T', (char const   )'S', (char const   )'T', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {18,
      {(char const   )'C', (char const   )'O', (char const   )'N', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {21,
      {(char const   )'T', (char const   )'T', (char const   )'I', (char const   )'N',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {22,
      {(char const   )'T', (char const   )'T', (char const   )'O', (char const   )'U',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {31,
      {(char const   )'S', (char const   )'Y', (char const   )'S', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {29,
      {(char const   )'P', (char const   )'O', (char const   )'L', (char const   )'L',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {26,
      {(char const   )'V', (char const   )'T', (char const   )'A', (char const   )'L',
       (char const   )'R', (char const   )'M', (char const   )'\000', (char const   )(char)0}}, 
        {27,
      {(char const   )'P', (char const   )'R', (char const   )'O', (char const   )'F',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {24,
      {(char const   )'X', (char const   )'C', (char const   )'P', (char const   )'U',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {25,
      {(char const   )'X', (char const   )'F', (char const   )'S', (char const   )'Z',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {6,
      {(char const   )'I', (char const   )'O', (char const   )'T', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {17,
      {(char const   )'C', (char const   )'L', (char const   )'D', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {30,
      {(char const   )'P', (char const   )'W', (char const   )'R', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {28,
      {(char const   )'W', (char const   )'I', (char const   )'N', (char const   )'C',
       (char const   )'H', (char const   )'\000', (char const   )(char)0, (char const   )(char)0}}, 
        {29,
      {(char const   )'I', (char const   )'O', (char const   )'\000', (char const   )(char)0,
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {16,
      {(char const   )'S', (char const   )'T', (char const   )'K', (char const   )'F',
       (char const   )'L', (char const   )'T', (char const   )'\000', (char const   )(char)0}}, 
        {0,
      {(char const   )'E', (char const   )'X', (char const   )'I', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}};
static int str2signum(char const   *signame ) 
{ char *endp ;
  long n ;
  long tmp ;
  unsigned int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *endp___0 ;
  int rtmin ;
  int tmp___7 ;
  int rtmax ;
  int tmp___8 ;
  long n___0 ;
  long tmp___9 ;
  long n___1 ;
  long tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___27 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
  if ((unsigned int )*signame - 48U <= 9U) {
    tmp = strtol((char const   * __restrict  )signame, (char ** __restrict  )(& endp),
                 10);
    n = tmp;
    if (! *endp) {
      if (n <= 64L) {
        return ((int )n);
      }
    }
  } else {
    i = 0U;
    while ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0])) {
      if (0) {
        __s1_len = __builtin_strlen(numname_table[i].name);
        __s2_len = __builtin_strlen(signame);
        if (! ((size_t )((void const   *)(numname_table[i].name + 1)) - (size_t )((void const   *)(numname_table[i].name)) == 1UL)) {
          goto _L___0;
        } else
        if (__s1_len >= 4UL) {
          _L___0: 
          if (! ((size_t )((void const   *)(signame + 1)) - (size_t )((void const   *)signame) == 1UL)) {
            tmp___6 = 1;
          } else
          if (__s2_len >= 4UL) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        if (tmp___6) {
          tmp___1 = __builtin_strcmp(numname_table[i].name, signame);
          tmp___5 = tmp___1;
        } else {
          tmp___4 = __builtin_strcmp(numname_table[i].name, signame);
          tmp___5 = tmp___4;
        }
      } else {
        tmp___4 = __builtin_strcmp(numname_table[i].name, signame);
        tmp___5 = tmp___4;
      }
      if (tmp___5 == 0) {
        return (numname_table[i].num);
      }
      i ++;
    }
    tmp___7 = __libc_current_sigrtmin();
    rtmin = tmp___7;
    tmp___8 = __libc_current_sigrtmax();
    rtmax = tmp___8;
    if (0 < rtmin) {
      if (0) {
        if (0) {
          __s1_len___1 = __builtin_strlen(signame);
          __s2_len___1 = __builtin_strlen("RTMIN");
          if (! ((size_t )((void const   *)(signame + 1)) - (size_t )((void const   *)signame) == 1UL)) {
            goto _L___4;
          } else
          if (__s1_len___1 >= 4UL) {
            _L___4: 
            if (! ((size_t )((void const   *)("RTMIN" + 1)) - (size_t )((void const   *)"RTMIN") == 1UL)) {
              tmp___32 = 1;
            } else
            if (__s2_len___1 >= 4UL) {
              tmp___32 = 1;
            } else {
              tmp___32 = 0;
            }
          } else {
            tmp___32 = 0;
          }
          if (tmp___32) {
            tmp___27 = __builtin_strcmp(signame, "RTMIN");
            tmp___31 = tmp___27;
          } else {
            tmp___30 = __builtin_strcmp(signame, "RTMIN");
            tmp___31 = tmp___30;
          }
        } else {
          tmp___30 = __builtin_strcmp(signame, "RTMIN");
          tmp___31 = tmp___30;
        }
        tmp___34 = tmp___31;
      } else {
        tmp___33 = strncmp(signame, "RTMIN", (size_t )5);
        tmp___34 = tmp___33;
      }
      if (tmp___34 == 0) {
        tmp___9 = strtol((char const   * __restrict  )(signame + 5), (char ** __restrict  )(& endp___0),
                         10);
        n___0 = tmp___9;
        if (! *endp___0) {
          if (0L <= n___0) {
            if (n___0 <= (long )(rtmax - rtmin)) {
              return ((int )((long )rtmin + n___0));
            }
          }
        }
      } else {
        goto _L___5;
      }
    } else
    _L___5: 
    if (0 < rtmax) {
      if (0) {
        if (0) {
          __s1_len___0 = __builtin_strlen(signame);
          __s2_len___0 = __builtin_strlen("RTMAX");
          if (! ((size_t )((void const   *)(signame + 1)) - (size_t )((void const   *)signame) == 1UL)) {
            goto _L___2;
          } else
          if (__s1_len___0 >= 4UL) {
            _L___2: 
            if (! ((size_t )((void const   *)("RTMAX" + 1)) - (size_t )((void const   *)"RTMAX") == 1UL)) {
              tmp___19 = 1;
            } else
            if (__s2_len___0 >= 4UL) {
              tmp___19 = 1;
            } else {
              tmp___19 = 0;
            }
          } else {
            tmp___19 = 0;
          }
          if (tmp___19) {
            tmp___14 = __builtin_strcmp(signame, "RTMAX");
            tmp___18 = tmp___14;
          } else {
            tmp___17 = __builtin_strcmp(signame, "RTMAX");
            tmp___18 = tmp___17;
          }
        } else {
          tmp___17 = __builtin_strcmp(signame, "RTMAX");
          tmp___18 = tmp___17;
        }
        tmp___21 = tmp___18;
      } else {
        tmp___20 = strncmp(signame, "RTMAX", (size_t )5);
        tmp___21 = tmp___20;
      }
      if (tmp___21 == 0) {
        tmp___10 = strtol((char const   * __restrict  )(signame + 5), (char ** __restrict  )(& endp___0),
                          10);
        n___1 = tmp___10;
        if (! *endp___0) {
          if ((long )(rtmin - rtmax) <= n___1) {
            if (n___1 <= 0L) {
              return ((int )((long )rtmax + n___1));
            }
          }
        }
      }
    }
  }
  return (-1);
}
}
int str2sig(char const   *signame , int *signum ) 
{ int tmp ;

  {
  *signum = str2signum(signame);
  if (*signum < 0) {
    tmp = -1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int sig2str(int signum , char *signame ) 
{ unsigned int i ;
  int rtmin ;
  int tmp ;
  int rtmax ;
  int tmp___0 ;
  int delta ;
  char const   *tmp___1 ;
  int delta___0 ;
  char const   *tmp___2 ;

  {
  i = 0U;
  while ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0])) {
    if (numname_table[i].num == signum) {
      strcpy((char * __restrict  )signame, (char const   * __restrict  )(numname_table[i].name));
      return (0);
    }
    i ++;
  }
  tmp = __libc_current_sigrtmin();
  rtmin = tmp;
  tmp___0 = __libc_current_sigrtmax();
  rtmax = tmp___0;
  if (rtmin <= signum) {
    if (! (signum <= rtmax)) {
      return (-1);
    }
  } else {
    return (-1);
  }
  if (signum <= rtmin + (rtmax - rtmin) / 2) {
    delta = signum - rtmin;
    if (delta) {
      tmp___1 = "RTMIN+%d";
    } else {
      tmp___1 = "RTMIN";
    }
    sprintf((char * __restrict  )signame, (char const   * __restrict  )tmp___1, delta);
  } else {
    delta___0 = rtmax - signum;
    if (delta___0) {
      tmp___2 = "RTMAX-%d";
    } else {
      tmp___2 = "RTMAX";
    }
    sprintf((char * __restrict  )signame, (char const   * __restrict  )tmp___2, delta___0);
  }
  return (0);
}
}
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
char *rpl_strerror(int n ) ;
static char buf___0[256]  ;
static char const   fmt[17]  = 
  {      (char const   )'U',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )'\000'};
char *rpl_strerror(int n ) 
{ size_t len ;
  char const   *msg ;
  char *tmp ;
  int *tmp___0 ;
  void __attribute__((__artificial__))  *tmp___1 ;

  {
  msg = (char const   *)((void *)0);
  if (msg) {
    return ((char *)msg);
  }
  tmp = strerror(n);
  msg = (char const   *)tmp;
  if (! msg) {
    sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )(fmt), n);
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (buf___0);
  } else
  if (! *msg) {
    sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )(fmt), n);
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (buf___0);
  }
  len = strlen(msg);
  if (sizeof(buf___0) <= len) {
    abort();
  }
  tmp___1 = memcpy((void * __restrict  )(buf___0), (void const   * __restrict  )msg,
                   len + 1UL);
  return ((char *)tmp___1);
}
}
static int local_utimensat(int fd , char const   *file , struct timespec  const  *ts ,
                           int flag ) ;
static int utimensat_works_really___0  ;
int rpl_utimensat(int fd , char const   *file , struct timespec  const  *times , int flag )  __attribute__((__nonnull__(2))) ;
int rpl_utimensat(int fd , char const   *file , struct timespec  const  *times , int flag ) 
{ struct timespec ts[2] ;
  int result ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  if (0 <= utimensat_works_really___0) {
    if (times) {
      if ((times + 0)->tv_nsec == (long const   )((1L << 30) - 2L)) {
        goto _L;
      } else
      if ((times + 1)->tv_nsec == (long const   )((1L << 30) - 2L)) {
        _L: 
        tmp = fstatat(fd, (char const   * __restrict  )file, (struct stat * __restrict  )(& st),
                      flag);
        if (tmp) {
          return (-1);
        }
        if ((times + 0)->tv_nsec == (long const   )((1L << 30) - 2L)) {
          if ((times + 1)->tv_nsec == (long const   )((1L << 30) - 2L)) {
            return (0);
          }
        }
        if ((times + 0)->tv_nsec == (long const   )((1L << 30) - 2L)) {
          ts[0] = get_stat_atime((struct stat  const  *)(& st));
        } else {
          ts[0] = (struct timespec )*(times + 0);
        }
        if ((times + 1)->tv_nsec == (long const   )((1L << 30) - 2L)) {
          ts[1] = get_stat_mtime((struct stat  const  *)(& st));
        } else {
          ts[1] = (struct timespec )*(times + 1);
        }
        times = (struct timespec  const  *)(ts);
      }
    }
    result = utimensat(fd, file, times, flag);
    if (result == -1) {
      tmp___0 = __errno_location();
      if (*tmp___0 == 22) {
        if (flag & -257) {
          return (result);
        }
      }
    }
    if (result == 0) {
      utimensat_works_really___0 = 1;
      return (result);
    } else {
      tmp___1 = __errno_location();
      if (*tmp___1 != 38) {
        tmp___2 = __errno_location();
        if (*tmp___2 != 22) {
          utimensat_works_really___0 = 1;
          return (result);
        }
      }
    }
  }
  if (0 <= utimensat_works_really___0) {
    tmp___3 = __errno_location();
    if (*tmp___3 == 38) {
      utimensat_works_really___0 = -1;
    }
  }
  tmp___4 = local_utimensat(fd, file, times, flag);
  return (tmp___4);
}
}
static int local_utimensat(int fd , char const   *file , struct timespec  const  *ts ,
                           int flag ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___3 ;
  int proc_result ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int proc_errno ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;

  {
  if (flag & -257) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (fd == -100) {
    goto _L___0;
  } else
  if ((int const   )*(file + 0) == 47) {
    goto _L___0;
  } else
  if (0) {
    _L___0: 
    if (flag == 256) {
      tmp___0 = lutimens(file, ts);
      tmp___2 = tmp___0;
    } else {
      tmp___1 = utimens(file, ts);
      tmp___2 = tmp___1;
    }
    return (tmp___2);
  }
  tmp___3 = openat_proc_name(proc_buf, fd, file);
  proc_file = tmp___3;
  if (proc_file) {
    if (flag == 256) {
      tmp___4 = lutimens((char const   *)proc_file, ts);
      tmp___6 = tmp___4;
    } else {
      tmp___5 = utimens((char const   *)proc_file, ts);
      tmp___6 = tmp___5;
    }
    proc_result = tmp___6;
    tmp___7 = __errno_location();
    proc_errno = *tmp___7;
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      free((void *)proc_file);
    }
    if (-1 != proc_result) {
      return (proc_result);
    }
    if (! (proc_errno == 20)) {
      if (! (proc_errno == 2)) {
        if (! (proc_errno == 1)) {
          if (! (proc_errno == 13)) {
            if (! (proc_errno == 38)) {
              if (! (proc_errno == 95)) {
                tmp___8 = __errno_location();
                *tmp___8 = proc_errno;
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  tmp___10 = save_cwd(& saved_cwd);
  if (tmp___10 != 0) {
    tmp___9 = __errno_location();
    openat_save_fail(*tmp___9);
  }
  if (0 <= fd) {
    if (fd == saved_cwd.desc) {
      free_cwd(& saved_cwd);
      tmp___11 = __errno_location();
      *tmp___11 = 9;
      return (-1);
    }
  }
  tmp___14 = fchdir(fd);
  if (tmp___14 != 0) {
    tmp___12 = __errno_location();
    saved_errno = *tmp___12;
    free_cwd(& saved_cwd);
    tmp___13 = __errno_location();
    *tmp___13 = saved_errno;
    return (-1);
  }
  if (flag == 256) {
    tmp___15 = lutimens(file, ts);
    err = tmp___15;
  } else {
    tmp___16 = utimens(file, ts);
    err = tmp___16;
  }
  if (err == -1) {
    tmp___17 = __errno_location();
    saved_errno = *tmp___17;
  } else {
    saved_errno = 0;
  }
  tmp___19 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  if (tmp___19 != 0) {
    tmp___18 = __errno_location();
    openat_restore_fail(*tmp___18);
  }
  free_cwd(& saved_cwd);
  if (saved_errno) {
    tmp___20 = __errno_location();
    *tmp___20 = saved_errno;
  }
  return (err);
}
}
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  tmp = xsum(size1, size2);
  tmp___0 = xsum((size_t )tmp, size3);
  tmp___1 = xsum((size_t )tmp___0, size4);
  return (tmp___1);
}
}
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ size_t tmp ;

  {
  if (size1 >= size2) {
    tmp = size1;
  } else {
    tmp = size2;
  }
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
__inline extern int __signbitl(long double __x ) 
{ union __anonunion___u_36 __u ;

  {
  __u.__l = __x;
  return ((__u.__i[2] & 32768) != 0);
}
}
static char decimal_point_char(void) 
{ char const   *point ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp = nl_langinfo(65536);
  point = (char const   *)tmp;
  if ((int const   )*(point + 0) != 0) {
    tmp___0 = (int )((int const   )*(point + 0));
  } else {
    tmp___0 = (int )((int const   )'.');
  }
  return ((char )tmp___0);
}
}
static int is_infinite_or_zerol(long double x ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = rpl_isnanl(x);
  if (tmp) {
    tmp___0 = 1;
  } else
  if (x + x == x) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
extern int __builtin_signbitl() ;
extern int __builtin_signbit() ;
extern int __builtin_signbitf() ;
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) 
{ char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___1 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int flags ;
  int has_width ;
  size_t width ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp___16 ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const   *digitp ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  size_t __attribute__((__pure__))  tmp___19 ;
  int arg___0 ;
  char const   *digitp___0 ;
  char const   *tmp___20 ;
  size_t tmp___21 ;
  size_t __attribute__((__pure__))  tmp___22 ;
  size_t __attribute__((__pure__))  tmp___23 ;
  size_t __attribute__((__pure__))  tmp___24 ;
  size_t tmp_memsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  long double arg___1 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int sign ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t ndigits ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  fpucw_t _ncw___0 ;
  int tmp___69 ;
  size_t pad ;
  char *end ;
  char *tmp___70 ;
  char *q ;
  char *tmp___71 ;
  char *q___0 ;
  char *tmp___72 ;
  size_t count ;
  size_t n___0 ;
  size_t __attribute__((__pure__))  tmp___73 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  arg_type type ;
  int flags___0 ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  size_t n___1 ;
  char const   *mp ;
  char *tmp___85 ;
  char const   *tmp___86 ;
  size_t n___2 ;
  char const   *mp___0 ;
  char *tmp___87 ;
  char const   *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___94 ;
  size_t __attribute__((__pure__))  tmp___95 ;
  size_t __attribute__((__pure__))  tmp___96 ;
  void *tmp___97 ;
  void *tmp___98 ;
  size_t __attribute__((__pure__))  tmp___99 ;
  int *tmp___100 ;
  int count___0 ;
  int retcount ;
  size_t maxlen ;
  int *tmp___101 ;
  int arg___2 ;
  int __attribute__((__artificial__))  tmp___102 ;
  int __attribute__((__artificial__))  tmp___103 ;
  int __attribute__((__artificial__))  tmp___104 ;
  unsigned int arg___3 ;
  int __attribute__((__artificial__))  tmp___105 ;
  int __attribute__((__artificial__))  tmp___106 ;
  int __attribute__((__artificial__))  tmp___107 ;
  int arg___4 ;
  int __attribute__((__artificial__))  tmp___108 ;
  int __attribute__((__artificial__))  tmp___109 ;
  int __attribute__((__artificial__))  tmp___110 ;
  unsigned int arg___5 ;
  int __attribute__((__artificial__))  tmp___111 ;
  int __attribute__((__artificial__))  tmp___112 ;
  int __attribute__((__artificial__))  tmp___113 ;
  int arg___6 ;
  int __attribute__((__artificial__))  tmp___114 ;
  int __attribute__((__artificial__))  tmp___115 ;
  int __attribute__((__artificial__))  tmp___116 ;
  unsigned int arg___7 ;
  int __attribute__((__artificial__))  tmp___117 ;
  int __attribute__((__artificial__))  tmp___118 ;
  int __attribute__((__artificial__))  tmp___119 ;
  long arg___8 ;
  int __attribute__((__artificial__))  tmp___120 ;
  int __attribute__((__artificial__))  tmp___121 ;
  int __attribute__((__artificial__))  tmp___122 ;
  unsigned long arg___9 ;
  int __attribute__((__artificial__))  tmp___123 ;
  int __attribute__((__artificial__))  tmp___124 ;
  int __attribute__((__artificial__))  tmp___125 ;
  long long arg___10 ;
  int __attribute__((__artificial__))  tmp___126 ;
  int __attribute__((__artificial__))  tmp___127 ;
  int __attribute__((__artificial__))  tmp___128 ;
  unsigned long long arg___11 ;
  int __attribute__((__artificial__))  tmp___129 ;
  int __attribute__((__artificial__))  tmp___130 ;
  int __attribute__((__artificial__))  tmp___131 ;
  double arg___12 ;
  int __attribute__((__artificial__))  tmp___132 ;
  int __attribute__((__artificial__))  tmp___133 ;
  int __attribute__((__artificial__))  tmp___134 ;
  long double arg___13 ;
  int __attribute__((__artificial__))  tmp___135 ;
  int __attribute__((__artificial__))  tmp___136 ;
  int __attribute__((__artificial__))  tmp___137 ;
  int arg___14 ;
  int __attribute__((__artificial__))  tmp___138 ;
  int __attribute__((__artificial__))  tmp___139 ;
  int __attribute__((__artificial__))  tmp___140 ;
  wint_t arg___15 ;
  int __attribute__((__artificial__))  tmp___141 ;
  int __attribute__((__artificial__))  tmp___142 ;
  int __attribute__((__artificial__))  tmp___143 ;
  char const   *arg___16 ;
  int __attribute__((__artificial__))  tmp___144 ;
  int __attribute__((__artificial__))  tmp___145 ;
  int __attribute__((__artificial__))  tmp___146 ;
  wchar_t const   *arg___17 ;
  int __attribute__((__artificial__))  tmp___147 ;
  int __attribute__((__artificial__))  tmp___148 ;
  int __attribute__((__artificial__))  tmp___149 ;
  void *arg___18 ;
  int __attribute__((__artificial__))  tmp___150 ;
  int __attribute__((__artificial__))  tmp___151 ;
  int __attribute__((__artificial__))  tmp___152 ;
  int saved_errno ;
  int *tmp___153 ;
  int *tmp___154 ;
  int tmp___155 ;
  size_t n___3 ;
  size_t tmp___156 ;
  size_t __attribute__((__pure__))  tmp___157 ;
  size_t __attribute__((__pure__))  tmp___158 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___159 ;
  void *tmp___160 ;
  void *tmp___161 ;
  int *tmp___162 ;
  int tmp___163 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___164 ;
  size_t __attribute__((__pure__))  tmp___165 ;
  size_t __attribute__((__pure__))  tmp___166 ;
  void *tmp___167 ;
  void *tmp___168 ;
  size_t __attribute__((__pure__))  tmp___169 ;
  char *memory___5 ;
  void *tmp___170 ;
  int *tmp___171 ;
  int *tmp___172 ;

  {
  tmp = printf_parse(format, & d, & a);
  if (tmp < 0) {
    return ((char *)((void *)0));
  }
  tmp___1 = printf_fetchargs(args, & a);
  if (tmp___1 < 0) {
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
      free((void *)d.dir);
    }
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
      free((void *)a.arg);
    }
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((char *)((void *)0));
  }
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
  buf_neededlength = (size_t )tmp___2;
  if (buf_neededlength < 4000UL / sizeof(char )) {
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
    buf___1 = (char *)tmp___3;
    buf_malloced = (char *)((void *)0);
  } else {
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
      tmp___4 = 0xffffffffffffffffUL;
    }
    buf_memsize = tmp___4;
    if (buf_memsize == 0xffffffffffffffffUL) {
      goto out_of_memory_1;
    }
    tmp___5 = malloc(buf_memsize);
    buf___1 = (char *)tmp___5;
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
      goto out_of_memory_1;
    }
    buf_malloced = buf___1;
  }
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
    result = resultbuf;
    allocated = *lengthp;
  } else {
    result = (char *)((void *)0);
    allocated = (size_t )0;
  }
  length = (size_t )0;
  cp = format;
  i = (size_t )0;
  dp = d.dir + 0;
  while (1) {
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      n = (size_t )(dp->dir_start - cp);
      tmp___6 = xsum(length, n);
      augmented_length = (size_t )tmp___6;
      if (augmented_length > allocated) {
        if (allocated > 0UL) {
          if (allocated <= 9223372036854775807UL) {
            tmp___7 = allocated * 2UL;
          } else {
            tmp___7 = 0xffffffffffffffffUL;
          }
          allocated = tmp___7;
        } else {
          allocated = (size_t )12;
        }
        if (augmented_length > allocated) {
          allocated = augmented_length;
        }
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
          memory_size = allocated * sizeof(char );
        } else {
          memory_size = 0xffffffffffffffffUL;
        }
        if (memory_size == 0xffffffffffffffffUL) {
          goto out_of_memory;
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          tmp___8 = malloc(memory_size);
          memory = (char *)tmp___8;
        } else
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          tmp___8 = malloc(memory_size);
          memory = (char *)tmp___8;
        } else {
          tmp___9 = realloc((void *)result, memory_size);
          memory = (char *)tmp___9;
        }
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
          goto out_of_memory;
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          if (length > 0UL) {
            memcpy((void * __restrict  )memory, (void const   * __restrict  )result,
                   length);
          }
        }
        result = memory;
      }
      if (sizeof(char ) == sizeof(char )) {
        memcpy((void * __restrict  )(result + length), (void const   * __restrict  )cp,
               n);
        length = augmented_length;
      } else {
        while (1) {
          tmp___10 = length;
          length ++;
          tmp___11 = cp;
          cp ++;
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
          n --;
          if (! (n > 0UL)) {
            break;
          }
        }
      }
    }
    if (i == d.count) {
      break;
    }
    if ((int )dp->conversion == 37) {
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        abort();
      }
      tmp___12 = xsum(length, (size_t )1);
      augmented_length___0 = (size_t )tmp___12;
      if (augmented_length___0 > allocated) {
        if (allocated > 0UL) {
          if (allocated <= 9223372036854775807UL) {
            tmp___13 = allocated * 2UL;
          } else {
            tmp___13 = 0xffffffffffffffffUL;
          }
          allocated = tmp___13;
        } else {
          allocated = (size_t )12;
        }
        if (augmented_length___0 > allocated) {
          allocated = augmented_length___0;
        }
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
          memory_size___0 = allocated * sizeof(char );
        } else {
          memory_size___0 = 0xffffffffffffffffUL;
        }
        if (memory_size___0 == 0xffffffffffffffffUL) {
          goto out_of_memory;
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          tmp___14 = malloc(memory_size___0);
          memory___0 = (char *)tmp___14;
        } else
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          tmp___14 = malloc(memory_size___0);
          memory___0 = (char *)tmp___14;
        } else {
          tmp___15 = realloc((void *)result, memory_size___0);
          memory___0 = (char *)tmp___15;
        }
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
          goto out_of_memory;
        }
        if ((unsigned long )result == (unsigned long )resultbuf) {
          if (length > 0UL) {
            memcpy((void * __restrict  )memory___0, (void const   * __restrict  )result,
                   length);
          }
        }
        result = memory___0;
      }
      *(result + length) = (char )'%';
      length = augmented_length___0;
    } else {
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        abort();
      }
      if ((int )dp->conversion == 110) {
        switch ((int )(a.arg + dp->arg_index)->type) {
        case 18: 
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
        break;
        case 19: 
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
        break;
        case 20: 
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
        break;
        case 21: 
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
        break;
        case 22: 
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
        break;
        default: 
        abort();
        }
      } else
      if ((int )dp->conversion == 102) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 70) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 101) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 69) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 103) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 71) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 97) {
        goto _L___11;
      } else
      if ((int )dp->conversion == 65) {
        _L___11: 
        if ((unsigned int )(a.arg + dp->arg_index)->type == 12U) {
          tmp___163 = is_infinite_or_zerol((a.arg + dp->arg_index)->a.a_longdouble);
          if (tmp___163) {
            flags = dp->flags;
            has_width = 0;
            width = (size_t )0;
            if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
              if (dp->width_arg_index != 0xffffffffffffffffUL) {
                if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
                  abort();
                }
                arg = (a.arg + dp->width_arg_index)->a.a_int;
                if (arg < 0) {
                  flags |= 2;
                  width = (size_t )((unsigned int )(- arg));
                } else {
                  width = (size_t )arg;
                }
              } else {
                digitp = dp->width_start;
                while (1) {
                  tmp___17 = digitp;
                  digitp ++;
                  if (width <= 1844674407370955161UL) {
                    tmp___18 = width * 10UL;
                  } else {
                    tmp___18 = 0xffffffffffffffffUL;
                  }
                  tmp___19 = xsum(tmp___18, (size_t )((int const   )*tmp___17 - 48));
                  width = (size_t )tmp___19;
                  if (! ((unsigned long )digitp != (unsigned long )dp->width_end)) {
                    break;
                  }
                }
              }
              has_width = 1;
            }
            has_precision = 0;
            precision = (size_t )0;
            if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
              if (dp->precision_arg_index != 0xffffffffffffffffUL) {
                if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
                  abort();
                }
                arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
                if (arg___0 >= 0) {
                  precision = (size_t )arg___0;
                  has_precision = 1;
                }
              } else {
                digitp___0 = dp->precision_start + 1;
                precision = (size_t )0;
                while ((unsigned long )digitp___0 != (unsigned long )dp->precision_end) {
                  tmp___20 = digitp___0;
                  digitp___0 ++;
                  if (precision <= 1844674407370955161UL) {
                    tmp___21 = precision * 10UL;
                  } else {
                    tmp___21 = 0xffffffffffffffffUL;
                  }
                  tmp___22 = xsum(tmp___21, (size_t )((int const   )*tmp___20 - 48));
                  precision = (size_t )tmp___22;
                }
                has_precision = 1;
              }
            }
            if (! has_precision) {
              if (! ((int )dp->conversion == 97)) {
                if (! ((int )dp->conversion == 65)) {
                  precision = (size_t )6;
                }
              }
            }
            tmp_length = (size_t )0;
            if (tmp_length < precision) {
              tmp_length = precision;
            }
            tmp___23 = xsum(tmp_length, (size_t )12);
            tmp_length = (size_t )tmp___23;
            if (tmp_length < width) {
              tmp_length = width;
            }
            tmp___24 = xsum(tmp_length, (size_t )1);
            tmp_length = (size_t )tmp___24;
            if (tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
              tmp___16 = tmpbuf;
            } else {
              if (tmp_length <= 0xffffffffffffffffUL / sizeof(char )) {
                tmp___25 = tmp_length * sizeof(char );
              } else {
                tmp___25 = 0xffffffffffffffffUL;
              }
              tmp_memsize = tmp___25;
              if (tmp_memsize == 0xffffffffffffffffUL) {
                goto out_of_memory;
              }
              tmp___26 = malloc(tmp_memsize);
              tmp___16 = (char *)tmp___26;
              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
                goto out_of_memory;
              }
            }
            pad_ptr = (char *)((void *)0);
            p = tmp___16;
            arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
            tmp___69 = rpl_isnanl(arg___1);
            if (tmp___69) {
              if ((int )dp->conversion >= 65) {
                if ((int )dp->conversion <= 90) {
                  tmp___27 = p;
                  p ++;
                  *tmp___27 = (char )'N';
                  tmp___28 = p;
                  p ++;
                  *tmp___28 = (char )'A';
                  tmp___29 = p;
                  p ++;
                  *tmp___29 = (char )'N';
                } else {
                  goto _L;
                }
              } else {
                _L: 
                tmp___30 = p;
                p ++;
                *tmp___30 = (char )'n';
                tmp___31 = p;
                p ++;
                *tmp___31 = (char )'a';
                tmp___32 = p;
                p ++;
                *tmp___32 = (char )'n';
              }
            } else {
              sign = 0;
              __asm__  volatile   ("fnstcw %0": "=m" (_cw));
              oldcw = _cw;
              _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
              __asm__  volatile   ("fldcw %0": : "m" (_ncw));
              if (sizeof(arg___1) == sizeof(long double )) {
                tmp___33 = __builtin_signbitl(arg___1);
                tmp___37 = tmp___33;
              } else {
                if (sizeof(arg___1) == sizeof(double )) {
                  tmp___34 = __builtin_signbit(arg___1);
                  tmp___36 = tmp___34;
                } else {
                  tmp___35 = __builtin_signbitf(arg___1);
                  tmp___36 = tmp___35;
                }
                tmp___37 = tmp___36;
              }
              if (tmp___37) {
                sign = -1;
                arg___1 = - arg___1;
              }
              if (sign < 0) {
                tmp___38 = p;
                p ++;
                *tmp___38 = (char )'-';
              } else
              if (flags & 4) {
                tmp___39 = p;
                p ++;
                *tmp___39 = (char )'+';
              } else
              if (flags & 8) {
                tmp___40 = p;
                p ++;
                *tmp___40 = (char )' ';
              }
              if (arg___1 > 0.0L) {
                if (arg___1 + arg___1 == arg___1) {
                  if ((int )dp->conversion >= 65) {
                    if ((int )dp->conversion <= 90) {
                      tmp___41 = p;
                      p ++;
                      *tmp___41 = (char )'I';
                      tmp___42 = p;
                      p ++;
                      *tmp___42 = (char )'N';
                      tmp___43 = p;
                      p ++;
                      *tmp___43 = (char )'F';
                    } else {
                      goto _L___0;
                    }
                  } else {
                    _L___0: 
                    tmp___44 = p;
                    p ++;
                    *tmp___44 = (char )'i';
                    tmp___45 = p;
                    p ++;
                    *tmp___45 = (char )'n';
                    tmp___46 = p;
                    p ++;
                    *tmp___46 = (char )'f';
                  }
                } else {
                  goto _L___8;
                }
              } else {
                _L___8: 
                if (! (arg___1 == 0.0L)) {
                  abort();
                }
                pad_ptr = p;
                if ((int )dp->conversion == 102) {
                  goto _L___7;
                } else
                if ((int )dp->conversion == 70) {
                  _L___7: 
                  tmp___47 = p;
                  p ++;
                  *tmp___47 = (char )'0';
                  if (flags & 16) {
                    goto _L___1;
                  } else
                  if (precision > 0UL) {
                    _L___1: 
                    tmp___48 = p;
                    p ++;
                    *tmp___48 = decimal_point_char();
                    while (precision > 0UL) {
                      tmp___49 = p;
                      p ++;
                      *tmp___49 = (char )'0';
                      precision --;
                    }
                  }
                } else
                if ((int )dp->conversion == 101) {
                  goto _L___6;
                } else
                if ((int )dp->conversion == 69) {
                  _L___6: 
                  tmp___50 = p;
                  p ++;
                  *tmp___50 = (char )'0';
                  if (flags & 16) {
                    goto _L___2;
                  } else
                  if (precision > 0UL) {
                    _L___2: 
                    tmp___51 = p;
                    p ++;
                    *tmp___51 = decimal_point_char();
                    while (precision > 0UL) {
                      tmp___52 = p;
                      p ++;
                      *tmp___52 = (char )'0';
                      precision --;
                    }
                  }
                  tmp___53 = p;
                  p ++;
                  *tmp___53 = dp->conversion;
                  tmp___54 = p;
                  p ++;
                  *tmp___54 = (char )'+';
                  tmp___55 = p;
                  p ++;
                  *tmp___55 = (char )'0';
                  tmp___56 = p;
                  p ++;
                  *tmp___56 = (char )'0';
                } else
                if ((int )dp->conversion == 103) {
                  goto _L___5;
                } else
                if ((int )dp->conversion == 71) {
                  _L___5: 
                  tmp___57 = p;
                  p ++;
                  *tmp___57 = (char )'0';
                  if (flags & 16) {
                    if (precision > 0UL) {
                      tmp___58 = precision - 1UL;
                    } else {
                      tmp___58 = (size_t )0;
                    }
                    ndigits = tmp___58;
                    tmp___59 = p;
                    p ++;
                    *tmp___59 = decimal_point_char();
                    while (ndigits > 0UL) {
                      tmp___60 = p;
                      p ++;
                      *tmp___60 = (char )'0';
                      ndigits --;
                    }
                  }
                } else
                if ((int )dp->conversion == 97) {
                  goto _L___4;
                } else
                if ((int )dp->conversion == 65) {
                  _L___4: 
                  tmp___61 = p;
                  p ++;
                  *tmp___61 = (char )'0';
                  tmp___62 = p;
                  p ++;
                  *tmp___62 = (char )(((int )dp->conversion - 65) + 88);
                  pad_ptr = p;
                  tmp___63 = p;
                  p ++;
                  *tmp___63 = (char )'0';
                  if (flags & 16) {
                    goto _L___3;
                  } else
                  if (precision > 0UL) {
                    _L___3: 
                    tmp___64 = p;
                    p ++;
                    *tmp___64 = decimal_point_char();
                    while (precision > 0UL) {
                      tmp___65 = p;
                      p ++;
                      *tmp___65 = (char )'0';
                      precision --;
                    }
                  }
                  tmp___66 = p;
                  p ++;
                  *tmp___66 = (char )(((int )dp->conversion - 65) + 80);
                  tmp___67 = p;
                  p ++;
                  *tmp___67 = (char )'+';
                  tmp___68 = p;
                  p ++;
                  *tmp___68 = (char )'0';
                } else {
                  abort();
                }
              }
              _ncw___0 = oldcw;
              __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
            }
            if (has_width) {
              if ((size_t )(p - tmp___16) < width) {
                pad = width - (size_t )(p - tmp___16);
                end = p + pad;
                if (flags & 2) {
                  while (pad > 0UL) {
                    tmp___70 = p;
                    p ++;
                    *tmp___70 = (char )' ';
                    pad --;
                  }
                } else
                if (flags & 32) {
                  if ((unsigned long )pad_ptr != (unsigned long )((void *)0)) {
                    q = end;
                    while ((unsigned long )p > (unsigned long )pad_ptr) {
                      q --;
                      p --;
                      *q = *p;
                    }
                    while (pad > 0UL) {
                      tmp___71 = p;
                      p ++;
                      *tmp___71 = (char )'0';
                      pad --;
                    }
                  } else {
                    goto _L___9;
                  }
                } else {
                  _L___9: 
                  q___0 = end;
                  while ((unsigned long )p > (unsigned long )tmp___16) {
                    q___0 --;
                    p --;
                    *q___0 = *p;
                  }
                  while (pad > 0UL) {
                    tmp___72 = p;
                    p ++;
                    *tmp___72 = (char )' ';
                    pad --;
                  }
                }
                p = end;
              }
            }
            count = (size_t )(p - tmp___16);
            if (count >= tmp_length) {
              abort();
            }
            if (count >= allocated - length) {
              tmp___73 = xsum(length, count);
              n___0 = (size_t )tmp___73;
              if (n___0 > allocated) {
                if (allocated > 0UL) {
                  if (allocated <= 9223372036854775807UL) {
                    tmp___74 = allocated * 2UL;
                  } else {
                    tmp___74 = 0xffffffffffffffffUL;
                  }
                  allocated = tmp___74;
                } else {
                  allocated = (size_t )12;
                }
                if (n___0 > allocated) {
                  allocated = n___0;
                }
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
                  memory_size___1 = allocated * sizeof(char );
                } else {
                  memory_size___1 = 0xffffffffffffffffUL;
                }
                if (memory_size___1 == 0xffffffffffffffffUL) {
                  goto out_of_memory;
                }
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  tmp___75 = malloc(memory_size___1);
                  memory___1 = (char *)tmp___75;
                } else
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  tmp___75 = malloc(memory_size___1);
                  memory___1 = (char *)tmp___75;
                } else {
                  tmp___76 = realloc((void *)result, memory_size___1);
                  memory___1 = (char *)tmp___76;
                }
                if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
                  goto out_of_memory;
                }
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  if (length > 0UL) {
                    memcpy((void * __restrict  )memory___1, (void const   * __restrict  )result,
                           length);
                  }
                }
                result = memory___1;
              }
            }
            memcpy((void * __restrict  )(result + length), (void const   * __restrict  )tmp___16,
                   count * sizeof(char ));
            if ((unsigned long )tmp___16 != (unsigned long )(tmpbuf)) {
              free((void *)tmp___16);
            }
            length += count;
          } else {
            goto _L___10;
          }
        } else {
          goto _L___10;
        }
      } else {
        _L___10: 
        type = (a.arg + dp->arg_index)->type;
        flags___0 = dp->flags;
        fbp = buf___1;
        tmp___77 = fbp;
        fbp ++;
        *tmp___77 = (char )'%';
        if (flags___0 & 1) {
          tmp___78 = fbp;
          fbp ++;
          *tmp___78 = (char )'\'';
        }
        if (flags___0 & 2) {
          tmp___79 = fbp;
          fbp ++;
          *tmp___79 = (char )'-';
        }
        if (flags___0 & 4) {
          tmp___80 = fbp;
          fbp ++;
          *tmp___80 = (char )'+';
        }
        if (flags___0 & 8) {
          tmp___81 = fbp;
          fbp ++;
          *tmp___81 = (char )' ';
        }
        if (flags___0 & 16) {
          tmp___82 = fbp;
          fbp ++;
          *tmp___82 = (char )'#';
        }
        if (flags___0 & 64) {
          tmp___83 = fbp;
          fbp ++;
          *tmp___83 = (char )'I';
        }
        if (flags___0 & 32) {
          tmp___84 = fbp;
          fbp ++;
          *tmp___84 = (char )'0';
        }
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
          n___1 = (size_t )(dp->width_end - dp->width_start);
          if (sizeof(char ) == sizeof(char )) {
            memcpy((void * __restrict  )fbp, (void const   * __restrict  )dp->width_start,
                   n___1 * sizeof(char ));
            fbp += n___1;
          } else {
            mp = dp->width_start;
            while (1) {
              tmp___85 = fbp;
              fbp ++;
              tmp___86 = mp;
              mp ++;
              *tmp___85 = (char )((unsigned char )*tmp___86);
              n___1 --;
              if (! (n___1 > 0UL)) {
                break;
              }
            }
          }
        }
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
          n___2 = (size_t )(dp->precision_end - dp->precision_start);
          if (sizeof(char ) == sizeof(char )) {
            memcpy((void * __restrict  )fbp, (void const   * __restrict  )dp->precision_start,
                   n___2 * sizeof(char ));
            fbp += n___2;
          } else {
            mp___0 = dp->precision_start;
            while (1) {
              tmp___87 = fbp;
              fbp ++;
              tmp___88 = mp___0;
              mp___0 ++;
              *tmp___87 = (char )((unsigned char )*tmp___88);
              n___2 --;
              if (! (n___2 > 0UL)) {
                break;
              }
            }
          }
        }
        switch ((int )type) {
        case 9: 
        case 10: 
        tmp___89 = fbp;
        fbp ++;
        *tmp___89 = (char )'l';
        case 7: 
        case 8: 
        case 14: 
        case 16: 
        tmp___90 = fbp;
        fbp ++;
        *tmp___90 = (char )'l';
        break;
        case 12: 
        tmp___91 = fbp;
        fbp ++;
        *tmp___91 = (char )'L';
        break;
        default: 
        break;
        }
        *fbp = dp->conversion;
        *(fbp + 1) = (char )'\000';
        prefix_count = 0U;
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            abort();
          }
          tmp___92 = prefix_count;
          prefix_count ++;
          prefixes[tmp___92] = (a.arg + dp->width_arg_index)->a.a_int;
        }
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            abort();
          }
          tmp___93 = prefix_count;
          prefix_count ++;
          prefixes[tmp___93] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        tmp___99 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        if (tmp___99 > (size_t __attribute__((__pure__))  )allocated) {
          if (allocated > 0UL) {
            if (allocated <= 9223372036854775807UL) {
              tmp___94 = allocated * 2UL;
            } else {
              tmp___94 = 0xffffffffffffffffUL;
            }
            allocated = tmp___94;
          } else {
            allocated = (size_t )12;
          }
          tmp___96 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          if (tmp___96 > (size_t __attribute__((__pure__))  )allocated) {
            tmp___95 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
            allocated = (size_t )tmp___95;
          }
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
            memory_size___2 = allocated * sizeof(char );
          } else {
            memory_size___2 = 0xffffffffffffffffUL;
          }
          if (memory_size___2 == 0xffffffffffffffffUL) {
            goto out_of_memory;
          }
          if ((unsigned long )result == (unsigned long )resultbuf) {
            tmp___97 = malloc(memory_size___2);
            memory___2 = (char *)tmp___97;
          } else
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            tmp___97 = malloc(memory_size___2);
            memory___2 = (char *)tmp___97;
          } else {
            tmp___98 = realloc((void *)result, memory_size___2);
            memory___2 = (char *)tmp___98;
          }
          if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
            goto out_of_memory;
          }
          if ((unsigned long )result == (unsigned long )resultbuf) {
            if (length > 0UL) {
              memcpy((void * __restrict  )memory___2, (void const   * __restrict  )result,
                     length);
            }
          }
          result = memory___2;
        }
        *(result + length) = (char )'\000';
        tmp___100 = __errno_location();
        orig_errno = *tmp___100;
        while (1) {
          count___0 = -1;
          retcount = 0;
          maxlen = allocated - length;
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
          maxlen *= sizeof(char ) / sizeof(char );
          tmp___101 = __errno_location();
          *tmp___101 = 0;
          switch ((int )type) {
          case 1: 
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_schar;
          switch ((int )prefix_count) {
          case 0: 
          tmp___102 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___2, & count___0);
          retcount = (int )tmp___102;
          break;
          case 1: 
          tmp___103 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___2, & count___0);
          retcount = (int )tmp___103;
          break;
          case 2: 
          tmp___104 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___2, & count___0);
          retcount = (int )tmp___104;
          break;
          default: 
          abort();
          }
          break;
          case 2: 
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          switch ((int )prefix_count) {
          case 0: 
          tmp___105 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___3, & count___0);
          retcount = (int )tmp___105;
          break;
          case 1: 
          tmp___106 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___3, & count___0);
          retcount = (int )tmp___106;
          break;
          case 2: 
          tmp___107 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___3, & count___0);
          retcount = (int )tmp___107;
          break;
          default: 
          abort();
          }
          break;
          case 3: 
          arg___4 = (int )(a.arg + dp->arg_index)->a.a_short;
          switch ((int )prefix_count) {
          case 0: 
          tmp___108 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___4, & count___0);
          retcount = (int )tmp___108;
          break;
          case 1: 
          tmp___109 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___4, & count___0);
          retcount = (int )tmp___109;
          break;
          case 2: 
          tmp___110 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___4, & count___0);
          retcount = (int )tmp___110;
          break;
          default: 
          abort();
          }
          break;
          case 4: 
          arg___5 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          switch ((int )prefix_count) {
          case 0: 
          tmp___111 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___5, & count___0);
          retcount = (int )tmp___111;
          break;
          case 1: 
          tmp___112 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___5, & count___0);
          retcount = (int )tmp___112;
          break;
          case 2: 
          tmp___113 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___5, & count___0);
          retcount = (int )tmp___113;
          break;
          default: 
          abort();
          }
          break;
          case 5: 
          arg___6 = (a.arg + dp->arg_index)->a.a_int;
          switch ((int )prefix_count) {
          case 0: 
          tmp___114 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___6, & count___0);
          retcount = (int )tmp___114;
          break;
          case 1: 
          tmp___115 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___6, & count___0);
          retcount = (int )tmp___115;
          break;
          case 2: 
          tmp___116 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___6, & count___0);
          retcount = (int )tmp___116;
          break;
          default: 
          abort();
          }
          break;
          case 6: 
          arg___7 = (a.arg + dp->arg_index)->a.a_uint;
          switch ((int )prefix_count) {
          case 0: 
          tmp___117 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___7, & count___0);
          retcount = (int )tmp___117;
          break;
          case 1: 
          tmp___118 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___7, & count___0);
          retcount = (int )tmp___118;
          break;
          case 2: 
          tmp___119 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___7, & count___0);
          retcount = (int )tmp___119;
          break;
          default: 
          abort();
          }
          break;
          case 7: 
          arg___8 = (a.arg + dp->arg_index)->a.a_longint;
          switch ((int )prefix_count) {
          case 0: 
          tmp___120 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___8, & count___0);
          retcount = (int )tmp___120;
          break;
          case 1: 
          tmp___121 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___8, & count___0);
          retcount = (int )tmp___121;
          break;
          case 2: 
          tmp___122 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___8, & count___0);
          retcount = (int )tmp___122;
          break;
          default: 
          abort();
          }
          break;
          case 8: 
          arg___9 = (a.arg + dp->arg_index)->a.a_ulongint;
          switch ((int )prefix_count) {
          case 0: 
          tmp___123 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___9, & count___0);
          retcount = (int )tmp___123;
          break;
          case 1: 
          tmp___124 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___9, & count___0);
          retcount = (int )tmp___124;
          break;
          case 2: 
          tmp___125 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___9, & count___0);
          retcount = (int )tmp___125;
          break;
          default: 
          abort();
          }
          break;
          case 9: 
          arg___10 = (a.arg + dp->arg_index)->a.a_longlongint;
          switch ((int )prefix_count) {
          case 0: 
          tmp___126 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___10, & count___0);
          retcount = (int )tmp___126;
          break;
          case 1: 
          tmp___127 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___10, & count___0);
          retcount = (int )tmp___127;
          break;
          case 2: 
          tmp___128 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___10, & count___0);
          retcount = (int )tmp___128;
          break;
          default: 
          abort();
          }
          break;
          case 10: 
          arg___11 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          switch ((int )prefix_count) {
          case 0: 
          tmp___129 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___11, & count___0);
          retcount = (int )tmp___129;
          break;
          case 1: 
          tmp___130 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___11, & count___0);
          retcount = (int )tmp___130;
          break;
          case 2: 
          tmp___131 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___11, & count___0);
          retcount = (int )tmp___131;
          break;
          default: 
          abort();
          }
          break;
          case 11: 
          arg___12 = (a.arg + dp->arg_index)->a.a_double;
          switch ((int )prefix_count) {
          case 0: 
          tmp___132 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___12, & count___0);
          retcount = (int )tmp___132;
          break;
          case 1: 
          tmp___133 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___12, & count___0);
          retcount = (int )tmp___133;
          break;
          case 2: 
          tmp___134 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___12, & count___0);
          retcount = (int )tmp___134;
          break;
          default: 
          abort();
          }
          break;
          case 12: 
          arg___13 = (a.arg + dp->arg_index)->a.a_longdouble;
          switch ((int )prefix_count) {
          case 0: 
          tmp___135 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___13, & count___0);
          retcount = (int )tmp___135;
          break;
          case 1: 
          tmp___136 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___13, & count___0);
          retcount = (int )tmp___136;
          break;
          case 2: 
          tmp___137 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___13, & count___0);
          retcount = (int )tmp___137;
          break;
          default: 
          abort();
          }
          break;
          case 13: 
          arg___14 = (a.arg + dp->arg_index)->a.a_char;
          switch ((int )prefix_count) {
          case 0: 
          tmp___138 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___14, & count___0);
          retcount = (int )tmp___138;
          break;
          case 1: 
          tmp___139 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___14, & count___0);
          retcount = (int )tmp___139;
          break;
          case 2: 
          tmp___140 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___14, & count___0);
          retcount = (int )tmp___140;
          break;
          default: 
          abort();
          }
          break;
          case 14: 
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_char;
          switch ((int )prefix_count) {
          case 0: 
          tmp___141 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___15, & count___0);
          retcount = (int )tmp___141;
          break;
          case 1: 
          tmp___142 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___15, & count___0);
          retcount = (int )tmp___142;
          break;
          case 2: 
          tmp___143 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___15, & count___0);
          retcount = (int )tmp___143;
          break;
          default: 
          abort();
          }
          break;
          case 15: 
          arg___16 = (a.arg + dp->arg_index)->a.a_string;
          switch ((int )prefix_count) {
          case 0: 
          tmp___144 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___16, & count___0);
          retcount = (int )tmp___144;
          break;
          case 1: 
          tmp___145 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___16, & count___0);
          retcount = (int )tmp___145;
          break;
          case 2: 
          tmp___146 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___16, & count___0);
          retcount = (int )tmp___146;
          break;
          default: 
          abort();
          }
          break;
          case 16: 
          arg___17 = (a.arg + dp->arg_index)->a.a_wide_string;
          switch ((int )prefix_count) {
          case 0: 
          tmp___147 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___17, & count___0);
          retcount = (int )tmp___147;
          break;
          case 1: 
          tmp___148 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___17, & count___0);
          retcount = (int )tmp___148;
          break;
          case 2: 
          tmp___149 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___17, & count___0);
          retcount = (int )tmp___149;
          break;
          default: 
          abort();
          }
          break;
          case 17: 
          arg___18 = (a.arg + dp->arg_index)->a.a_pointer;
          switch ((int )prefix_count) {
          case 0: 
          tmp___150 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               arg___18, & count___0);
          retcount = (int )tmp___150;
          break;
          case 1: 
          tmp___151 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], arg___18, & count___0);
          retcount = (int )tmp___151;
          break;
          case 2: 
          tmp___152 = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___1,
                               prefixes[0], prefixes[1], arg___18, & count___0);
          retcount = (int )tmp___152;
          break;
          default: 
          abort();
          }
          break;
          default: 
          abort();
          }
          if (count___0 >= 0) {
            if ((size_t )count___0 < maxlen) {
              if ((int )*((result + length) + count___0) != 0) {
                abort();
              }
            }
            if (retcount > count___0) {
              count___0 = retcount;
            }
          } else
          if ((int )*(fbp + 1) != 0) {
            *(fbp + 1) = (char )'\000';
            goto __Cont;
          } else
          if (! (retcount < 0)) {
            count___0 = retcount;
          }
          if (count___0 < 0) {
            tmp___153 = __errno_location();
            saved_errno = *tmp___153;
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                free((void *)result);
              }
            }
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              free((void *)buf_malloced);
            }
            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
              free((void *)d.dir);
            }
            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
              free((void *)a.arg);
            }
            tmp___154 = __errno_location();
            if (saved_errno != 0) {
              *tmp___154 = saved_errno;
            } else {
              if ((int )dp->conversion == 99) {
                tmp___155 = 84;
              } else
              if ((int )dp->conversion == 115) {
                tmp___155 = 84;
              } else {
                tmp___155 = 22;
              }
              *tmp___154 = tmp___155;
            }
            return ((char *)((void *)0));
          }
          if ((size_t )((unsigned int )count___0 + 1U) >= maxlen) {
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
              goto overflow;
            } else {
              if (allocated <= 9223372036854775807UL) {
                tmp___156 = allocated * 2UL;
              } else {
                tmp___156 = 0xffffffffffffffffUL;
              }
              tmp___157 = xsum(length, (((unsigned long )((unsigned int )count___0 + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
              tmp___158 = xmax((size_t )tmp___157, tmp___156);
              n___3 = (size_t )tmp___158;
              if (n___3 > allocated) {
                if (allocated > 0UL) {
                  if (allocated <= 9223372036854775807UL) {
                    tmp___159 = allocated * 2UL;
                  } else {
                    tmp___159 = 0xffffffffffffffffUL;
                  }
                  allocated = tmp___159;
                } else {
                  allocated = (size_t )12;
                }
                if (n___3 > allocated) {
                  allocated = n___3;
                }
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
                  memory_size___3 = allocated * sizeof(char );
                } else {
                  memory_size___3 = 0xffffffffffffffffUL;
                }
                if (memory_size___3 == 0xffffffffffffffffUL) {
                  goto out_of_memory;
                }
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  tmp___160 = malloc(memory_size___3);
                  memory___3 = (char *)tmp___160;
                } else
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  tmp___160 = malloc(memory_size___3);
                  memory___3 = (char *)tmp___160;
                } else {
                  tmp___161 = realloc((void *)result, memory_size___3);
                  memory___3 = (char *)tmp___161;
                }
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
                  goto out_of_memory;
                }
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  if (length > 0UL) {
                    memcpy((void * __restrict  )memory___3, (void const   * __restrict  )result,
                           length);
                  }
                }
                result = memory___3;
              }
              goto __Cont;
            }
          }
          length += (size_t )count___0;
          break;
          __Cont: ;
        }
        tmp___162 = __errno_location();
        *tmp___162 = orig_errno;
      }
    }
    cp = dp->dir_end;
    i ++;
    dp ++;
  }
  tmp___169 = xsum(length, (size_t )1);
  if (tmp___169 > (size_t __attribute__((__pure__))  )allocated) {
    if (allocated > 0UL) {
      if (allocated <= 9223372036854775807UL) {
        tmp___164 = allocated * 2UL;
      } else {
        tmp___164 = 0xffffffffffffffffUL;
      }
      allocated = tmp___164;
    } else {
      allocated = (size_t )12;
    }
    tmp___166 = xsum(length, (size_t )1);
    if (tmp___166 > (size_t __attribute__((__pure__))  )allocated) {
      tmp___165 = xsum(length, (size_t )1);
      allocated = (size_t )tmp___165;
    }
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
      memory_size___4 = allocated * sizeof(char );
    } else {
      memory_size___4 = 0xffffffffffffffffUL;
    }
    if (memory_size___4 == 0xffffffffffffffffUL) {
      goto out_of_memory;
    }
    if ((unsigned long )result == (unsigned long )resultbuf) {
      tmp___167 = malloc(memory_size___4);
      memory___4 = (char *)tmp___167;
    } else
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      tmp___167 = malloc(memory_size___4);
      memory___4 = (char *)tmp___167;
    } else {
      tmp___168 = realloc((void *)result, memory_size___4);
      memory___4 = (char *)tmp___168;
    }
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
      goto out_of_memory;
    }
    if ((unsigned long )result == (unsigned long )resultbuf) {
      if (length > 0UL) {
        memcpy((void * __restrict  )memory___4, (void const   * __restrict  )result,
               length);
      }
    }
    result = memory___4;
  }
  *(result + length) = (char )'\000';
  if ((unsigned long )result != (unsigned long )resultbuf) {
    if (length + 1UL < allocated) {
      tmp___170 = realloc((void *)result, (length + 1UL) * sizeof(char ));
      memory___5 = (char *)tmp___170;
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
        result = memory___5;
      }
    }
  }
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    free((void *)buf_malloced);
  }
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    free((void *)d.dir);
  }
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    free((void *)a.arg);
  }
  *lengthp = length;
  return (result);
  overflow: 
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      free((void *)result);
    }
  }
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    free((void *)buf_malloced);
  }
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    free((void *)d.dir);
  }
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    free((void *)a.arg);
  }
  tmp___171 = __errno_location();
  *tmp___171 = 75;
  return ((char *)((void *)0));
  out_of_memory: 
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      free((void *)result);
    }
  }
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    free((void *)buf_malloced);
  }
  out_of_memory_1: 
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    free((void *)d.dir);
  }
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    free((void *)a.arg);
  }
  tmp___172 = __errno_location();
  *tmp___172 = 12;
  return ((char *)((void *)0));
}
}
int rpl_vasprintf(char **resultp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
int rpl_vasprintf(char **resultp , char const   *format , va_list args ) 
{ size_t length ;
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
  tmp = vasnprintf((char *)((void *)0), & length, format, args);
  result = tmp;
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (length > 2147483647UL) {
    free((void *)result);
    tmp___0 = __errno_location();
    *tmp___0 = 75;
    return (-1);
  }
  *resultp = result;
  return ((int )length);
}
}
int rpl_vfprintf(FILE *fp , char const   *format , va_list args )  __attribute__((__nonnull__(1,2))) ;
int rpl_vfprintf(FILE *fp , char const   *format , va_list args ) 
{ char buf___1[2000] ;
  char *output ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t __attribute__((__nonnull__(1,4)))  tmp___1 ;
  int *tmp___2 ;

  {
  lenbuf = sizeof(buf___1);
  output = vasnprintf(buf___1, & lenbuf, format, args);
  len = lenbuf;
  if (! output) {
    fseterr(fp);
    return (-1);
  }
  tmp___1 = rpl_fwrite((void const   *)output, (size_t )1, len, fp);
  if (tmp___1 < (size_t __attribute__((__nonnull__(1,4)))  )len) {
    if ((unsigned long )output != (unsigned long )(buf___1)) {
      tmp = __errno_location();
      saved_errno = *tmp;
      free((void *)output);
      tmp___0 = __errno_location();
      *tmp___0 = saved_errno;
    }
    return (-1);
  }
  if ((unsigned long )output != (unsigned long )(buf___1)) {
    free((void *)output);
  }
  if (len > 2147483647UL) {
    tmp___2 = __errno_location();
    *tmp___2 = 75;
    fseterr(fp);
    return (-1);
  }
  return ((int )len);
}
}
int rpl_vprintf(char const   *format , va_list args )  __attribute__((__nonnull__(1))) ;
int rpl_vprintf(char const   *format , va_list args ) 
{ int tmp ;

  {
  tmp = rpl_vfprintf(stdout, format, args);
  return (tmp);
}
}
_Bool euidaccess_stat(struct stat  const  *st , int mode ) ;
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
_Bool euidaccess_stat(struct stat  const  *st , int mode ) 
{ uid_t euid ;
  unsigned int granted ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  gid_t egid ;
  __gid_t tmp___11 ;
  int tmp___12 ;

  {
  mode &= 7;
  if (mode == 0) {
    return ((_Bool)1);
  }
  euid = geteuid();
  if (euid == 0U) {
    if ((mode & 1) == 0) {
      return ((_Bool)1);
    } else
    if (st->st_mode & (unsigned int const   )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
      return ((_Bool)1);
    }
  }
  if (256 == 4 << 6) {
    if (128 == 2 << 6) {
      if (64 == 1 << 6) {
        if (256 >> 3 == 4 << 3) {
          if (128 >> 3 == 2 << 3) {
            if (64 >> 3 == 1 << 3) {
              if ((256 >> 3) >> 3 == 4) {
                if ((128 >> 3) >> 3 == 2) {
                  if ((64 >> 3) >> 3 == 1) {
                    granted = (unsigned int )st->st_mode;
                  } else {
                    goto _L___6;
                  }
                } else {
                  goto _L___6;
                }
              } else {
                goto _L___6;
              }
            } else {
              goto _L___6;
            }
          } else {
            goto _L___6;
          }
        } else {
          goto _L___6;
        }
      } else {
        goto _L___6;
      }
    } else {
      goto _L___6;
    }
  } else {
    _L___6: 
    if (st->st_mode & 256U) {
      tmp___2 = 4 << 6;
    } else {
      tmp___2 = 0;
    }
    if (st->st_mode & 128U) {
      tmp___3 = 2 << 6;
    } else {
      tmp___3 = 0;
    }
    if (st->st_mode & 64U) {
      tmp___4 = 1 << 6;
    } else {
      tmp___4 = 0;
    }
    if (st->st_mode & (unsigned int const   )(256 >> 3)) {
      tmp___5 = 4 << 3;
    } else {
      tmp___5 = 0;
    }
    if (st->st_mode & (unsigned int const   )(128 >> 3)) {
      tmp___6 = 2 << 3;
    } else {
      tmp___6 = 0;
    }
    if (st->st_mode & (unsigned int const   )(64 >> 3)) {
      tmp___7 = 1 << 3;
    } else {
      tmp___7 = 0;
    }
    if (st->st_mode & (unsigned int const   )((256 >> 3) >> 3)) {
      tmp___8 = 4;
    } else {
      tmp___8 = 0;
    }
    if (st->st_mode & (unsigned int const   )((128 >> 3) >> 3)) {
      tmp___9 = 2;
    } else {
      tmp___9 = 0;
    }
    if (st->st_mode & (unsigned int const   )((64 >> 3) >> 3)) {
      tmp___10 = 1;
    } else {
      tmp___10 = 0;
    }
    granted = (unsigned int )((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) + tmp___6) + tmp___7) + tmp___8) + tmp___9) + tmp___10);
  }
  if (euid == (uid_t )st->st_uid) {
    granted >>= 6;
  } else {
    tmp___11 = getegid();
    egid = tmp___11;
    if (egid == (gid_t )st->st_gid) {
      granted >>= 3;
    } else {
      tmp___12 = group_member((__gid_t )st->st_gid);
      if (tmp___12) {
        granted >>= 3;
      }
    }
  }
  if (((unsigned int )mode & ~ granted) == 0U) {
    return ((_Bool)1);
  }
  return ((_Bool)0);
}
}
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) ;
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) 
{ int fd ;
  int __attribute__((__artificial__))  tmp ;
  int fd2 ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  tmp = open(file, flags, mode);
  fd = (int )tmp;
  if (fd == desired_fd) {
    return (fd);
  } else
  if (fd < 0) {
    return (fd);
  } else {
    tmp___0 = dup2(fd, desired_fd);
    fd2 = tmp___0;
    tmp___1 = __errno_location();
    saved_errno = *tmp___1;
    close(fd);
    tmp___2 = __errno_location();
    *tmp___2 = saved_errno;
    return (fd2);
  }
}
}
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) ;
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent )  __attribute__((__pure__)) ;
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) 
{ FTS *fts ;
  FTS *tmp ;
  int *tmp___0 ;

  {
  tmp = fts_open(argv, options | 512, compar);
  fts = tmp;
  if ((unsigned long )fts == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    if (! (*tmp___0 != 22)) {
      __assert_fail("(*__errno_location ()) != 22", "xfts.c", 41U, "xfts_open");
    }
    xalloc_die();
  }
  return (fts);
}
}
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent )  __attribute__((__pure__)) ;
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent ) 
{ int tmp ;

  {
  if (fts->fts_options & 16) {
    if (! (fts->fts_options & 1)) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: 
  if (fts->fts_options & 16) {
    if (fts->fts_options & 1) {
      if (ent->fts_level != 0L) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
int strintcmp(char const   *a , char const   *b )  __attribute__((__pure__)) ;
__inline static int __attribute__((__pure__))  fraccompare(char const   *a , char const   *b ,
                                                           char decimal_point ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((int const   )*a == (int const   )decimal_point) {
    if ((int const   )*b == (int const   )decimal_point) {
      while (1) {
        a ++;
        b ++;
        if (! ((int const   )*a == (int const   )*b)) {
          break;
        }
        if (! ((unsigned int )*a - 48U <= 9U)) {
          return ((int __attribute__((__pure__))  )0);
        }
      }
      if ((unsigned int )*a - 48U <= 9U) {
        if ((unsigned int )*b - 48U <= 9U) {
          return ((int __attribute__((__pure__))  )((int const   )*a - (int const   )*b));
        }
      }
      if ((unsigned int )*a - 48U <= 9U) {
        goto a_trailing_nonzero;
      }
      if ((unsigned int )*b - 48U <= 9U) {
        goto b_trailing_nonzero;
      }
      return ((int __attribute__((__pure__))  )0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    tmp___0 = a;
    a ++;
    if ((int const   )*tmp___0 == (int const   )decimal_point) {
      a_trailing_nonzero: 
      while ((int const   )*a == 48) {
        a ++;
      }
      return ((int __attribute__((__pure__))  )((unsigned int )*a - 48U <= 9U));
    } else {
      tmp = b;
      b ++;
      if ((int const   )*tmp == (int const   )decimal_point) {
        b_trailing_nonzero: 
        while ((int const   )*b == 48) {
          b ++;
        }
        return ((int __attribute__((__pure__))  )(- ((unsigned int )*b - 48U <= 9U)));
      }
    }
  }
  return ((int __attribute__((__pure__))  )0);
}
}
__inline static int __attribute__((__pure__))  numcompare(char const   *a , char const   *b ,
                                                          int decimal_point , int thousands_sep ) 
{ unsigned char tmpa ;
  unsigned char tmpb ;
  int tmp ;
  size_t log_a ;
  size_t log_b ;
  int __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int tmp___3 ;

  {
  tmpa = (unsigned char )*a;
  tmpb = (unsigned char )*b;
  if ((int )tmpa == 45) {
    while (1) {
      a ++;
      tmpa = (unsigned char )*a;
      if (! ((int )tmpa == 48)) {
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
    }
    if ((int )tmpb != 45) {
      if ((int )tmpa == decimal_point) {
        while (1) {
          a ++;
          tmpa = (unsigned char )*a;
          if (! ((int )tmpa == 48)) {
            break;
          }
        }
      }
      if ((unsigned int )tmpa - 48U <= 9U) {
        return ((int __attribute__((__pure__))  )-1);
      }
      while (1) {
        if (! ((int )tmpb == 48)) {
          if (! ((int )tmpb == thousands_sep)) {
            break;
          }
        }
        b ++;
        tmpb = (unsigned char )*b;
      }
      if ((int )tmpb == decimal_point) {
        while (1) {
          b ++;
          tmpb = (unsigned char )*b;
          if (! ((int )tmpb == 48)) {
            break;
          }
        }
      }
      return ((int __attribute__((__pure__))  )(- ((unsigned int )tmpb - 48U <= 9U)));
    }
    while (1) {
      b ++;
      tmpb = (unsigned char )*b;
      if (! ((int )tmpb == 48)) {
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
    }
    while (1) {
      if ((int )tmpa == (int )tmpb) {
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
          break;
        }
      } else {
        break;
      }
      while (1) {
        a ++;
        tmpa = (unsigned char )*a;
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
      while (1) {
        b ++;
        tmpb = (unsigned char )*b;
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
    }
    if ((int )tmpa == decimal_point) {
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
        tmp___0 = fraccompare(b, a, (char )decimal_point);
        return (tmp___0);
      } else {
        goto _L;
      }
    } else
    _L: 
    if ((int )tmpb == decimal_point) {
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
        tmp___0 = fraccompare(b, a, (char )decimal_point);
        return (tmp___0);
      }
    }
    tmp = (int )tmpb - (int )tmpa;
    log_a = (size_t )0;
    while ((unsigned int )tmpa - 48U <= 9U) {
      while (1) {
        a ++;
        tmpa = (unsigned char )*a;
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
      log_a ++;
    }
    log_b = (size_t )0;
    while ((unsigned int )tmpb - 48U <= 9U) {
      while (1) {
        b ++;
        tmpb = (unsigned char )*b;
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
      log_b ++;
    }
    if (log_a != log_b) {
      if (log_a < log_b) {
        tmp___1 = 1;
      } else {
        tmp___1 = -1;
      }
      return ((int __attribute__((__pure__))  )tmp___1);
    }
    if (! log_a) {
      return ((int __attribute__((__pure__))  )0);
    }
    return ((int __attribute__((__pure__))  )tmp);
  } else
  if ((int )tmpb == 45) {
    while (1) {
      b ++;
      tmpb = (unsigned char )*b;
      if (! ((int )tmpb == 48)) {
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
    }
    if ((int )tmpb == decimal_point) {
      while (1) {
        b ++;
        tmpb = (unsigned char )*b;
        if (! ((int )tmpb == 48)) {
          break;
        }
      }
    }
    if ((unsigned int )tmpb - 48U <= 9U) {
      return ((int __attribute__((__pure__))  )1);
    }
    while (1) {
      if (! ((int )tmpa == 48)) {
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
      a ++;
      tmpa = (unsigned char )*a;
    }
    if ((int )tmpa == decimal_point) {
      while (1) {
        a ++;
        tmpa = (unsigned char )*a;
        if (! ((int )tmpa == 48)) {
          break;
        }
      }
    }
    return ((int __attribute__((__pure__))  )((unsigned int )tmpa - 48U <= 9U));
  } else {
    while (1) {
      if (! ((int )tmpa == 48)) {
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
      a ++;
      tmpa = (unsigned char )*a;
    }
    while (1) {
      if (! ((int )tmpb == 48)) {
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
      b ++;
      tmpb = (unsigned char )*b;
    }
    while (1) {
      if ((int )tmpa == (int )tmpb) {
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
          break;
        }
      } else {
        break;
      }
      while (1) {
        a ++;
        tmpa = (unsigned char )*a;
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
      while (1) {
        b ++;
        tmpb = (unsigned char )*b;
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
    }
    if ((int )tmpa == decimal_point) {
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
        tmp___2 = fraccompare(a, b, (char )decimal_point);
        return (tmp___2);
      } else {
        goto _L___0;
      }
    } else
    _L___0: 
    if ((int )tmpb == decimal_point) {
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
        tmp___2 = fraccompare(a, b, (char )decimal_point);
        return (tmp___2);
      }
    }
    tmp = (int )tmpa - (int )tmpb;
    log_a = (size_t )0;
    while ((unsigned int )tmpa - 48U <= 9U) {
      while (1) {
        a ++;
        tmpa = (unsigned char )*a;
        if (! ((int )tmpa == thousands_sep)) {
          break;
        }
      }
      log_a ++;
    }
    log_b = (size_t )0;
    while ((unsigned int )tmpb - 48U <= 9U) {
      while (1) {
        b ++;
        tmpb = (unsigned char )*b;
        if (! ((int )tmpb == thousands_sep)) {
          break;
        }
      }
      log_b ++;
    }
    if (log_a != log_b) {
      if (log_a < log_b) {
        tmp___3 = -1;
      } else {
        tmp___3 = 1;
      }
      return ((int __attribute__((__pure__))  )tmp___3);
    }
    if (! log_a) {
      return ((int __attribute__((__pure__))  )0);
    }
    return ((int __attribute__((__pure__))  )tmp);
  }
}
}
int strintcmp(char const   *a , char const   *b )  __attribute__((__pure__)) ;
int strintcmp(char const   *a , char const   *b ) 
{ int __attribute__((__pure__))  tmp ;

  {
  tmp = numcompare(a, b, -1, -1);
  return ((int )tmp);
}
}
int __attribute__((__pure__))  strnumcmp(char const   *a , char const   *b , int decimal_point ,
                                         int thousands_sep ) ;
int __attribute__((__pure__))  strnumcmp(char const   *a , char const   *b , int decimal_point ,
                                         int thousands_sep ) 
{ int __attribute__((__pure__))  tmp ;

  {
  tmp = numcompare(a, b, decimal_point, thousands_sep);
  return (tmp);
}
}
char const   *Version  =    "8.13.14-081e2-dirty";
extern  __attribute__((__nothrow__)) void sync(void) ;
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *canonicalize_file_name(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
__inline static void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
__inline static void emit_size_note(void) 
{ char *tmp ;

  {
  tmp = gettext("\nSIZE may be (or may be an integer optionally followed by) one of following:\nKB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n");
  fputs_unlocked((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);
  return;
}
}
__inline static void emit_blocksize_note(char const   *program ) 
{ char *tmp ;

  {
  tmp = gettext("\nDisplay values are in units of the first available SIZE from --block-size,\nand the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\nOtherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n");
  printf((char const   * __restrict  )tmp, program);
  return;
}
}
__inline static void emit_ancillary_info(void) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *lc_messages ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  tmp = last_component(program_name);
  tmp___0 = gettext("\nReport %s bugs to %s\n");
  printf((char const   * __restrict  )tmp___0, tmp, "bug-coreutils@gnu.org");
  tmp___1 = gettext("%s home page: <%s>\n");
  printf((char const   * __restrict  )tmp___1, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
  tmp___2 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
  fputs_unlocked((char const   * __restrict  )tmp___2, (FILE * __restrict  )stdout);
  tmp___3 = setlocale(5, (char const   *)((void *)0));
  lc_messages = (char const   *)tmp___3;
  if (lc_messages) {
    tmp___6 = strncmp(lc_messages, "en_", sizeof("en_") - 1UL);
    if (tmp___6) {
      tmp___4 = last_component(program_name);
      tmp___5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
      printf((char const   * __restrict  )tmp___5, tmp___4);
    }
  }
  tmp___7 = last_component(program_name);
  tmp___8 = gettext("For complete documentation, run: info coreutils \'%s invocation\'\n");
  printf((char const   * __restrict  )tmp___8, tmp___7);
  return;
}
}
extern char *find_mount_point(char const   *file , struct stat  const  *file_stat ) ;
static _Bool inode_format  ;
static _Bool show_all_fs  ;
static _Bool show_local_fs  ;
static _Bool show_listed_fs  ;
static int human_output_opts  ;
static uintmax_t output_block_size  ;
static _Bool posix_format  ;
static _Bool file_systems_processed  ;
static _Bool require_sync  ;
static int exit_status  ;
static struct fs_type_list *fs_select_list  ;
static struct fs_type_list *fs_exclude_list  ;
static struct mount_entry *mount_list  ;
static _Bool print_type  ;
static _Bool print_grand_total  ;
static struct fs_usage grand_fsu  ;
static int header_mode  =    0;
static char const   *headers[7][4]  = { {        "Filesystem",        (char const   *)((void *)0),        (char const   *)((void *)0),        (char const   *)((void *)0)}, 
   {        "Type",        (char const   *)((void *)0),        (char const   *)((void *)0),        (char const   *)((void *)0)}, 
   {        "blocks",        "Inodes",        "Size",        (char const   *)((void *)0)}, 
   {        "Used",        "IUsed",        (char const   *)((void *)0),        (char const   *)((void *)0)}, 
   {        "Available",        "IFree",        "Avail",        (char const   *)((void *)0)}, 
   {        "Use%",        "IUse%",        (char const   *)((void *)0),        "Capacity"}, 
   {        "Mounted on",        (char const   *)((void *)0),        (char const   *)((void *)0),        (char const   *)((void *)0)}};
static mbs_align_t alignments[7]  = {      (mbs_align_t )0,      (mbs_align_t )0,      (mbs_align_t )1,      (mbs_align_t )1, 
        (mbs_align_t )1,      (mbs_align_t )1,      (mbs_align_t )0};
static size_t widths[7]  = {      (size_t )14,      (size_t )4,      (size_t )5,      (size_t )5, 
        (size_t )5,      (size_t )4,      (size_t )0};
static char ***table___0  ;
static size_t nrows  ;
static struct rpl_option  const  long_options___0[17]  = 
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"block-size", 1, (int *)((void *)0), 'B'}, 
        {"inodes", 0, (int *)((void *)0), 'i'}, 
        {"human-readable", 0, (int *)((void *)0), 'h'}, 
        {"si", 0, (int *)((void *)0), 'H'}, 
        {"local", 0, (int *)((void *)0), 'l'}, 
        {"megabytes", 0, (int *)((void *)0), 'm'}, 
        {"portability", 0, (int *)((void *)0), 'P'}, 
        {"print-type", 0, (int *)((void *)0), 'T'}, 
        {"sync", 0, (int *)((void *)0), 129}, 
        {"no-sync", 0, (int *)((void *)0), 128}, 
        {"total", 0, (int *)((void *)0), 'c'}, 
        {"type", 1, (int *)((void *)0), 't'}, 
        {"exclude-type", 1, (int *)((void *)0), 'x'}, 
        {"help", 0, (int *)((void *)0), -130}, 
        {"version", 0, (int *)((void *)0), -131}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
static void alloc_table_row(void) 
{ void *tmp ;
  void *tmp___0 ;

  {
  nrows ++;
  tmp = xnrealloc((void *)table___0, nrows, sizeof(char *));
  table___0 = (char ***)tmp;
  tmp___0 = xnmalloc((size_t )7, sizeof(char *));
  *(table___0 + (nrows - 1UL)) = (char **)tmp___0;
  return;
}
}
static void print_table(void) 
{ size_t field ;
  size_t row ;
  size_t width ;
  char *cell ;
  char *tmp ;

  {
  row = (size_t )0;
  while (row < nrows) {
    field = (size_t )0;
    while (field < 7UL) {
      width = widths[field];
      cell = *(*(table___0 + row) + field);
      if (! cell) {
        goto __Cont;
      }
      if (field != 0UL) {
        putchar_unlocked(' ');
      }
      if (field == 6UL) {
        fputs_unlocked((char const   * __restrict  )cell, (FILE * __restrict  )stdout);
      } else {
        cell = ambsalign((char const   *)cell, & width, alignments[field], 0);
        if (cell) {
          tmp = cell;
        } else {
          tmp = *(*(table___0 + row) + field);
        }
        fputs_unlocked((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);
        free((void *)cell);
      }
      __Cont: /* CIL Label */ 
      field ++;
    }
    putchar_unlocked('\n');
    row ++;
  }
  return;
}
}
static void get_header(void) 
{ size_t field ;
  char *cell ;
  char const   *header ;
  char *tmp ;
  char *tmp___0 ;
  char buf___1[(((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL) + 1UL] ;
  int opts ;
  uintmax_t q1000 ;
  uintmax_t q1024 ;
  _Bool divisible_by_1000 ;
  _Bool divisible_by_1024 ;
  char *num ;
  char *tmp___1 ;
  int tmp___2 ;
  char buf___2[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *num___0 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  alloc_table_row();
  field = (size_t )0;
  while (field < 7UL) {
    if (field == 1UL) {
      if (! print_type) {
        *(*(table___0 + (nrows - 1UL)) + field) = (char *)((void *)0);
        goto __Cont;
      }
    }
    cell = (char *)((void *)0);
    tmp = gettext(headers[field][header_mode]);
    header = (char const   *)tmp;
    if (! header) {
      tmp___0 = gettext(headers[field][0]);
      header = (char const   *)tmp___0;
    }
    if (header_mode == 0) {
      if (field == 2UL) {
        opts = 152 | (human_output_opts & 292);
        q1000 = output_block_size;
        q1024 = output_block_size;
        while (1) {
          divisible_by_1000 = (_Bool )(q1000 % 1000UL == 0UL);
          q1000 /= 1000UL;
          divisible_by_1024 = (_Bool )(q1024 % 1024UL == 0UL);
          q1024 /= 1024UL;
          if (! ((int )divisible_by_1000 & (int )divisible_by_1024)) {
            break;
          }
        }
        if ((int )divisible_by_1000 < (int )divisible_by_1024) {
          opts |= 32;
        }
        if ((int )divisible_by_1024 < (int )divisible_by_1000) {
          opts &= -33;
        }
        if (! (opts & 32)) {
          opts |= 256;
        }
        tmp___1 = human_readable(output_block_size, buf___1, opts, (uintmax_t )1,
                                 (uintmax_t )1);
        num = tmp___1;
        tmp___2 = rpl_asprintf(& cell, "%s-%s", num, header);
        if (tmp___2 == -1) {
          cell = (char *)((void *)0);
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (header_mode == 3) {
      if (field == 2UL) {
        tmp___3 = (char *)umaxtostr(output_block_size, buf___2);
        num___0 = tmp___3;
        tmp___4 = rpl_asprintf(& cell, "%s-%s", num___0, header);
        if (tmp___4 == -1) {
          cell = (char *)((void *)0);
        }
      } else {
        cell = strdup(header);
      }
    } else {
      cell = strdup(header);
    }
    if (! cell) {
      xalloc_die();
    }
    *(*(table___0 + (nrows - 1UL)) + field) = cell;
    tmp___7 = gnu_mbswidth((char const   *)cell, 0);
    if (widths[field] > (size_t )tmp___7) {
      widths[field] = widths[field];
    } else {
      tmp___6 = gnu_mbswidth((char const   *)cell, 0);
      widths[field] = (size_t )tmp___6;
    }
    __Cont: /* CIL Label */ 
    field ++;
  }
  return;
}
}
static _Bool __attribute__((__pure__))  selected_fstype(char const   *fstype ) 
{ struct fs_type_list  const  *fsp ;
  int tmp ;

  {
  if ((unsigned long )fs_select_list == (unsigned long )((void *)0)) {
    return ((_Bool __attribute__((__pure__))  )1);
  } else
  if ((unsigned long )fstype == (unsigned long )((void *)0)) {
    return ((_Bool __attribute__((__pure__))  )1);
  }
  fsp = (struct fs_type_list  const  *)fs_select_list;
  while (fsp) {
    tmp = strcmp(fstype, (char const   *)fsp->fs_name);
    if (tmp == 0) {
      return ((_Bool __attribute__((__pure__))  )1);
    }
    fsp = (struct fs_type_list  const  *)fsp->fs_next;
  }
  return ((_Bool __attribute__((__pure__))  )0);
}
}
static _Bool __attribute__((__pure__))  excluded_fstype(char const   *fstype ) 
{ struct fs_type_list  const  *fsp ;
  int tmp ;

  {
  if ((unsigned long )fs_exclude_list == (unsigned long )((void *)0)) {
    return ((_Bool __attribute__((__pure__))  )0);
  } else
  if ((unsigned long )fstype == (unsigned long )((void *)0)) {
    return ((_Bool __attribute__((__pure__))  )0);
  }
  fsp = (struct fs_type_list  const  *)fs_exclude_list;
  while (fsp) {
    tmp = strcmp(fstype, (char const   *)fsp->fs_name);
    if (tmp == 0) {
      return ((_Bool __attribute__((__pure__))  )1);
    }
    fsp = (struct fs_type_list  const  *)fsp->fs_next;
  }
  return ((_Bool __attribute__((__pure__))  )0);
}
}
static _Bool known_value(uintmax_t n ) 
{ 

  {
  return ((_Bool )(n < 0xfffffffffffffffeUL));
}
}
static char const   *df_readable(_Bool negative , uintmax_t n , char *buf___1 , uintmax_t input_units ,
                                 uintmax_t output_units ) 
{ char *p ;
  uintmax_t tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp___1 = known_value(n);
  if (tmp___1) {
    _L: /* CIL Label */ 
    if (negative) {
      tmp = - n;
    } else {
      tmp = n;
    }
    tmp___0 = human_readable(tmp, buf___1 + (int )negative, human_output_opts, input_units,
                             output_units);
    p = tmp___0;
    if (negative) {
      p --;
      *p = (char )'-';
    }
    return ((char const   *)p);
  } else
  if (! negative) {
    return ("-");
  } else {
    goto _L;
  }
}
}
static void add_uint_with_neg_flag(uintmax_t *dest , _Bool *dest_neg , uintmax_t src ,
                                   _Bool src_neg ) 
{ 

  {
  if (! *dest_neg == ! src_neg) {
    *dest += src;
    return;
  }
  if (*dest_neg) {
    *dest = - *dest;
  }
  if (src_neg) {
    src = - src;
  }
  if (src < *dest) {
    *dest -= src;
  } else {
    *dest = src - *dest;
    *dest_neg = src_neg;
  }
  if (*dest_neg) {
    *dest = - *dest;
  }
  return;
}
}
static void get_dev(char const   *disk , char const   *mount_point , char const   *stat_file ,
                    char const   *fstype , _Bool me_dummy , _Bool me_remote , struct fs_usage  const  *force_fsu ) 
{ struct fs_usage fsu ;
  char buf___1[(((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL) + 2UL] ;
  uintmax_t input_units ;
  uintmax_t output_units ;
  uintmax_t total ;
  uintmax_t available ;
  _Bool negate_available ;
  uintmax_t available_to_root ;
  uintmax_t used ;
  _Bool negate_used ;
  double pct ;
  char *cell ;
  size_t field ;
  _Bool __attribute__((__pure__))  tmp ;
  _Bool __attribute__((__pure__))  tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  uintmax_t u100 ;
  uintmax_t nonroot_total ;
  double u ;
  double tmp___17 ;
  double a ;
  double tmp___18 ;
  double nonroot_total___0 ;
  long lipct ;
  double ipct ;
  _Bool tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  pct = (double )-1;
  if (me_remote) {
    if (show_local_fs) {
      return;
    }
  }
  if (me_dummy) {
    if (! show_all_fs) {
      if (! show_listed_fs) {
        return;
      }
    }
  }
  tmp = selected_fstype(fstype);
  if (tmp) {
    tmp___0 = excluded_fstype(fstype);
    if (tmp___0) {
      return;
    }
  } else {
    return;
  }
  if (! stat_file) {
    if (mount_point) {
      stat_file = mount_point;
    } else {
      stat_file = disk;
    }
  }
  if (force_fsu) {
    fsu = (struct fs_usage )*force_fsu;
  } else {
    tmp___3 = get_fs_usage(stat_file, disk, & fsu);
    if (tmp___3) {
      tmp___1 = quote(stat_file);
      tmp___2 = __errno_location();
      error(0, *tmp___2, "%s", tmp___1);
      exit_status = 1;
      return;
    }
  }
  if (fsu.fsu_blocks == 0UL) {
    if (! show_all_fs) {
      if (! show_listed_fs) {
        return;
      }
    }
  }
  if (! file_systems_processed) {
    file_systems_processed = (_Bool)1;
    get_header();
  }
  alloc_table_row();
  if (! disk) {
    disk = "-";
  }
  if (! fstype) {
    fstype = "-";
  }
  if (inode_format) {
    output_units = (uintmax_t )1;
    input_units = output_units;
    total = fsu.fsu_files;
    available = fsu.fsu_ffree;
    negate_available = (_Bool)0;
    available_to_root = available;
    tmp___4 = known_value(total);
    if (tmp___4) {
      grand_fsu.fsu_files += total;
    }
    tmp___5 = known_value(available);
    if (tmp___5) {
      grand_fsu.fsu_ffree += available;
    }
  } else {
    input_units = fsu.fsu_blocksize;
    output_units = output_block_size;
    total = fsu.fsu_blocks;
    available = fsu.fsu_bavail;
    if (fsu.fsu_bavail_top_bit_set) {
      tmp___6 = known_value(available);
      if (tmp___6) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
    negate_available = (_Bool )tmp___7;
    available_to_root = fsu.fsu_bfree;
    tmp___8 = known_value(total);
    if (tmp___8) {
      grand_fsu.fsu_blocks += input_units * total;
    }
    tmp___9 = known_value(available_to_root);
    if (tmp___9) {
      grand_fsu.fsu_bfree += input_units * available_to_root;
    }
    tmp___10 = known_value(available);
    if (tmp___10) {
      add_uint_with_neg_flag(& grand_fsu.fsu_bavail, & grand_fsu.fsu_bavail_top_bit_set,
                             input_units * available, negate_available);
    }
  }
  used = 0xffffffffffffffffUL;
  negate_used = (_Bool)0;
  tmp___11 = known_value(total);
  if (tmp___11) {
    tmp___12 = known_value(available_to_root);
    if (tmp___12) {
      used = total - available_to_root;
      negate_used = (_Bool )(total < available_to_root);
    }
  }
  field = (size_t )0;
  while (field < 7UL) {
    switch ((int )field) {
    case 0: 
    cell = xstrdup(disk);
    break;
    case 1: 
    if (print_type) {
      tmp___13 = xstrdup(fstype);
      cell = tmp___13;
    } else {
      cell = (char *)((void *)0);
    }
    break;
    case 2: 
    tmp___14 = df_readable((_Bool)0, total, buf___1, input_units, output_units);
    cell = xstrdup(tmp___14);
    break;
    case 3: 
    tmp___15 = df_readable(negate_used, used, buf___1, input_units, output_units);
    cell = xstrdup(tmp___15);
    break;
    case 4: 
    tmp___16 = df_readable(negate_available, available, buf___1, input_units, output_units);
    cell = xstrdup(tmp___16);
    break;
    case 5: 
    tmp___19 = known_value(used);
    if (tmp___19) {
      tmp___20 = known_value(available);
      if (tmp___20) {
        if (! negate_used) {
          if (used <= 184467440737095516UL) {
            if (used + available != 0UL) {
              if ((used + available < used) == (int )negate_available) {
                u100 = used * 100UL;
                nonroot_total = used + available;
                pct = (double )(u100 / nonroot_total + (uintmax_t )(u100 % nonroot_total != 0UL));
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          if (negate_used) {
            tmp___17 = - ((double )(- used));
          } else {
            tmp___17 = (double )used;
          }
          u = tmp___17;
          if (negate_available) {
            tmp___18 = - ((double )(- available));
          } else {
            tmp___18 = (double )available;
          }
          a = tmp___18;
          nonroot_total___0 = u + a;
          if (nonroot_total___0) {
            pct = (u * (double )100) / nonroot_total___0;
            lipct = (long )pct;
            ipct = (double )lipct;
            if (ipct - (double )1 < pct) {
              if (pct <= ipct + (double )1) {
                pct = ipct + (double )(ipct < pct);
              }
            }
          }
        }
      }
    }
    if ((double )0 <= pct) {
      tmp___21 = rpl_asprintf(& cell, "%.0f%%", pct);
      if (tmp___21 == -1) {
        cell = (char *)((void *)0);
      }
    } else {
      cell = strdup("-");
    }
    if (! cell) {
      xalloc_die();
    }
    break;
    case 6: 
    if (mount_point) {
      cell = xstrdup(mount_point);
    } else {
      cell = (char *)((void *)0);
    }
    break;
    default: 
    __assert_fail("!\"unhandled field\"", "df.c", 626U, "get_dev");
    }
    if (cell) {
      tmp___24 = gnu_mbswidth((char const   *)cell, 0);
      if (widths[field] > (size_t )tmp___24) {
        widths[field] = widths[field];
      } else {
        tmp___23 = gnu_mbswidth((char const   *)cell, 0);
        widths[field] = (size_t )tmp___23;
      }
    }
    *(*(table___0 + (nrows - 1UL)) + field) = cell;
    field ++;
  }
  return;
}
}
static _Bool get_disk(char const   *disk ) 
{ struct mount_entry  const  *me ;
  struct mount_entry  const  *best_match ;
  int tmp ;

  {
  best_match = (struct mount_entry  const  *)((void *)0);
  me = (struct mount_entry  const  *)mount_list;
  while (me) {
    tmp = strcmp(disk, (char const   *)me->me_devname);
    if (tmp == 0) {
      best_match = me;
    }
    me = (struct mount_entry  const  *)me->me_next;
  }
  if (best_match) {
    get_dev((char const   *)best_match->me_devname, (char const   *)best_match->me_mountdir,
            (char const   *)((void *)0), (char const   *)best_match->me_type, (_Bool )best_match->me_dummy,
            (_Bool )best_match->me_remote, (struct fs_usage  const  *)((void *)0));
    return ((_Bool)1);
  }
  return ((_Bool)0);
}
}
static void get_point(char const   *point , struct stat  const  *statp ) 
{ struct stat disk_stats ;
  struct mount_entry *me ;
  struct mount_entry  const  *best_match ;
  char *resolved ;
  char *tmp ;
  size_t resolved_len ;
  size_t tmp___0 ;
  size_t best_match_len ;
  size_t len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *mp ;
  char *tmp___11 ;

  {
  best_match = (struct mount_entry  const  *)((void *)0);
  tmp = canonicalize_file_name(point);
  resolved = tmp;
  if (resolved) {
    if ((int )*(resolved + 0) == 47) {
      tmp___0 = strlen((char const   *)resolved);
      resolved_len = tmp___0;
      best_match_len = (size_t )0;
      me = mount_list;
      while (me) {
        tmp___3 = strcmp((char const   *)me->me_type, "lofs");
        if (! (tmp___3 == 0)) {
          if (! best_match) {
            goto _L___0;
          } else
          if (best_match->me_dummy) {
            goto _L___0;
          } else
          if (! me->me_dummy) {
            _L___0: /* CIL Label */ 
            tmp___1 = strlen((char const   *)me->me_mountdir);
            len = tmp___1;
            if (best_match_len <= len) {
              if (len <= resolved_len) {
                if (len == 1UL) {
                  best_match = (struct mount_entry  const  *)me;
                  best_match_len = len;
                } else
                if (len == resolved_len) {
                  goto _L;
                } else
                if ((int )*(resolved + len) == 47) {
                  _L: /* CIL Label */ 
                  tmp___2 = strncmp((char const   *)me->me_mountdir, (char const   *)resolved,
                                    len);
                  if (tmp___2 == 0) {
                    best_match = (struct mount_entry  const  *)me;
                    best_match_len = len;
                  }
                }
              }
            }
          }
        }
        me = me->me_next;
      }
    }
  }
  free((void *)resolved);
  if (best_match) {
    tmp___4 = stat((char const   * __restrict  )best_match->me_mountdir, (struct stat * __restrict  )(& disk_stats));
    if (tmp___4 != 0) {
      best_match = (struct mount_entry  const  *)((void *)0);
    } else
    if (disk_stats.st_dev != (__dev_t )statp->st_dev) {
      best_match = (struct mount_entry  const  *)((void *)0);
    }
  }
  if (! best_match) {
    me = mount_list;
    while (me) {
      if (me->me_dev == 0xffffffffffffffffUL) {
        tmp___8 = stat((char const   * __restrict  )me->me_mountdir, (struct stat * __restrict  )(& disk_stats));
        if (tmp___8 == 0) {
          me->me_dev = disk_stats.st_dev;
        } else {
          tmp___7 = __errno_location();
          if (*tmp___7 == 5) {
            tmp___5 = quote((char const   *)me->me_mountdir);
            tmp___6 = __errno_location();
            error(0, *tmp___6, "%s", tmp___5);
            exit_status = 1;
          }
          me->me_dev = (dev_t )-2;
        }
      }
      if (statp->st_dev == (__dev_t const   )me->me_dev) {
        tmp___10 = strcmp((char const   *)me->me_type, "lofs");
        if (! (tmp___10 == 0)) {
          if (! best_match) {
            goto _L___1;
          } else
          if (best_match->me_dummy) {
            goto _L___1;
          } else
          if (! me->me_dummy) {
            _L___1: /* CIL Label */ 
            tmp___9 = stat((char const   * __restrict  )me->me_mountdir, (struct stat * __restrict  )(& disk_stats));
            if (tmp___9 != 0) {
              me->me_dev = (dev_t )-2;
            } else
            if (disk_stats.st_dev != me->me_dev) {
              me->me_dev = (dev_t )-2;
            } else {
              best_match = (struct mount_entry  const  *)me;
            }
          }
        }
      }
      me = me->me_next;
    }
  }
  if (best_match) {
    get_dev((char const   *)best_match->me_devname, (char const   *)best_match->me_mountdir,
            point, (char const   *)best_match->me_type, (_Bool )best_match->me_dummy,
            (_Bool )best_match->me_remote, (struct fs_usage  const  *)((void *)0));
  } else {
    tmp___11 = find_mount_point(point, statp);
    mp = tmp___11;
    if (mp) {
      get_dev((char const   *)((void *)0), (char const   *)mp, (char const   *)((void *)0),
              (char const   *)((void *)0), (_Bool)0, (_Bool)0, (struct fs_usage  const  *)((void *)0));
      free((void *)mp);
    }
  }
  return;
}
}
static void get_entry(char const   *name , struct stat  const  *statp ) 
{ _Bool tmp ;

  {
  if ((statp->st_mode & 61440U) == 24576U) {
    goto _L;
  } else
  if ((statp->st_mode & 61440U) == 8192U) {
    _L: /* CIL Label */ 
    tmp = get_disk(name);
    if (tmp) {
      return;
    }
  }
  get_point(name, statp);
  return;
}
}
static void get_all_entries(void) 
{ struct mount_entry *me ;

  {
  me = mount_list;
  while (me) {
    get_dev((char const   *)me->me_devname, (char const   *)me->me_mountdir, (char const   *)((void *)0),
            (char const   *)me->me_type, (_Bool )me->me_dummy, (_Bool )me->me_remote,
            (struct fs_usage  const  *)((void *)0));
    me = me->me_next;
  }
  return;
}
}
static void add_fs_type(char const   *fstype ) 
{ struct fs_type_list *fsp ;
  void *tmp ;

  {
  tmp = xmalloc(sizeof(*fsp));
  fsp = (struct fs_type_list *)tmp;
  fsp->fs_name = (char *)fstype;
  fsp->fs_next = fs_select_list;
  fs_select_list = fsp;
  return;
}
}
static void add_excluded_fs_type(char const   *fstype ) 
{ struct fs_type_list *fsp ;
  void *tmp ;

  {
  tmp = xmalloc(sizeof(*fsp));
  fsp = (struct fs_type_list *)tmp;
  fsp->fs_name = (char *)fstype;
  fsp->fs_next = fs_exclude_list;
  fs_exclude_list = fsp;
  return;
}
}
 __attribute__((__noreturn__)) void usage(int status ) ;
void usage(int status ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  if (status != 0) {
    tmp = gettext("Try `%s --help\' for more information.\n");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, program_name);
  } else {
    tmp___0 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf((char const   * __restrict  )tmp___0, program_name);
    tmp___1 = gettext("Show information about the file system on which each FILE resides,\nor all file systems by default.\n\n");
    fputs_unlocked((char const   * __restrict  )tmp___1, (FILE * __restrict  )stdout);
    tmp___2 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
    fputs_unlocked((char const   * __restrict  )tmp___2, (FILE * __restrict  )stdout);
    tmp___3 = gettext("  -a, --all             include dummy file systems\n  -B, --block-size=SIZE  scale sizes by SIZE before printing them.  E.g.,\n                           `-BM\' prints sizes in units of 1,048,576 bytes.\n                           See SIZE format below.\n      --total           produce a grand total\n  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\n  -H, --si              likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked((char const   * __restrict  )tmp___3, (FILE * __restrict  )stdout);
    tmp___4 = gettext("  -i, --inodes          list inode information instead of block usage\n  -k                    like --block-size=1K\n  -l, --local           limit listing to local file systems\n      --no-sync         do not invoke sync before getting usage info (default)\n");
    fputs_unlocked((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
    tmp___5 = gettext("  -P, --portability     use the POSIX output format\n      --sync            invoke sync before getting usage info\n  -t, --type=TYPE       limit listing to file systems of type TYPE\n  -T, --print-type      print file system type\n  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n  -v                    (ignored)\n");
    fputs_unlocked((char const   * __restrict  )tmp___5, (FILE * __restrict  )stdout);
    tmp___6 = gettext("      --help     display this help and exit\n");
    fputs_unlocked((char const   * __restrict  )tmp___6, (FILE * __restrict  )stdout);
    tmp___7 = gettext("      --version  output version information and exit\n");
    fputs_unlocked((char const   * __restrict  )tmp___7, (FILE * __restrict  )stdout);
    emit_blocksize_note("DF");
    emit_size_note();
    emit_ancillary_info();
  }
  exit(status);
}
}
int main(int argc , char **argv ) 
{ struct stat *stats ;
  int oi ;
  int c ;
  int tmp ;
  enum strtol_error e ;
  enum strtol_error tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool match ;
  struct fs_type_list *fs_incl ;
  struct fs_type_list *fs_excl ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int i ;
  void *tmp___8 ;
  int fd ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int status ;
  int tmp___15 ;
  char const   *warning ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  int i___0 ;
  char *tmp___20 ;

  {
  set_program_name((char const   *)*(argv + 0));
  setlocale(6, "");
  bindtextdomain("coreutils", "/usr/local/share/locale");
  textdomain("coreutils");
  atexit(& close_stdout);
  fs_select_list = (struct fs_type_list *)((void *)0);
  fs_exclude_list = (struct fs_type_list *)((void *)0);
  inode_format = (_Bool)0;
  show_all_fs = (_Bool)0;
  show_listed_fs = (_Bool)0;
  human_output_opts = -1;
  print_type = (_Bool)0;
  file_systems_processed = (_Bool)0;
  posix_format = (_Bool)0;
  exit_status = 0;
  print_grand_total = (_Bool)0;
  grand_fsu.fsu_blocksize = (uintmax_t )1;
  while (1) {
    oi = -1;
    tmp = rpl_getopt_long(argc, argv, "aB:iF:hHklmPTt:vx:", long_options___0, & oi);
    c = tmp;
    if (c == -1) {
      break;
    }
    switch (c) {
    case 97: 
    show_all_fs = (_Bool)1;
    break;
    case 66: 
    tmp___0 = human_options((char const   *)rpl_optarg, & human_output_opts, & output_block_size);
    e = tmp___0;
    if ((unsigned int )e != 0U) {
      xstrtol_fatal(e, oi, (char )c, long_options___0, (char const   *)rpl_optarg);
    }
    break;
    case 105: 
    inode_format = (_Bool)1;
    break;
    case 104: 
    human_output_opts = 176;
    output_block_size = (uintmax_t )1;
    break;
    case 72: 
    human_output_opts = 144;
    output_block_size = (uintmax_t )1;
    break;
    case 107: 
    human_output_opts = 0;
    output_block_size = (uintmax_t )1024;
    break;
    case 108: 
    show_local_fs = (_Bool)1;
    break;
    case 109: 
    human_output_opts = 0;
    output_block_size = (uintmax_t )1048576;
    break;
    case 84: 
    print_type = (_Bool)1;
    break;
    case 80: 
    posix_format = (_Bool)1;
    break;
    case 129: 
    require_sync = (_Bool)1;
    break;
    case 128: 
    require_sync = (_Bool)0;
    break;
    case 70: 
    case 116: 
    add_fs_type((char const   *)rpl_optarg);
    break;
    case 118: 
    break;
    case 120: 
    add_excluded_fs_type((char const   *)rpl_optarg);
    break;
    case 99: 
    print_grand_total = (_Bool)1;
    break;
    case -130: 
    usage(0);
    break;
    case -131: 
    tmp___1 = proper_name_utf8("Torbjorn Granlund", "Torbj\303\266rn Granlund");
    version_etc(stdout, "df", "GNU coreutils", Version, tmp___1, "David MacKenzie",
                "Paul Eggert", (char *)((void *)0));
    exit(0);
    break;
    default: 
    usage(1);
    }
  }
  if (human_output_opts == -1) {
    if (posix_format) {
      human_output_opts = 0;
      tmp___3 = getenv("POSIXLY_CORRECT");
      if (tmp___3) {
        output_block_size = (uintmax_t )512;
      } else {
        output_block_size = (uintmax_t )1024;
      }
    } else {
      tmp___4 = getenv("DF_BLOCK_SIZE");
      human_options((char const   *)tmp___4, & human_output_opts, & output_block_size);
    }
  }
  if (inode_format) {
    header_mode = 1;
  } else
  if (human_output_opts & 16) {
    header_mode = 2;
  } else
  if (posix_format) {
    header_mode = 3;
  }
  match = (_Bool)0;
  fs_incl = fs_select_list;
  while (fs_incl) {
    fs_excl = fs_exclude_list;
    while (fs_excl) {
      tmp___7 = strcmp((char const   *)fs_incl->fs_name, (char const   *)fs_excl->fs_name);
      if (tmp___7 == 0) {
        tmp___5 = quote((char const   *)fs_incl->fs_name);
        tmp___6 = gettext("file system type %s both selected and excluded");
        error(0, 0, (char const   *)tmp___6, tmp___5);
        match = (_Bool)1;
        break;
      }
      fs_excl = fs_excl->fs_next;
    }
    fs_incl = fs_incl->fs_next;
  }
  if (match) {
    exit(1);
  }
  if (rpl_optind < argc) {
    tmp___8 = xnmalloc((size_t )(argc - rpl_optind), sizeof(*stats));
    stats = (struct stat *)tmp___8;
    i = rpl_optind;
    while (i < argc) {
      tmp___9 = (int )open((char const   *)*(argv + i), 256);
      fd = tmp___9;
      if (fd < 0) {
        goto _L;
      } else {
        tmp___12 = fstat(fd, stats + (i - rpl_optind));
        if (tmp___12) {
          _L: /* CIL Label */ 
          tmp___13 = stat((char const   * __restrict  )*(argv + i), (struct stat * __restrict  )(stats + (i - rpl_optind)));
          if (tmp___13) {
            tmp___10 = quote((char const   *)*(argv + i));
            tmp___11 = __errno_location();
            error(0, *tmp___11, "%s", tmp___10);
            exit_status = 1;
            *(argv + i) = (char *)((void *)0);
          }
        }
      }
      if (0 <= fd) {
        close(fd);
      }
      i ++;
    }
  }
  if ((unsigned long )fs_select_list != (unsigned long )((void *)0)) {
    tmp___14 = 1;
  } else
  if ((unsigned long )fs_exclude_list != (unsigned long )((void *)0)) {
    tmp___14 = 1;
  } else
  if (print_type) {
    tmp___14 = 1;
  } else
  if (show_local_fs) {
    tmp___14 = 1;
  } else {
    tmp___14 = 0;
  }
  mount_list = read_file_system_list((_Bool )tmp___14);
  if ((unsigned long )mount_list == (unsigned long )((void *)0)) {
    if (rpl_optind < argc) {
      tmp___15 = 0;
    } else {
      tmp___15 = 1;
    }
    status = tmp___15;
    if (rpl_optind < argc) {
      tmp___16 = gettext("Warning: ");
      tmp___17 = (char const   *)tmp___16;
    } else {
      tmp___17 = "";
    }
    warning = tmp___17;
    tmp___18 = gettext("cannot read table of mounted file systems");
    tmp___19 = __errno_location();
    error(status, *tmp___19, "%s%s", warning, tmp___18);
  }
  if (require_sync) {
    sync();
  }
  if (rpl_optind < argc) {
    show_listed_fs = (_Bool)1;
    i___0 = rpl_optind;
    while (i___0 < argc) {
      if (*(argv + i___0)) {
        get_entry((char const   *)*(argv + i___0), (struct stat  const  *)(stats + (i___0 - rpl_optind)));
      }
      i___0 ++;
    }
  } else {
    get_all_entries();
  }
  if (print_grand_total) {
    if (inode_format) {
      grand_fsu.fsu_blocks = (uintmax_t )1;
    }
    get_dev("total", (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
            (_Bool)0, (_Bool)0, (struct fs_usage  const  *)(& grand_fsu));
  }
  print_table();
  if (! file_systems_processed) {
    tmp___20 = gettext("no file systems processed");
    error(1, 0, (char const   *)tmp___20);
  }
  exit(exit_status);
}
}
extern char *find_mount_point(char const   *file , struct stat  const  *file_stat ) 
{ struct saved_cwd cwd ;
  struct stat last_stat ;
  char *mp ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *xdir ;
  char *tmp___6 ;
  char *dir ;
  char const   *__old ;
  size_t __len ;
  size_t tmp___7 ;
  char *__new ;
  void *tmp___8 ;
  void *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  struct stat st ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  int save_errno ;
  int *tmp___26 ;
  char *tmp___27 ;
  int *tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;

  {
  mp = (char *)((void *)0);
  tmp___1 = save_cwd(& cwd);
  if (tmp___1 != 0) {
    tmp = gettext("cannot get current directory");
    tmp___0 = __errno_location();
    error(0, *tmp___0, (char const   *)tmp);
    return ((char *)((void *)0));
  }
  if ((file_stat->st_mode & 61440U) == 16384U) {
    last_stat = (struct stat )*file_stat;
    tmp___5 = chdir(file);
    if (tmp___5 < 0) {
      tmp___2 = quote(file);
      tmp___3 = gettext("cannot change to directory %s");
      tmp___4 = __errno_location();
      error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
      return ((char *)((void *)0));
    }
  } else {
    tmp___6 = dir_name(file);
    xdir = tmp___6;
    while (1) {
      __old = (char const   *)xdir;
      tmp___7 = strlen(__old);
      __len = tmp___7 + 1UL;
      tmp___8 = __builtin_alloca(__len);
      __new = (char *)tmp___8;
      tmp___9 = (void *)memcpy((void * __restrict  )__new, (void const   * __restrict  )__old,
                               __len);
      dir = (char *)tmp___9;
      break;
    }
    free((void *)xdir);
    tmp___13 = chdir((char const   *)dir);
    if (tmp___13 < 0) {
      tmp___10 = quote((char const   *)dir);
      tmp___11 = gettext("cannot change to directory %s");
      tmp___12 = __errno_location();
      error(0, *tmp___12, (char const   *)tmp___11, tmp___10);
      return ((char *)((void *)0));
    }
    tmp___17 = stat((char const   * __restrict  )".", (struct stat * __restrict  )(& last_stat));
    if (tmp___17 < 0) {
      tmp___14 = quote((char const   *)dir);
      tmp___15 = gettext("cannot stat current directory (now %s)");
      tmp___16 = __errno_location();
      error(0, *tmp___16, (char const   *)tmp___15, tmp___14);
      goto done;
    }
  }
  while (1) {
    tmp___21 = stat((char const   * __restrict  )"..", (struct stat * __restrict  )(& st));
    if (tmp___21 < 0) {
      tmp___18 = quote("..");
      tmp___19 = gettext("cannot stat %s");
      tmp___20 = __errno_location();
      error(0, *tmp___20, (char const   *)tmp___19, tmp___18);
      goto done;
    }
    if (st.st_dev != last_stat.st_dev) {
      break;
    } else
    if (st.st_ino == last_stat.st_ino) {
      break;
    }
    tmp___25 = chdir("..");
    if (tmp___25 < 0) {
      tmp___22 = quote("..");
      tmp___23 = gettext("cannot change to directory %s");
      tmp___24 = __errno_location();
      error(0, *tmp___24, (char const   *)tmp___23, tmp___22);
      goto done;
    }
    last_stat = st;
  }
  mp = xgetcwd();
  done: 
  tmp___26 = __errno_location();
  save_errno = *tmp___26;
  tmp___29 = restore_cwd((struct saved_cwd  const  *)(& cwd));
  if (tmp___29 != 0) {
    tmp___27 = gettext("failed to return to initial working directory");
    tmp___28 = __errno_location();
    error(1, *tmp___28, (char const   *)tmp___27);
  }
  free_cwd(& cwd);
  tmp___30 = __errno_location();
  *tmp___30 = save_errno;
  return (mp);
}
}
